{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentazione ITS Fantastici \u00b6 Questa piattaforma raccoglie la documentazione tecnica dei corsi ITS Fantastici. L\u2019obiettivo non \u00e8 fornire semplici appunti, ma costruire una base di conoscenza strutturata, collaborativa e riutilizzabile , orientata allo sviluppo di competenze reali e alla risoluzione di problemi concreti. Caratteristiche principali \u00b6 organizzazione per corsi e moduli documentazione versionata tramite Git contributi collaborativi con revisione della community esempi pratici e progetto unico per ogni corso focus su scalabilit\u00e0, modellizzazione e correttezza tecnica Corsi disponibili \u00b6 Vai all\u2019 indice dei corsi .","title":"Home"},{"location":"#documentazione-its-fantastici","text":"Questa piattaforma raccoglie la documentazione tecnica dei corsi ITS Fantastici. L\u2019obiettivo non \u00e8 fornire semplici appunti, ma costruire una base di conoscenza strutturata, collaborativa e riutilizzabile , orientata allo sviluppo di competenze reali e alla risoluzione di problemi concreti.","title":"Documentazione ITS Fantastici"},{"location":"#caratteristiche-principali","text":"organizzazione per corsi e moduli documentazione versionata tramite Git contributi collaborativi con revisione della community esempi pratici e progetto unico per ogni corso focus su scalabilit\u00e0, modellizzazione e correttezza tecnica","title":"Caratteristiche principali"},{"location":"#corsi-disponibili","text":"Vai all\u2019 indice dei corsi .","title":"Corsi disponibili"},{"location":"esempio-lezione/","text":"Lezione XX \u2014 Titolo \u00b6 Problema \u00b6 Descrizione chiara e concreta del problema che vogliamo risolvere. contesto reale vincoli noti cosa non sappiamo ancora fare perch\u00e9 il problema \u00e8 rilevante Questa sezione d\u00e0 senso a tutta la lezione. Teoria \u00b6 Spiegazione dei concetti necessari solo per affrontare il problema. definizioni modelli concettuali regole e vincoli diagrammi (se servono) La teoria non \u00e8 fine a s\u00e9 stessa , ma strumentale. Esempi \u00b6 Applicazione pratica immediata dei concetti teorici. esempi SQL commentati casi semplici \u2192 casi realistici tutto coerente con il progetto unico ```sql -- esempio esplicativo SELECT ...","title":"Esempio lezione"},{"location":"esempio-lezione/#lezione-xx-titolo","text":"","title":"Lezione XX \u2014 Titolo"},{"location":"esempio-lezione/#problema","text":"Descrizione chiara e concreta del problema che vogliamo risolvere. contesto reale vincoli noti cosa non sappiamo ancora fare perch\u00e9 il problema \u00e8 rilevante Questa sezione d\u00e0 senso a tutta la lezione.","title":"Problema"},{"location":"esempio-lezione/#teoria","text":"Spiegazione dei concetti necessari solo per affrontare il problema. definizioni modelli concettuali regole e vincoli diagrammi (se servono) La teoria non \u00e8 fine a s\u00e9 stessa , ma strumentale.","title":"Teoria"},{"location":"esempio-lezione/#esempi","text":"Applicazione pratica immediata dei concetti teorici. esempi SQL commentati casi semplici \u2192 casi realistici tutto coerente con il progetto unico ```sql -- esempio esplicativo SELECT ...","title":"Esempi"},{"location":"community/","text":"Community \u00b6 Questo corso \u00e8 costruito come documentazione collaborativa . Gli studenti non sono semplici fruitori, ma parte attiva nel miglioramento: - delle spiegazioni - degli esempi - degli esercizi - delle soluzioni Principi fondamentali \u00b6 la documentazione \u00e8 viva le soluzioni sono motivate, non \u201cgiuste\u201d le decisioni sono argomentate la qualit\u00e0 \u00e8 responsabilit\u00e0 collettiva Come contribuire \u00b6 \u00c8 possibile contribuire tramite: - proposte di esercizi - miglioramenti delle spiegazioni - estensioni delle soluzioni - correzioni tecniche Tutte le modifiche avvengono tramite Pull Request su GitHub . Approvazione delle modifiche \u00b6 Una modifica viene integrata solo se: - \u00e8 tecnicamente corretta - \u00e8 chiara e ben spiegata - viene approvata da almeno 50% + 1 degli studenti Documentazione di riferimento \u00b6 Linee guida Workflow di contribuzione","title":"Introduzione"},{"location":"community/#community","text":"Questo corso \u00e8 costruito come documentazione collaborativa . Gli studenti non sono semplici fruitori, ma parte attiva nel miglioramento: - delle spiegazioni - degli esempi - degli esercizi - delle soluzioni","title":"Community"},{"location":"community/#principi-fondamentali","text":"la documentazione \u00e8 viva le soluzioni sono motivate, non \u201cgiuste\u201d le decisioni sono argomentate la qualit\u00e0 \u00e8 responsabilit\u00e0 collettiva","title":"Principi fondamentali"},{"location":"community/#come-contribuire","text":"\u00c8 possibile contribuire tramite: - proposte di esercizi - miglioramenti delle spiegazioni - estensioni delle soluzioni - correzioni tecniche Tutte le modifiche avvengono tramite Pull Request su GitHub .","title":"Come contribuire"},{"location":"community/#approvazione-delle-modifiche","text":"Una modifica viene integrata solo se: - \u00e8 tecnicamente corretta - \u00e8 chiara e ben spiegata - viene approvata da almeno 50% + 1 degli studenti","title":"Approvazione delle modifiche"},{"location":"community/#documentazione-di-riferimento","text":"Linee guida Workflow di contribuzione","title":"Documentazione di riferimento"},{"location":"community/linee-guida/","text":"Linee guida della community \u00b6 Questa documentazione \u00e8 collaborativa . Il suo valore dipende dalla qualit\u00e0 dei contributi , non dalla quantit\u00e0. Queste linee guida definiscono come contribuire correttamente . Principi fondamentali \u00b6 Ogni contributo deve rispettare i seguenti principi: 1. Correttezza tecnica \u00b6 le informazioni devono essere verificabili niente scorciatoie concettuali niente soluzioni \u201cfunzionano ma non si spiegano\u201d 2. Chiarezza \u00b6 spiegare perch\u00e9 una scelta \u00e8 corretta evitare ambiguit\u00e0 usare terminologia coerente con il corso 3. Coerenza con il progetto \u00b6 ogni esempio deve essere coerente con il modello dati evitare esempi isolati o fuori contesto il progetto \u00e8 il filo conduttore 4. DB-agnostic \u00b6 preferire SQL standard specificare quando qualcosa \u00e8 dipendente dal database evitare soluzioni specifiche se non motivate Tipologie di contributo accettate \u00b6 \u00c8 possibile contribuire con: nuovi esercizi di approfondimento miglioramenti alle spiegazioni soluzioni alternative ben motivate correzioni concettuali chiarimenti su punti complessi Non sono accettati: - esercizi \u201cda verifica\u201d - soluzioni senza spiegazione - duplicazioni inutili - contenuti fuori scope Stile della documentazione \u00b6 usare Markdown conforme allo standard del corso seguire il template di lezione codice sempre commentato esempi realistici, non astratti Responsabilit\u00e0 \u00b6 Ogni contributore \u00e8 responsabile di: - ci\u00f2 che propone - la qualit\u00e0 tecnica del contenuto - l\u2019impatto sul resto del corso La community valuta contenuto , non persone.","title":"Linee guida"},{"location":"community/linee-guida/#linee-guida-della-community","text":"Questa documentazione \u00e8 collaborativa . Il suo valore dipende dalla qualit\u00e0 dei contributi , non dalla quantit\u00e0. Queste linee guida definiscono come contribuire correttamente .","title":"Linee guida della community"},{"location":"community/linee-guida/#principi-fondamentali","text":"Ogni contributo deve rispettare i seguenti principi:","title":"Principi fondamentali"},{"location":"community/linee-guida/#1-correttezza-tecnica","text":"le informazioni devono essere verificabili niente scorciatoie concettuali niente soluzioni \u201cfunzionano ma non si spiegano\u201d","title":"1. Correttezza tecnica"},{"location":"community/linee-guida/#2-chiarezza","text":"spiegare perch\u00e9 una scelta \u00e8 corretta evitare ambiguit\u00e0 usare terminologia coerente con il corso","title":"2. Chiarezza"},{"location":"community/linee-guida/#3-coerenza-con-il-progetto","text":"ogni esempio deve essere coerente con il modello dati evitare esempi isolati o fuori contesto il progetto \u00e8 il filo conduttore","title":"3. Coerenza con il progetto"},{"location":"community/linee-guida/#4-db-agnostic","text":"preferire SQL standard specificare quando qualcosa \u00e8 dipendente dal database evitare soluzioni specifiche se non motivate","title":"4. DB-agnostic"},{"location":"community/linee-guida/#tipologie-di-contributo-accettate","text":"\u00c8 possibile contribuire con: nuovi esercizi di approfondimento miglioramenti alle spiegazioni soluzioni alternative ben motivate correzioni concettuali chiarimenti su punti complessi Non sono accettati: - esercizi \u201cda verifica\u201d - soluzioni senza spiegazione - duplicazioni inutili - contenuti fuori scope","title":"Tipologie di contributo accettate"},{"location":"community/linee-guida/#stile-della-documentazione","text":"usare Markdown conforme allo standard del corso seguire il template di lezione codice sempre commentato esempi realistici, non astratti","title":"Stile della documentazione"},{"location":"community/linee-guida/#responsabilita","text":"Ogni contributore \u00e8 responsabile di: - ci\u00f2 che propone - la qualit\u00e0 tecnica del contenuto - l\u2019impatto sul resto del corso La community valuta contenuto , non persone.","title":"Responsabilit\u00e0"},{"location":"community/workflow/","text":"Workflow di contribuzione \u00b6 Questo documento descrive il processo operativo per proporre modifiche alla documentazione del corso. Tutte le modifiche passano tramite Git e GitHub . Strumenti \u00b6 repository GitHub: itsfantastici/docs branch principale: main contributi tramite Pull Request Non sono consentite modifiche dirette su main . Flusso di lavoro \u00b6 1. Fork o branch \u00b6 crea un fork del repository oppure crea un branch dedicato Nome branch consigliato: feature/nome-breve fix/descrizione-breve yaml Copia codice 2. Apporta le modifiche \u00b6 lavora solo sui file rilevanti mantieni le modifiche focalizzate rispetta struttura e template 3. Apri una Pull Request \u00b6 La Pull Request deve includere: descrizione chiara del cambiamento motivazione tecnica riferimento alla lezione/modulo coinvolto Pull Request vaghe o senza contesto verranno rifiutate . 4. Revisione della community \u00b6 Una Pull Request viene accettata solo se: \u00e8 tecnicamente corretta \u00e8 coerente con il corso \u00e8 chiara e ben spiegata ottiene l\u2019approvazione di almeno 50% + 1 degli studenti La revisione avviene tramite: - commenti - richieste di modifica - approvazioni GitHub 5. Approvazione finale \u00b6 Dopo il raggiungimento di 50% + 1 : - la Pull Request pu\u00f2 essere unita - il maintainer del corso (painic) ha l\u2019ultima parola tecnica Casi particolari \u00b6 Modifiche strutturali \u00b6 cambi di modello dati riorganizzazione moduli modifiche al template \ud83d\udc49 richiedono discussione preventiva e consenso esplicito. Correzioni urgenti \u00b6 errori concettuali gravi informazioni errate \ud83d\udc49 possono essere approvate pi\u00f9 rapidamente. Buone pratiche \u00b6 una PR = un obiettivo preferire modifiche piccole ma chiare discutere prima cambiamenti grandi documentare sempre il perch\u00e9","title":"Workflow di contribuzione"},{"location":"community/workflow/#workflow-di-contribuzione","text":"Questo documento descrive il processo operativo per proporre modifiche alla documentazione del corso. Tutte le modifiche passano tramite Git e GitHub .","title":"Workflow di contribuzione"},{"location":"community/workflow/#strumenti","text":"repository GitHub: itsfantastici/docs branch principale: main contributi tramite Pull Request Non sono consentite modifiche dirette su main .","title":"Strumenti"},{"location":"community/workflow/#flusso-di-lavoro","text":"","title":"Flusso di lavoro"},{"location":"community/workflow/#1-fork-o-branch","text":"crea un fork del repository oppure crea un branch dedicato Nome branch consigliato: feature/nome-breve fix/descrizione-breve yaml Copia codice","title":"1. Fork o branch"},{"location":"community/workflow/#2-apporta-le-modifiche","text":"lavora solo sui file rilevanti mantieni le modifiche focalizzate rispetta struttura e template","title":"2. Apporta le modifiche"},{"location":"community/workflow/#3-apri-una-pull-request","text":"La Pull Request deve includere: descrizione chiara del cambiamento motivazione tecnica riferimento alla lezione/modulo coinvolto Pull Request vaghe o senza contesto verranno rifiutate .","title":"3. Apri una Pull Request"},{"location":"community/workflow/#4-revisione-della-community","text":"Una Pull Request viene accettata solo se: \u00e8 tecnicamente corretta \u00e8 coerente con il corso \u00e8 chiara e ben spiegata ottiene l\u2019approvazione di almeno 50% + 1 degli studenti La revisione avviene tramite: - commenti - richieste di modifica - approvazioni GitHub","title":"4. Revisione della community"},{"location":"community/workflow/#5-approvazione-finale","text":"Dopo il raggiungimento di 50% + 1 : - la Pull Request pu\u00f2 essere unita - il maintainer del corso (painic) ha l\u2019ultima parola tecnica","title":"5. Approvazione finale"},{"location":"community/workflow/#casi-particolari","text":"","title":"Casi particolari"},{"location":"community/workflow/#modifiche-strutturali","text":"cambi di modello dati riorganizzazione moduli modifiche al template \ud83d\udc49 richiedono discussione preventiva e consenso esplicito.","title":"Modifiche strutturali"},{"location":"community/workflow/#correzioni-urgenti","text":"errori concettuali gravi informazioni errate \ud83d\udc49 possono essere approvate pi\u00f9 rapidamente.","title":"Correzioni urgenti"},{"location":"community/workflow/#buone-pratiche","text":"una PR = un obiettivo preferire modifiche piccole ma chiare discutere prima cambiamenti grandi documentare sempre il perch\u00e9","title":"Buone pratiche"},{"location":"corsi/","text":"Corsi \u00b6 In questa sezione trovi tutti i corsi documentati sulla piattaforma. Ogni corso segue uno standard comune : - un problema iniziale da risolvere - sviluppo incrementale delle competenze - progetto unico come filo conduttore - contributi della community integrati nella documentazione Elenco corsi \u00b6 Come usare CLI - Terminale UNIX Come usare MarkDown Come usare makedock (python) Corso Database SQL","title":"Indice corsi"},{"location":"corsi/#corsi","text":"In questa sezione trovi tutti i corsi documentati sulla piattaforma. Ogni corso segue uno standard comune : - un problema iniziale da risolvere - sviluppo incrementale delle competenze - progetto unico come filo conduttore - contributi della community integrati nella documentazione","title":"Corsi"},{"location":"corsi/#elenco-corsi","text":"Come usare CLI - Terminale UNIX Come usare MarkDown Come usare makedock (python) Corso Database SQL","title":"Elenco corsi"},{"location":"corsi/cli/","text":"Corso CLI - Command Line Interface \u00b6 Il corso \u00e8 organizzato in lezioni progressive , pensate per costruire prima il modello mentale e poi le competenze operative. Ogni lezione: introduce concetti chiave prepara la base per la lezione successiva evita salti logici Partecipazione della community \u00b6 Gli studenti possono: - proporre esercizi - migliorare spiegazioni - suggerire soluzioni alternative Ogni modifica passa tramite Pull Request e viene approvata secondo la regola 50% + 1 . Tecnologie utilizzate \u00b6 Raspberry Pi con Raspberry OS (basato su Debian) Navigazione rapida \u00b6 Moduli Linee guida community","title":"Indice moduli"},{"location":"corsi/cli/#corso-cli-command-line-interface","text":"Il corso \u00e8 organizzato in lezioni progressive , pensate per costruire prima il modello mentale e poi le competenze operative. Ogni lezione: introduce concetti chiave prepara la base per la lezione successiva evita salti logici","title":"Corso CLI - Command Line Interface"},{"location":"corsi/cli/#partecipazione-della-community","text":"Gli studenti possono: - proporre esercizi - migliorare spiegazioni - suggerire soluzioni alternative Ogni modifica passa tramite Pull Request e viene approvata secondo la regola 50% + 1 .","title":"Partecipazione della community"},{"location":"corsi/cli/#tecnologie-utilizzate","text":"Raspberry Pi con Raspberry OS (basato su Debian)","title":"Tecnologie utilizzate"},{"location":"corsi/cli/#navigazione-rapida","text":"Moduli Linee guida community","title":"Navigazione rapida"},{"location":"corsi/cli/moduli/","text":"Moduli del corso \u00b6 Il corso CLI - Command Line Interface \u00e8 strutturato in moduli progressivi . Ogni modulo: introduce nuovi concetti risolve problemi che emergono dal progetto estende ci\u00f2 che \u00e8 stato costruito nei moduli precedenti Non esistono moduli indipendenti: il corso \u00e8 cumulativo . Come usare i moduli \u00b6 segui i moduli in ordine non saltare le lezioni iniziali usa il progetto come riferimento costante confronta teoria, esempi ed esercizi con il modello dati Elenco dei moduli \u00b6 Modulo 01 \u2014 Fondamenti della CLI \u00b6 Costruisce il modello mentale corretto . Contenuti chiave: introduzione storico\u2011generale (breve) CLI \u2260 terminale shell e interprete dei comandi filosofia UNIX \ud83d\udc49 Vai al modulo Modulo 02 \u2014 Filesystem \u00b6 Introduce la struttura dei file e la navigazione. Contenuti chiave: gerarchia standard path assoluto e relativo working directory concetti chiave (file, directory, inode, link) \ud83d\udc49 Vai al modulo Output complessivo del corso \u00b6 Al termine di tutti i moduli, lo studente avr\u00e0: una comprensione solida del modello UNIX e del ruolo della shell capacit\u00e0 di navigare e manipolare il filesystem in modo sicuro ed efficiente padronanza dei permessi, della propriet\u00e0 dei file e delle buone pratiche di sicurezza uso quotidiano dei comandi core per ispezionare, cercare e trasformare dati abilit\u00e0 nel comporre pipeline con pipe e redirection per automatizzare task ripetitivi confidenza con variabili, ambiente e contesto di esecuzione ( PATH incluso) strumenti di base per gestire processi, job control e segnali metodo per fare debug, leggere log e monitorare risorse da terminale competenze essenziali di networking da CLI per diagnosi e accesso remoto Navigazione \u00b6 Home corso Community","title":"Indice"},{"location":"corsi/cli/moduli/#moduli-del-corso","text":"Il corso CLI - Command Line Interface \u00e8 strutturato in moduli progressivi . Ogni modulo: introduce nuovi concetti risolve problemi che emergono dal progetto estende ci\u00f2 che \u00e8 stato costruito nei moduli precedenti Non esistono moduli indipendenti: il corso \u00e8 cumulativo .","title":"Moduli del corso"},{"location":"corsi/cli/moduli/#come-usare-i-moduli","text":"segui i moduli in ordine non saltare le lezioni iniziali usa il progetto come riferimento costante confronta teoria, esempi ed esercizi con il modello dati","title":"Come usare i moduli"},{"location":"corsi/cli/moduli/#elenco-dei-moduli","text":"","title":"Elenco dei moduli"},{"location":"corsi/cli/moduli/#modulo-01-fondamenti-della-cli","text":"Costruisce il modello mentale corretto . Contenuti chiave: introduzione storico\u2011generale (breve) CLI \u2260 terminale shell e interprete dei comandi filosofia UNIX \ud83d\udc49 Vai al modulo","title":"Modulo 01 \u2014 Fondamenti della CLI"},{"location":"corsi/cli/moduli/#modulo-02-filesystem","text":"Introduce la struttura dei file e la navigazione. Contenuti chiave: gerarchia standard path assoluto e relativo working directory concetti chiave (file, directory, inode, link) \ud83d\udc49 Vai al modulo","title":"Modulo 02 \u2014 Filesystem"},{"location":"corsi/cli/moduli/#output-complessivo-del-corso","text":"Al termine di tutti i moduli, lo studente avr\u00e0: una comprensione solida del modello UNIX e del ruolo della shell capacit\u00e0 di navigare e manipolare il filesystem in modo sicuro ed efficiente padronanza dei permessi, della propriet\u00e0 dei file e delle buone pratiche di sicurezza uso quotidiano dei comandi core per ispezionare, cercare e trasformare dati abilit\u00e0 nel comporre pipeline con pipe e redirection per automatizzare task ripetitivi confidenza con variabili, ambiente e contesto di esecuzione ( PATH incluso) strumenti di base per gestire processi, job control e segnali metodo per fare debug, leggere log e monitorare risorse da terminale competenze essenziali di networking da CLI per diagnosi e accesso remoto","title":"Output complessivo del corso"},{"location":"corsi/cli/moduli/#navigazione","text":"Home corso Community","title":"Navigazione"},{"location":"corsi/cli/moduli/01-fondamenti/","text":"Fondamenti della CLI \u00b6 Introduzione alla CLI \u00b6 La Command Line Interface (CLI) \u00e8 il metodo pi\u00f9 antico e potente per interagire con un sistema operativo. Prima delle interfacce grafiche (GUI), tutti i sistemi venivano controllati tramite comandi testuali. Ancora oggi: i server i sistemi embedded l\u2019infrastruttura cloud il mondo DevOps si basano quasi esclusivamente sulla CLI . Distinzione Tra CLI, Terminale e Shell \u00b6 Uno degli errori pi\u00f9 comuni \u00e8 confondere questi concetti: CLI: \u00e8 il linguaggio di interazione Terminale: \u00e8 solo un contenitore Shell: \u00e8 l\u2019interprete Sono cose diverse . Cos\u2019\u00e8 la CLI \u00b6 La CLI (Command Line Interface) \u00e8 un paradigma di interazione : - l\u2019utente scrive comandi testuali - il sistema risponde con output testuale Non \u00e8 un programma specifico. \u00c8 un modo di lavorare . Cos\u2019\u00e8 il terminale \u00b6 Il terminale \u00e8 un\u2019applicazione che: - fornisce una finestra - riceve input da tastiera - mostra output testuale Esempi: - GNOME Terminal - iTerm2 - Windows Terminal Il terminale non interpreta i comandi . La Shell \u00b6 La shell \u00e8 il programma che: - legge i comandi - li interpreta - li esegue \u00c8 il cuore operativo della CLI . Cosa fa una shell \u00b6 Una shell: interpreta il testo digitato espande variabili gestisce redirection e pipe avvia processi restituisce un exit code Quando scrivi un comando, non stai parlando direttamente al sistema , ma alla shell. Shell comuni \u00b6 Alcuni esempi: sh \u2013 shell storica bash \u2013 la pi\u00f9 diffusa zsh \u2013 moderna e avanzata fish \u2013 orientata all\u2019usabilit\u00e0 Nel corso useremo bash come riferimento concettuale. Prompt \u00b6 Il prompt \u00e8 la parte di testo che la shell mostra per indicare che \u00e8 pronta a ricevere un comando. In pratica \u00e8 un \u201csegnale di attesa\u201d e, spesso, contiene informazioni utili sul contesto in cui stai lavorando. Di solito pu\u00f2 includere: utente corrente nome della macchina (host) cartella in cui ti trovi (directory corrente) un simbolo finale che indica il tipo di utente Esempio: user@machine:~$ Come si legge: user = nome utente machine = computer/server su cui stai lavorando ~ = home directory dell\u2019utente (es. /home/user ) $ = utente normale ( # di solito indica l\u2019utente root /amministratore) Il prompt pu\u00f2 cambiare a seconda della shell e della configurazione, e pu\u00f2 mostrare anche altre informazioni (ad esempio il ramo Git o lo stato di un ambiente virtuale).","title":"Fondamenti della CLI"},{"location":"corsi/cli/moduli/01-fondamenti/#fondamenti-della-cli","text":"","title":"Fondamenti della CLI"},{"location":"corsi/cli/moduli/01-fondamenti/#introduzione-alla-cli","text":"La Command Line Interface (CLI) \u00e8 il metodo pi\u00f9 antico e potente per interagire con un sistema operativo. Prima delle interfacce grafiche (GUI), tutti i sistemi venivano controllati tramite comandi testuali. Ancora oggi: i server i sistemi embedded l\u2019infrastruttura cloud il mondo DevOps si basano quasi esclusivamente sulla CLI .","title":"Introduzione alla CLI"},{"location":"corsi/cli/moduli/01-fondamenti/#distinzione-tra-cli-terminale-e-shell","text":"Uno degli errori pi\u00f9 comuni \u00e8 confondere questi concetti: CLI: \u00e8 il linguaggio di interazione Terminale: \u00e8 solo un contenitore Shell: \u00e8 l\u2019interprete Sono cose diverse .","title":"Distinzione Tra CLI, Terminale e Shell"},{"location":"corsi/cli/moduli/01-fondamenti/#cose-la-cli","text":"La CLI (Command Line Interface) \u00e8 un paradigma di interazione : - l\u2019utente scrive comandi testuali - il sistema risponde con output testuale Non \u00e8 un programma specifico. \u00c8 un modo di lavorare .","title":"Cos\u2019\u00e8 la CLI"},{"location":"corsi/cli/moduli/01-fondamenti/#cose-il-terminale","text":"Il terminale \u00e8 un\u2019applicazione che: - fornisce una finestra - riceve input da tastiera - mostra output testuale Esempi: - GNOME Terminal - iTerm2 - Windows Terminal Il terminale non interpreta i comandi .","title":"Cos\u2019\u00e8 il terminale"},{"location":"corsi/cli/moduli/01-fondamenti/#la-shell","text":"La shell \u00e8 il programma che: - legge i comandi - li interpreta - li esegue \u00c8 il cuore operativo della CLI .","title":"La Shell"},{"location":"corsi/cli/moduli/01-fondamenti/#cosa-fa-una-shell","text":"Una shell: interpreta il testo digitato espande variabili gestisce redirection e pipe avvia processi restituisce un exit code Quando scrivi un comando, non stai parlando direttamente al sistema , ma alla shell.","title":"Cosa fa una shell"},{"location":"corsi/cli/moduli/01-fondamenti/#shell-comuni","text":"Alcuni esempi: sh \u2013 shell storica bash \u2013 la pi\u00f9 diffusa zsh \u2013 moderna e avanzata fish \u2013 orientata all\u2019usabilit\u00e0 Nel corso useremo bash come riferimento concettuale.","title":"Shell comuni"},{"location":"corsi/cli/moduli/01-fondamenti/#prompt","text":"Il prompt \u00e8 la parte di testo che la shell mostra per indicare che \u00e8 pronta a ricevere un comando. In pratica \u00e8 un \u201csegnale di attesa\u201d e, spesso, contiene informazioni utili sul contesto in cui stai lavorando. Di solito pu\u00f2 includere: utente corrente nome della macchina (host) cartella in cui ti trovi (directory corrente) un simbolo finale che indica il tipo di utente Esempio: user@machine:~$ Come si legge: user = nome utente machine = computer/server su cui stai lavorando ~ = home directory dell\u2019utente (es. /home/user ) $ = utente normale ( # di solito indica l\u2019utente root /amministratore) Il prompt pu\u00f2 cambiare a seconda della shell e della configurazione, e pu\u00f2 mostrare anche altre informazioni (ad esempio il ramo Git o lo stato di un ambiente virtuale).","title":"Prompt"},{"location":"corsi/cli/moduli/02-filesystem/","text":"Filesystem e Permessi \u00b6 In questo modulo costruisci le basi per orientarti nel filesystem da riga di comando: capire dove sei , cosa stai toccando e cosa succede quando esegui un comando. Quasi tutti i comandi della CLI lavorano su file e directory . Senza una mappa mentale della struttura e dei percorsi, i comandi si riducono a copia/incolla e gli errori diventano inevitabili. Obiettivo: leggere e usare correttamente path , gerarchia e contesto di lavoro prima di passare ai permessi. Filesystem \u00b6 Cos\u2019\u00e8 il filesystem \u00b6 Il filesystem \u00e8 il modello logico con cui il sistema operativo: organizza i dati li rende accessibili gestisce permessi e propriet\u00e0 In sistemi UNIX-like il filesystem \u00e8: gerarchico unificato radicato in / File e directory \u00b6 In UNIX: una directory \u00e8 un file speciale che contiene un elenco di nomi \u2192 inode (cio\u00e8 \u201cetichette\u201d che puntano ad altri file o directory) un file \u00e8, in sostanza, una sequenza di byte (testo, immagini, binari, ecc.) le estensioni ( .txt , .png , .pdf ) sono solo una convenzione : aiutano le persone e alcuni programmi, ma non sono obbligatorie n\u00e9 decisive Quindi il \u201ctipo\u201d di un file non dipende dal nome, ma da: Contenuto (formato reale) Molti file hanno una firma interna (\u201cmagic number\u201d). Per verificarlo si usa: file documento Metadati del filesystem (permessi, proprietario, timestamp, ecc.) Permessi di esecuzione Conclusione: in UNIX il nome \u00e8 solo un nome ; ci\u00f2 che conta \u00e8 cosa contiene il file e cosa ti \u00e8 permesso farci . Gerarchia standard \u00b6 Tutto parte dalla directory radice e si ramifica in ulteriori directories: / \u251c\u2500\u2500 bin # comandi essenziali \u251c\u2500\u2500 etc # file di configurazione \u251c\u2500\u2500 home # directory degli utenti \u251c\u2500\u2500 var # dati variabili (log, cache) \u2514\u2500\u2500 tmp # file temporanei Non \u00e8 una convenzione estetica: ogni directory ha una funzione precisa . Path (percorsi) \u00b6 Un path identifica un file o una directory. Path assoluto : parte da / /home/user/file.txt Path relativo : parte dalla directory corrente ./file.txt Un modo utile per pensarci: l\u2019assoluto \u00e8 \u201ccoordinate globali\u201d il relativo \u00e8 \u201ccoordinate locali\u201d (dipendono da dove ti trovi) I riferimenti speciali: . , .. , ~ \u00b6 Nella maggior parte delle shell UNIX, questi simboli sono fondamentali: . = directory corrente .. = directory padre ~ = home dell\u2019utente Working directory (il \u201ccontesto\u201d) \u00b6 La working directory (directory di lavoro) \u00e8 il posto in cui il sistema considera che tu sia \u201cin questo momento\u201d. \u00c8 fondamentale perch\u00e9 molti comandi: leggono file \u201crelativi\u201d al punto in cui sei creano nuovi file \u201cqui\u201d se non specifichi un path possono fare danni se eseguiti nella cartella sbagliata Comandi base: pwd # stampa dove sei ls # mostra cosa c\u2019\u00e8 nella cartella cd ... # cambia cartella Regola pratica: prima di un\u2019operazione delicata (es. cancellazioni), esegui sempre pwd e ls . Muoversi nel filesystem \u00b6 Il prompt della shell (dove scrivi i comandi) \u00b6 Quando apri il Terminale vedi una riga simile a: utente@macbook:~/progetti $ Quella parte finale ( $ oppure # ) \u00e8 il prompt : indica che la shell \u00e8 pronta a ricevere un comando. ~ di solito significa \u201csei nella home\u201d se vedi # spesso sei root (massimi permessi) \u2192 pi\u00f9 rischioso La cosa pi\u00f9 importante da capire \u00e8: ogni comando che scrivi viene eseguito \u201cda\u201d una directory corrente (working directory). Per orientarti usi soprattutto pwd , ls , cd . Navigazione essenziale: pwd , ls , cd \u00b6 pwd \u2014 \u201cdove sono?\u201d \u00b6 pwd ( print working directory ) stampa il percorso assoluto della directory in cui ti trovi. pwd # /Users/pianic2/itsfantastici \u00c8 il comando da usare quando non sei sicuro del contesto (prima di operazioni delicate). ls \u2014 \u201ccosa c\u2019\u00e8 qui?\u201d \u00b6 ls ( abbreviazione per : list ) elenca file e directory nella cartella corrente (o in un path che gli passi). ls ls docs/ Opzioni comuni: ls -l # lista \u201clunga\u201d: permessi, proprietario, dimensione, data ls -a # include i file nascosti (quelli che iniziano con .) ls -la # combinazione molto usata ls -la \u00e8 utile perch\u00e9 mostra: file \u201cnascosti\u201d (iniziano con . ) permessi e proprietario (li vedremo nella parte sui permessi) cd \u2014 \u201cvai in un\u2019altra cartella\u201d \u00b6 cd ( change directory ) cambia la directory corrente. cd / # vai alla root cd ~ # vai alla home cd .. # vai alla cartella padre cd - # torna alla cartella precedente cd docs/ # path relativo cd /var/log # path assoluto Note pratiche: cd senza argomenti ti porta in ~ (home) i path relativi dipendono da dove sei (controlla con pwd ) usa TAB per completare nomi di file/cartelle ed evitare errori Globbing (selezionare file con pattern) \u00b6 La shell espande automaticamente alcuni pattern: * = qualsiasi sequenza di caratteri ? = un singolo carattere Esempi: ls *.md ls lezione-0?.md Se un nome contiene spazi, usa le virgolette: ls \"File con spazi.txt\" Creare, spostare ed eliminare file \u00b6 In questa sezione vedi le operazioni fondamentali su file e directory: creare : mkdir , touch copiare : cp spostare / rinominare : mv eliminare (con attenzione): rm , rmdir Operazioni essenziali: mkdir , touch , cp , mv , rm \u00b6 mkdir \u2014 \u201ccrea una directory\u201d \u00b6 mkdir ( make directory ) crea una nuova cartella. mkdir appunti Se vuoi creare pi\u00f9 livelli in un colpo solo (e non avere errori se qualche cartella esiste gi\u00e0), usa -p : mkdir -p corsi/cli/moduli touch \u2014 \u201ccrea un file vuoto (o aggiorna il timestamp)\u201d \u00b6 touch crea un file vuoto se non esiste; se esiste, aggiorna data/ora di modifica. touch note.md cp \u2014 \u201ccopia\u201d \u00b6 cp ( copy ) copia file (e, con opzioni, directory). Copiare un file (crea copia.txt oppure lo sovrascrive se esiste): cp sorgente.txt copia.txt Copiare una directory richiede -r ( recursive ): cp -r cartella cartella-backup Regola pratica: prima di una modifica \u201crischiosa\u201d, fare una copia \u00e8 spesso il modo pi\u00f9 rapido per recuperare da un errore. mv \u2014 \u201csposta o rinomina\u201d \u00b6 In UNIX, spostare e rinominare sono la stessa operazione: mv ( move ). Rinominare un file: mv vecchio.txt nuovo.txt Spostare un file in una directory (eventualmente cambiandogli nome): mv note.md appunti/note.md Se la destinazione esiste gi\u00e0, mv pu\u00f2 sovrascrivere . Per ridurre il rischio, usa la modalit\u00e0 interattiva: mv -i sorgente.txt destinazione.txt rm / rmdir \u2014 \u201celimina (attenzione)\u201d \u00b6 Eliminare \u00e8 l\u2019operazione pi\u00f9 delicata: di default non c\u2019\u00e8 cestino . Eliminare un file: rm file.txt Eliminare una directory vuota : rmdir cartella-vuota Eliminare una directory con contenuto (attenzione: rimuove tutto) richiede -r : rm -r cartella Modalit\u00e0 \u201cinterattiva\u201d (chiede conferma): rm -i file.txt rm -ri cartella Regola di sicurezza: prima fai una ls del path che vuoi colpire, poi esegui rm . Esempio: ls cartella rm -r cartella Perch\u00e9 il contesto \u00e8 fondamentale (la regola che evita errori) \u00b6 Due comandi identici possono avere effetti completamente diversi a seconda di: dove sei ( pwd ) su quali file stai puntando (path relativo vs assoluto) quali pattern stai espandendo ( * , ? ) Esempio: questi due comandi NON sono equivalenti. rm -r build rm -r ./build Il secondo rende esplicito che ti riferisci alla cartella build nella directory corrente.","title":"Filesystem e permessi"},{"location":"corsi/cli/moduli/02-filesystem/#filesystem-e-permessi","text":"In questo modulo costruisci le basi per orientarti nel filesystem da riga di comando: capire dove sei , cosa stai toccando e cosa succede quando esegui un comando. Quasi tutti i comandi della CLI lavorano su file e directory . Senza una mappa mentale della struttura e dei percorsi, i comandi si riducono a copia/incolla e gli errori diventano inevitabili. Obiettivo: leggere e usare correttamente path , gerarchia e contesto di lavoro prima di passare ai permessi.","title":"Filesystem e Permessi"},{"location":"corsi/cli/moduli/02-filesystem/#filesystem","text":"","title":"Filesystem"},{"location":"corsi/cli/moduli/02-filesystem/#cose-il-filesystem","text":"Il filesystem \u00e8 il modello logico con cui il sistema operativo: organizza i dati li rende accessibili gestisce permessi e propriet\u00e0 In sistemi UNIX-like il filesystem \u00e8: gerarchico unificato radicato in /","title":"Cos\u2019\u00e8 il filesystem"},{"location":"corsi/cli/moduli/02-filesystem/#file-e-directory","text":"In UNIX: una directory \u00e8 un file speciale che contiene un elenco di nomi \u2192 inode (cio\u00e8 \u201cetichette\u201d che puntano ad altri file o directory) un file \u00e8, in sostanza, una sequenza di byte (testo, immagini, binari, ecc.) le estensioni ( .txt , .png , .pdf ) sono solo una convenzione : aiutano le persone e alcuni programmi, ma non sono obbligatorie n\u00e9 decisive Quindi il \u201ctipo\u201d di un file non dipende dal nome, ma da: Contenuto (formato reale) Molti file hanno una firma interna (\u201cmagic number\u201d). Per verificarlo si usa: file documento Metadati del filesystem (permessi, proprietario, timestamp, ecc.) Permessi di esecuzione Conclusione: in UNIX il nome \u00e8 solo un nome ; ci\u00f2 che conta \u00e8 cosa contiene il file e cosa ti \u00e8 permesso farci .","title":"File e directory"},{"location":"corsi/cli/moduli/02-filesystem/#gerarchia-standard","text":"Tutto parte dalla directory radice e si ramifica in ulteriori directories: / \u251c\u2500\u2500 bin # comandi essenziali \u251c\u2500\u2500 etc # file di configurazione \u251c\u2500\u2500 home # directory degli utenti \u251c\u2500\u2500 var # dati variabili (log, cache) \u2514\u2500\u2500 tmp # file temporanei Non \u00e8 una convenzione estetica: ogni directory ha una funzione precisa .","title":"Gerarchia standard"},{"location":"corsi/cli/moduli/02-filesystem/#path-percorsi","text":"Un path identifica un file o una directory. Path assoluto : parte da / /home/user/file.txt Path relativo : parte dalla directory corrente ./file.txt Un modo utile per pensarci: l\u2019assoluto \u00e8 \u201ccoordinate globali\u201d il relativo \u00e8 \u201ccoordinate locali\u201d (dipendono da dove ti trovi)","title":"Path (percorsi)"},{"location":"corsi/cli/moduli/02-filesystem/#i-riferimenti-speciali","text":"Nella maggior parte delle shell UNIX, questi simboli sono fondamentali: . = directory corrente .. = directory padre ~ = home dell\u2019utente","title":"I riferimenti speciali: ., .., ~"},{"location":"corsi/cli/moduli/02-filesystem/#working-directory-il-contesto","text":"La working directory (directory di lavoro) \u00e8 il posto in cui il sistema considera che tu sia \u201cin questo momento\u201d. \u00c8 fondamentale perch\u00e9 molti comandi: leggono file \u201crelativi\u201d al punto in cui sei creano nuovi file \u201cqui\u201d se non specifichi un path possono fare danni se eseguiti nella cartella sbagliata Comandi base: pwd # stampa dove sei ls # mostra cosa c\u2019\u00e8 nella cartella cd ... # cambia cartella Regola pratica: prima di un\u2019operazione delicata (es. cancellazioni), esegui sempre pwd e ls .","title":"Working directory (il \u201ccontesto\u201d)"},{"location":"corsi/cli/moduli/02-filesystem/#muoversi-nel-filesystem","text":"","title":"Muoversi nel filesystem"},{"location":"corsi/cli/moduli/02-filesystem/#il-prompt-della-shell-dove-scrivi-i-comandi","text":"Quando apri il Terminale vedi una riga simile a: utente@macbook:~/progetti $ Quella parte finale ( $ oppure # ) \u00e8 il prompt : indica che la shell \u00e8 pronta a ricevere un comando. ~ di solito significa \u201csei nella home\u201d se vedi # spesso sei root (massimi permessi) \u2192 pi\u00f9 rischioso La cosa pi\u00f9 importante da capire \u00e8: ogni comando che scrivi viene eseguito \u201cda\u201d una directory corrente (working directory). Per orientarti usi soprattutto pwd , ls , cd .","title":"Il prompt della shell (dove scrivi i comandi)"},{"location":"corsi/cli/moduli/02-filesystem/#navigazione-essenziale-pwd-ls-cd","text":"","title":"Navigazione essenziale: pwd, ls, cd"},{"location":"corsi/cli/moduli/02-filesystem/#pwd-dove-sono","text":"pwd ( print working directory ) stampa il percorso assoluto della directory in cui ti trovi. pwd # /Users/pianic2/itsfantastici \u00c8 il comando da usare quando non sei sicuro del contesto (prima di operazioni delicate).","title":"pwd \u2014 \u201cdove sono?\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#ls-cosa-ce-qui","text":"ls ( abbreviazione per : list ) elenca file e directory nella cartella corrente (o in un path che gli passi). ls ls docs/ Opzioni comuni: ls -l # lista \u201clunga\u201d: permessi, proprietario, dimensione, data ls -a # include i file nascosti (quelli che iniziano con .) ls -la # combinazione molto usata ls -la \u00e8 utile perch\u00e9 mostra: file \u201cnascosti\u201d (iniziano con . ) permessi e proprietario (li vedremo nella parte sui permessi)","title":"ls \u2014 \u201ccosa c\u2019\u00e8 qui?\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#cd-vai-in-unaltra-cartella","text":"cd ( change directory ) cambia la directory corrente. cd / # vai alla root cd ~ # vai alla home cd .. # vai alla cartella padre cd - # torna alla cartella precedente cd docs/ # path relativo cd /var/log # path assoluto Note pratiche: cd senza argomenti ti porta in ~ (home) i path relativi dipendono da dove sei (controlla con pwd ) usa TAB per completare nomi di file/cartelle ed evitare errori","title":"cd \u2014 \u201cvai in un\u2019altra cartella\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#globbing-selezionare-file-con-pattern","text":"La shell espande automaticamente alcuni pattern: * = qualsiasi sequenza di caratteri ? = un singolo carattere Esempi: ls *.md ls lezione-0?.md Se un nome contiene spazi, usa le virgolette: ls \"File con spazi.txt\"","title":"Globbing (selezionare file con pattern)"},{"location":"corsi/cli/moduli/02-filesystem/#creare-spostare-ed-eliminare-file","text":"In questa sezione vedi le operazioni fondamentali su file e directory: creare : mkdir , touch copiare : cp spostare / rinominare : mv eliminare (con attenzione): rm , rmdir","title":"Creare, spostare ed eliminare file"},{"location":"corsi/cli/moduli/02-filesystem/#operazioni-essenziali-mkdir-touch-cp-mv-rm","text":"","title":"Operazioni essenziali: mkdir, touch, cp, mv, rm"},{"location":"corsi/cli/moduli/02-filesystem/#mkdir-crea-una-directory","text":"mkdir ( make directory ) crea una nuova cartella. mkdir appunti Se vuoi creare pi\u00f9 livelli in un colpo solo (e non avere errori se qualche cartella esiste gi\u00e0), usa -p : mkdir -p corsi/cli/moduli","title":"mkdir \u2014 \u201ccrea una directory\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#touch-crea-un-file-vuoto-o-aggiorna-il-timestamp","text":"touch crea un file vuoto se non esiste; se esiste, aggiorna data/ora di modifica. touch note.md","title":"touch \u2014 \u201ccrea un file vuoto (o aggiorna il timestamp)\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#cp-copia","text":"cp ( copy ) copia file (e, con opzioni, directory). Copiare un file (crea copia.txt oppure lo sovrascrive se esiste): cp sorgente.txt copia.txt Copiare una directory richiede -r ( recursive ): cp -r cartella cartella-backup Regola pratica: prima di una modifica \u201crischiosa\u201d, fare una copia \u00e8 spesso il modo pi\u00f9 rapido per recuperare da un errore.","title":"cp \u2014 \u201ccopia\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#mv-sposta-o-rinomina","text":"In UNIX, spostare e rinominare sono la stessa operazione: mv ( move ). Rinominare un file: mv vecchio.txt nuovo.txt Spostare un file in una directory (eventualmente cambiandogli nome): mv note.md appunti/note.md Se la destinazione esiste gi\u00e0, mv pu\u00f2 sovrascrivere . Per ridurre il rischio, usa la modalit\u00e0 interattiva: mv -i sorgente.txt destinazione.txt","title":"mv \u2014 \u201csposta o rinomina\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#rm-rmdir-elimina-attenzione","text":"Eliminare \u00e8 l\u2019operazione pi\u00f9 delicata: di default non c\u2019\u00e8 cestino . Eliminare un file: rm file.txt Eliminare una directory vuota : rmdir cartella-vuota Eliminare una directory con contenuto (attenzione: rimuove tutto) richiede -r : rm -r cartella Modalit\u00e0 \u201cinterattiva\u201d (chiede conferma): rm -i file.txt rm -ri cartella Regola di sicurezza: prima fai una ls del path che vuoi colpire, poi esegui rm . Esempio: ls cartella rm -r cartella","title":"rm / rmdir \u2014 \u201celimina (attenzione)\u201d"},{"location":"corsi/cli/moduli/02-filesystem/#perche-il-contesto-e-fondamentale-la-regola-che-evita-errori","text":"Due comandi identici possono avere effetti completamente diversi a seconda di: dove sei ( pwd ) su quali file stai puntando (path relativo vs assoluto) quali pattern stai espandendo ( * , ? ) Esempio: questi due comandi NON sono equivalenti. rm -r build rm -r ./build Il secondo rende esplicito che ti riferisci alla cartella build nella directory corrente.","title":"Perch\u00e9 il contesto \u00e8 fondamentale (la regola che evita errori)"},{"location":"corsi/corso-database-sql/","text":"Corso Database SQL \u00b6 Questo corso introduce i concetti fondamentali dei database relazionali e del linguaggio SQL, partendo dalle basi teoriche fino ad arrivare a progettazione, query avanzate e deploy. Il corso \u00e8 costruito attorno a un progetto unico , che evolve modulo dopo modulo, mantenendo sempre un filo logico tra teoria e pratica. Non \u00e8 un corso di sola sintassi: l\u2019obiettivo \u00e8 imparare a progettare, interrogare e mantenere dati correttamente , ragionando come chi costruisce sistemi reali. Idea centrale del corso \u00b6 Tutto il corso ruota attorno a un unico progetto , che evolve nel tempo. Non studiamo SQL \u201cper argomenti isolati\u201d, ma perch\u00e9: - emerge un problema reale - serve uno strumento specifico - lo applichiamo subito al progetto Questo garantisce: - continuit\u00e0 logica - coerenza tra le lezioni - competenze realmente spendibili Obiettivi del corso \u00b6 comprendere come e perch\u00e9 usare un database relazionale progettare correttamente uno schema dati scrivere query SQL corrette, leggibili e scalabili comprendere le differenze tra motori SQL (SQLite \u2192 MySQL) lavorare in modo collaborativo su documentazione e soluzioni Struttura del corso \u00b6 Progetto : definizione del problema e del modello dati Moduli : concetti teorici + applicazione pratica Esercizi : approfondimento guidato, non verifica Soluzioni community : le migliori spiegazioni vengono integrate Partecipazione della community \u00b6 Gli studenti possono: - proporre esercizi - migliorare spiegazioni - suggerire soluzioni alternative Ogni modifica passa tramite Pull Request e viene approvata secondo la regola 50% + 1 . Tecnologie utilizzate \u00b6 SQL standard (approccio DB-agnostic) SQLite per sviluppo iniziale MySQL per scenari di produzione Git + GitHub per collaborazione MkDocs per la documentazione Navigazione rapida \u00b6 Progetto Moduli Linee guida community Changelog","title":"Home corso"},{"location":"corsi/corso-database-sql/#corso-database-sql","text":"Questo corso introduce i concetti fondamentali dei database relazionali e del linguaggio SQL, partendo dalle basi teoriche fino ad arrivare a progettazione, query avanzate e deploy. Il corso \u00e8 costruito attorno a un progetto unico , che evolve modulo dopo modulo, mantenendo sempre un filo logico tra teoria e pratica. Non \u00e8 un corso di sola sintassi: l\u2019obiettivo \u00e8 imparare a progettare, interrogare e mantenere dati correttamente , ragionando come chi costruisce sistemi reali.","title":"Corso Database SQL"},{"location":"corsi/corso-database-sql/#idea-centrale-del-corso","text":"Tutto il corso ruota attorno a un unico progetto , che evolve nel tempo. Non studiamo SQL \u201cper argomenti isolati\u201d, ma perch\u00e9: - emerge un problema reale - serve uno strumento specifico - lo applichiamo subito al progetto Questo garantisce: - continuit\u00e0 logica - coerenza tra le lezioni - competenze realmente spendibili","title":"Idea centrale del corso"},{"location":"corsi/corso-database-sql/#obiettivi-del-corso","text":"comprendere come e perch\u00e9 usare un database relazionale progettare correttamente uno schema dati scrivere query SQL corrette, leggibili e scalabili comprendere le differenze tra motori SQL (SQLite \u2192 MySQL) lavorare in modo collaborativo su documentazione e soluzioni","title":"Obiettivi del corso"},{"location":"corsi/corso-database-sql/#struttura-del-corso","text":"Progetto : definizione del problema e del modello dati Moduli : concetti teorici + applicazione pratica Esercizi : approfondimento guidato, non verifica Soluzioni community : le migliori spiegazioni vengono integrate","title":"Struttura del corso"},{"location":"corsi/corso-database-sql/#partecipazione-della-community","text":"Gli studenti possono: - proporre esercizi - migliorare spiegazioni - suggerire soluzioni alternative Ogni modifica passa tramite Pull Request e viene approvata secondo la regola 50% + 1 .","title":"Partecipazione della community"},{"location":"corsi/corso-database-sql/#tecnologie-utilizzate","text":"SQL standard (approccio DB-agnostic) SQLite per sviluppo iniziale MySQL per scenari di produzione Git + GitHub per collaborazione MkDocs per la documentazione","title":"Tecnologie utilizzate"},{"location":"corsi/corso-database-sql/#navigazione-rapida","text":"Progetto Moduli Linee guida community Changelog","title":"Navigazione rapida"},{"location":"corsi/corso-database-sql/changelog/","text":"Changelog \u00b6 Questo documento registra le modifiche rilevanti alla documentazione del corso Database SQL . Il changelog: - riflette l\u2019evoluzione reale del corso - \u00e8 supportato da Git - documenta solo cambiamenti concettuali o strutturali Modifiche minori (refusi, formattazione) possono non essere elencate. [Unreleased] \u00b6 Added \u00b6 modello di documentazione collaborativa standard globale per corsi ITS Fantastici struttura modulare con progetto unico governance community basata su Pull Request Changed \u00b6 approccio didattico orientato al problema, non alla sintassi [v0.1.0] \u2014 Fondazioni iniziali \u00b6 Added \u00b6 piattaforma documentale ITS Fantastici struttura scalabile per pi\u00f9 corsi corso Database SQL progetto unico del corso problema iniziale requisiti modello dati iniziale Modulo 01 \u2014 Fondamenti dei database Lezione 01 \u2014 Introduzione ai database Lezione 02 \u2014 Primo contatto con SQL template standard di lezione linee guida per contributi della community Lezione 03 - Relazioni e JOIN Convenzioni \u00b6 Added : nuove funzionalit\u00e0, sezioni o concetti Changed : modifiche a contenuti esistenti Deprecated : concetti o strutture non pi\u00f9 consigliati Removed : contenuti rimossi Fixed : correzioni concettuali importanti Ogni modifica che influisce sul significato didattico del corso deve essere tracciata qui. Note operative \u00b6 ogni release corrisponde a uno stato coerente del corso il changelog non sostituisce la cronologia Git le decisioni didattiche importanti devono essere esplicite","title":"Changelog"},{"location":"corsi/corso-database-sql/changelog/#changelog","text":"Questo documento registra le modifiche rilevanti alla documentazione del corso Database SQL . Il changelog: - riflette l\u2019evoluzione reale del corso - \u00e8 supportato da Git - documenta solo cambiamenti concettuali o strutturali Modifiche minori (refusi, formattazione) possono non essere elencate.","title":"Changelog"},{"location":"corsi/corso-database-sql/changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"corsi/corso-database-sql/changelog/#added","text":"modello di documentazione collaborativa standard globale per corsi ITS Fantastici struttura modulare con progetto unico governance community basata su Pull Request","title":"Added"},{"location":"corsi/corso-database-sql/changelog/#changed","text":"approccio didattico orientato al problema, non alla sintassi","title":"Changed"},{"location":"corsi/corso-database-sql/changelog/#v010-fondazioni-iniziali","text":"","title":"[v0.1.0] \u2014 Fondazioni iniziali"},{"location":"corsi/corso-database-sql/changelog/#added_1","text":"piattaforma documentale ITS Fantastici struttura scalabile per pi\u00f9 corsi corso Database SQL progetto unico del corso problema iniziale requisiti modello dati iniziale Modulo 01 \u2014 Fondamenti dei database Lezione 01 \u2014 Introduzione ai database Lezione 02 \u2014 Primo contatto con SQL template standard di lezione linee guida per contributi della community Lezione 03 - Relazioni e JOIN","title":"Added"},{"location":"corsi/corso-database-sql/changelog/#convenzioni","text":"Added : nuove funzionalit\u00e0, sezioni o concetti Changed : modifiche a contenuti esistenti Deprecated : concetti o strutture non pi\u00f9 consigliati Removed : contenuti rimossi Fixed : correzioni concettuali importanti Ogni modifica che influisce sul significato didattico del corso deve essere tracciata qui.","title":"Convenzioni"},{"location":"corsi/corso-database-sql/changelog/#note-operative","text":"ogni release corrisponde a uno stato coerente del corso il changelog non sostituisce la cronologia Git le decisioni didattiche importanti devono essere esplicite","title":"Note operative"},{"location":"corsi/corso-database-sql/moduli/","text":"Moduli del corso \u00b6 Il corso Database SQL \u00e8 strutturato in moduli progressivi . Ogni modulo: introduce nuovi concetti risolve problemi che emergono dal progetto estende ci\u00f2 che \u00e8 stato costruito nei moduli precedenti Non esistono moduli indipendenti: il corso \u00e8 cumulativo . Come usare i moduli \u00b6 segui i moduli in ordine non saltare le lezioni iniziali usa il progetto come riferimento costante confronta teoria, esempi ed esercizi con il modello dati Elenco dei moduli \u00b6 \ud83d\udcd8 Modulo 01 \u2014 Fondamenti dei database \u00b6 Costruisce il modello mentale corretto . Contenuti chiave: cos\u2019\u00e8 un database modello relazionale entit\u00e0, relazioni e vincoli primo schema reale primo contatto con SQL \ud83d\udc49 Vai al modulo \ud83d\udcd7 Modulo 02 \u2014 Query SQL \u00b6 Introduce la lettura e interrogazione avanzata dei dati . Contenuti chiave: JOIN aggregazioni GROUP BY e HAVING VIEW gestione dei conflitti (UPSERT) \ud83d\udc49 Vai al modulo \ud83d\udcd9 Modulo 03 \u2014 Schema e performance \u00b6 Si concentra su qualit\u00e0 e prestazioni . Contenuti chiave: indici EXPLAIN vincoli utili soft delete migrazioni di schema \ud83d\udc49 Vai al modulo \ud83d\udcd5 Modulo 04 \u2014 Migrazione e produzione \u00b6 Affronta il passaggio da progetto didattico a sistema reale . Contenuti chiave: transazioni concorrenza differenze SQLite / MySQL utenti e permessi backup e manutenzione \ud83d\udc49 Vai al modulo Output complessivo del corso \u00b6 Al termine di tutti i moduli, lo studente avr\u00e0: un modello dati solido query SQL leggibili ed efficienti consapevolezza dei trade-off progettuali capacit\u00e0 di passare da prototipo a produzione esperienza di lavoro collaborativo su documentazione tecnica Navigazione \u00b6 Home corso Progetto Community Changelog","title":"Indice moduli"},{"location":"corsi/corso-database-sql/moduli/#moduli-del-corso","text":"Il corso Database SQL \u00e8 strutturato in moduli progressivi . Ogni modulo: introduce nuovi concetti risolve problemi che emergono dal progetto estende ci\u00f2 che \u00e8 stato costruito nei moduli precedenti Non esistono moduli indipendenti: il corso \u00e8 cumulativo .","title":"Moduli del corso"},{"location":"corsi/corso-database-sql/moduli/#come-usare-i-moduli","text":"segui i moduli in ordine non saltare le lezioni iniziali usa il progetto come riferimento costante confronta teoria, esempi ed esercizi con il modello dati","title":"Come usare i moduli"},{"location":"corsi/corso-database-sql/moduli/#elenco-dei-moduli","text":"","title":"Elenco dei moduli"},{"location":"corsi/corso-database-sql/moduli/#modulo-01-fondamenti-dei-database","text":"Costruisce il modello mentale corretto . Contenuti chiave: cos\u2019\u00e8 un database modello relazionale entit\u00e0, relazioni e vincoli primo schema reale primo contatto con SQL \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd8 Modulo 01 \u2014 Fondamenti dei database"},{"location":"corsi/corso-database-sql/moduli/#modulo-02-query-sql","text":"Introduce la lettura e interrogazione avanzata dei dati . Contenuti chiave: JOIN aggregazioni GROUP BY e HAVING VIEW gestione dei conflitti (UPSERT) \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd7 Modulo 02 \u2014 Query SQL"},{"location":"corsi/corso-database-sql/moduli/#modulo-03-schema-e-performance","text":"Si concentra su qualit\u00e0 e prestazioni . Contenuti chiave: indici EXPLAIN vincoli utili soft delete migrazioni di schema \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd9 Modulo 03 \u2014 Schema e performance"},{"location":"corsi/corso-database-sql/moduli/#modulo-04-migrazione-e-produzione","text":"Affronta il passaggio da progetto didattico a sistema reale . Contenuti chiave: transazioni concorrenza differenze SQLite / MySQL utenti e permessi backup e manutenzione \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd5 Modulo 04 \u2014 Migrazione e produzione"},{"location":"corsi/corso-database-sql/moduli/#output-complessivo-del-corso","text":"Al termine di tutti i moduli, lo studente avr\u00e0: un modello dati solido query SQL leggibili ed efficienti consapevolezza dei trade-off progettuali capacit\u00e0 di passare da prototipo a produzione esperienza di lavoro collaborativo su documentazione tecnica","title":"Output complessivo del corso"},{"location":"corsi/corso-database-sql/moduli/#navigazione","text":"Home corso Progetto Community Changelog","title":"Navigazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/","text":"Modulo 01 \u2014 Fondamenti dei database \u00b6 Questo modulo introduce i concetti fondamentali necessari per comprendere e progettare un database relazionale. Non si parte dalla sintassi, ma dalla struttura mentale corretta : capire cosa stiamo costruendo prima di imparare come interrogarlo. Tutto ci\u00f2 che verr\u00e0 fatto nei moduli successivi dipende direttamente da questo modulo. Perch\u00e9 questo modulo \u00e8 fondamentale \u00b6 Senza una comprensione chiara di: entit\u00e0 relazioni vincoli integrit\u00e0 dei dati qualsiasi utilizzo di SQL diventa: fragile difficile da mantenere impossibile da scalare Questo modulo serve a prevenire errori strutturali , non a imparare comandi a memoria. Obiettivi di apprendimento \u00b6 Al termine di questo modulo lo studente sar\u00e0 in grado di spiegare cos\u2019\u00e8 un database e perch\u00e9 \u00e8 necessario, distinguendo tra database relazionali e non relazionali. Sapr\u00e0 modellare correttamente entit\u00e0 e relazioni e comprender\u00e0 il ruolo di primary key , foreign key e dei principali vincoli per garantire l\u2019integrit\u00e0 dei dati. Inoltre, sar\u00e0 in grado di leggere e valutare un modello dati, motivando le scelte progettuali, e di inquadrare SQL come uno strumento operativo al servizio del modello, non come un fine in s\u00e9. Collegamento con il progetto \u00b6 In questo modulo: viene introdotto il problema iniziale vengono definiti requisiti e vincoli viene costruito il modello dati iniziale si realizza la prima implementazione reale dello schema Il progetto nasce qui e non verr\u00e0 mai resettato . Contenuti del modulo \u00b6 Lezione 01 \u2014 Introduzione ai database \u00b6 Problema \u2014 Comprendere cos\u2019\u00e8 un database e perch\u00e9 serve rispetto alla gestione tramite file. Teoria \u2014 Cos\u2019\u00e8 un database; perch\u00e9 i file non bastano; modello relazionale; entit\u00e0, relazioni e vincoli; definizione del modello concettuale del progetto. Esempi pratici \u2014 inizializzare un nuovo database da zero; creare le prime tabelle. \ud83d\udc49 Vai alla lezione Lezione 02 \u2014 Primo contatto con SQL \u00b6 Problema \u2014 Passare dal modello concettuale a uno schema reale interrogabile. Teoria \u2014 Cos\u2019\u00e8 SQL e perch\u00e9 \u00e8 dichiarativo; schema del database; tipi di dato (DB-agnostic); operazioni CRUD. Esempi pratici \u2014 Operazioni CRUD. \ud83d\udc49 Vai alla lezione Lezione 03 \u2014 Relazioni e JOIN \u00b6 Problema \u2014 Leggere dati distribuiti su pi\u00f9 tabelle (post + autore, commenti + post, ecc.). Teoria \u2014 JOIN tramite chiavi (FK \u2192 PK); differenza tra INNER JOIN e LEFT JOIN ; alias e naming. Esempi pratici \u2014 Post con autore ( JOIN users ); commenti con autore e post; post anche senza commenti ( LEFT JOIN + COUNT ). Esercizi \u2014 Progettare un database con studenti , corsi e iscrizioni (relazione molti-a-molti); creare tabelle, inserire dati, verificare con SELECT , e fare una query con JOIN per mostrare studente + corso. \ud83d\udc49 Vai alla lezione Output del modulo \u00b6 Alla fine del modulo esistono: un problema ben definito un insieme di requisiti espliciti un modello dati coerente una prima implementazione reale un linguaggio tecnico condiviso tra tutti i partecipanti Questi elementi costituiscono la base tecnica comune dell\u2019intero corso. Errori comuni da evitare \u00b6 saltare la modellazione per \u201candare subito su SQL\u201d confondere tabelle con entit\u00e0 concettuali ignorare i vincoli pensando di gestirli \u201ca codice\u201d duplicare dati per comodit\u00e0 pensare che SQL sia solo sintassi Questo modulo serve a costruire fondamenta solide . Navigazione \u00b6 Progetto Lezione 01 Lezione 02 Lezione 03 Glossario Moduli","title":"Indice"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#modulo-01-fondamenti-dei-database","text":"Questo modulo introduce i concetti fondamentali necessari per comprendere e progettare un database relazionale. Non si parte dalla sintassi, ma dalla struttura mentale corretta : capire cosa stiamo costruendo prima di imparare come interrogarlo. Tutto ci\u00f2 che verr\u00e0 fatto nei moduli successivi dipende direttamente da questo modulo.","title":"Modulo 01 \u2014 Fondamenti dei database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#perche-questo-modulo-e-fondamentale","text":"Senza una comprensione chiara di: entit\u00e0 relazioni vincoli integrit\u00e0 dei dati qualsiasi utilizzo di SQL diventa: fragile difficile da mantenere impossibile da scalare Questo modulo serve a prevenire errori strutturali , non a imparare comandi a memoria.","title":"Perch\u00e9 questo modulo \u00e8 fondamentale"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#obiettivi-di-apprendimento","text":"Al termine di questo modulo lo studente sar\u00e0 in grado di spiegare cos\u2019\u00e8 un database e perch\u00e9 \u00e8 necessario, distinguendo tra database relazionali e non relazionali. Sapr\u00e0 modellare correttamente entit\u00e0 e relazioni e comprender\u00e0 il ruolo di primary key , foreign key e dei principali vincoli per garantire l\u2019integrit\u00e0 dei dati. Inoltre, sar\u00e0 in grado di leggere e valutare un modello dati, motivando le scelte progettuali, e di inquadrare SQL come uno strumento operativo al servizio del modello, non come un fine in s\u00e9.","title":"Obiettivi di apprendimento"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#collegamento-con-il-progetto","text":"In questo modulo: viene introdotto il problema iniziale vengono definiti requisiti e vincoli viene costruito il modello dati iniziale si realizza la prima implementazione reale dello schema Il progetto nasce qui e non verr\u00e0 mai resettato .","title":"Collegamento con il progetto"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#contenuti-del-modulo","text":"","title":"Contenuti del modulo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#lezione-01-introduzione-ai-database","text":"Problema \u2014 Comprendere cos\u2019\u00e8 un database e perch\u00e9 serve rispetto alla gestione tramite file. Teoria \u2014 Cos\u2019\u00e8 un database; perch\u00e9 i file non bastano; modello relazionale; entit\u00e0, relazioni e vincoli; definizione del modello concettuale del progetto. Esempi pratici \u2014 inizializzare un nuovo database da zero; creare le prime tabelle. \ud83d\udc49 Vai alla lezione","title":"Lezione 01 \u2014 Introduzione ai database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#lezione-02-primo-contatto-con-sql","text":"Problema \u2014 Passare dal modello concettuale a uno schema reale interrogabile. Teoria \u2014 Cos\u2019\u00e8 SQL e perch\u00e9 \u00e8 dichiarativo; schema del database; tipi di dato (DB-agnostic); operazioni CRUD. Esempi pratici \u2014 Operazioni CRUD. \ud83d\udc49 Vai alla lezione","title":"Lezione 02 \u2014 Primo contatto con SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#lezione-03-relazioni-e-join","text":"Problema \u2014 Leggere dati distribuiti su pi\u00f9 tabelle (post + autore, commenti + post, ecc.). Teoria \u2014 JOIN tramite chiavi (FK \u2192 PK); differenza tra INNER JOIN e LEFT JOIN ; alias e naming. Esempi pratici \u2014 Post con autore ( JOIN users ); commenti con autore e post; post anche senza commenti ( LEFT JOIN + COUNT ). Esercizi \u2014 Progettare un database con studenti , corsi e iscrizioni (relazione molti-a-molti); creare tabelle, inserire dati, verificare con SELECT , e fare una query con JOIN per mostrare studente + corso. \ud83d\udc49 Vai alla lezione","title":"Lezione 03 \u2014 Relazioni e JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#output-del-modulo","text":"Alla fine del modulo esistono: un problema ben definito un insieme di requisiti espliciti un modello dati coerente una prima implementazione reale un linguaggio tecnico condiviso tra tutti i partecipanti Questi elementi costituiscono la base tecnica comune dell\u2019intero corso.","title":"Output del modulo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#errori-comuni-da-evitare","text":"saltare la modellazione per \u201candare subito su SQL\u201d confondere tabelle con entit\u00e0 concettuali ignorare i vincoli pensando di gestirli \u201ca codice\u201d duplicare dati per comodit\u00e0 pensare che SQL sia solo sintassi Questo modulo serve a costruire fondamenta solide .","title":"Errori comuni da evitare"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#navigazione","text":"Progetto Lezione 01 Lezione 02 Lezione 03 Glossario Moduli","title":"Navigazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/","text":"Glossario \u2014 Modulo 01: Fondamenti dei database \u00b6 Questo glossario raccoglie i termini fondamentali introdotti nel Modulo 01 . Le definizioni sono: - intenzionalmente precise - coerenti con il corso - pensate per essere riutilizzate nei moduli successivi Database \u00b6 Collezione organizzata di dati progettata per essere memorizzata, interrogata e mantenuta in modo coerente e affidabile. Un database non \u00e8 solo storage, ma un sistema che impone regole sui dati. Database relazionale \u00b6 Tipo di database che organizza i dati in tabelle collegate tra loro tramite relazioni esplicite. Le relazioni sono implementate tramite chiavi e vincoli. Tabella \u00b6 Struttura che rappresenta un insieme di entit\u00e0 omogenee. \u00c8 composta da righe (record) e colonne (campi). Record (riga) \u00b6 Singola istanza di un\u2019entit\u00e0 all\u2019interno di una tabella. Ogni record rappresenta un elemento specifico (es. un utente). Campo (colonna) \u00b6 Propriet\u00e0 di un\u2019entit\u00e0. Ogni campo ha: - un nome - un tipo di dato - eventuali vincoli Schema \u00b6 Definizione strutturale del database. Include: - tabelle - campi - tipi di dato - vincoli - relazioni Tipo di dato \u00b6 Categoria che definisce quali valori sono ammessi in una colonna e come vengono memorizzati. Esempi comuni: INTEGER , TEXT , REAL . Entit\u00e0 \u00b6 Concetto astratto che rappresenta qualcosa di rilevante nel dominio del problema. Un\u2019entit\u00e0 diventa una tabella quando viene implementata in un database relazionale. Relazione \u00b6 Collegamento logico tra due entit\u00e0. Nel database relazionale \u00e8 implementata tramite foreign key o tabelle di collegamento. Cardinalit\u00e0 \u00b6 Descrive quante istanze di un\u2019entit\u00e0 possono essere associate a un\u2019altra. Forme principali: - 1:1 (uno a uno) - 1:N (uno a molti) - N:M (molti a molti) Tabella ponte (junction table) \u00b6 Tabella usata per rappresentare una relazione N:M tra due entit\u00e0. Contiene tipicamente due foreign key, una per ciascuna tabella collegata. Primary Key (PK) \u00b6 Campo o insieme di campi che identifica univocamente un record in una tabella. Una primary key: - \u00e8 unica - non pu\u00f2 essere NULL - \u00e8 stabile nel tempo Foreign Key (FK) \u00b6 Campo che fa riferimento alla primary key di un\u2019altra tabella. Serve a: - creare relazioni - garantire integrit\u00e0 referenziale Integrit\u00e0 referenziale \u00b6 Propriet\u00e0 che assicura che ogni foreign key punti a un record esistente nella tabella referenziata. Vincolo (Constraint) \u00b6 Regola applicata dal database per impedire stati invalidi dei dati. Esempi: - PRIMARY KEY - FOREIGN KEY - UNIQUE - NOT NULL Integrit\u00e0 dei dati \u00b6 Propriet\u00e0 che garantisce che i dati siano corretti, coerenti e consistenti nel tempo. \u00c8 garantita tramite vincoli e regole del database. Modello dei dati \u00b6 Rappresentazione strutturata delle entit\u00e0, delle relazioni e dei vincoli del sistema. Pu\u00f2 essere: - concettuale - logico - fisico SQL (Structured Query Language) \u00b6 Linguaggio standard per interagire con database relazionali. SQL \u00e8 dichiarativo: descrive cosa ottenere, non come ottenerlo. DDL (Data Definition Language) \u00b6 Famiglia di comandi SQL che definisce o modifica la struttura del database. Esempi: CREATE , ALTER , DROP . DML (Data Manipulation Language) \u00b6 Famiglia di comandi SQL che inserisce, aggiorna o elimina dati. Esempi: INSERT , UPDATE , DELETE . DQL (Data Query Language) \u00b6 Famiglia di comandi SQL che legge i dati. Esempio: SELECT . TCL (Transaction Control Language) \u00b6 Famiglia di comandi SQL che gestisce le transazioni. Esempi: BEGIN , COMMIT , ROLLBACK , SAVEPOINT . DCL (Data Control Language) \u00b6 Famiglia di comandi SQL che gestisce permessi e ruoli. Esempi: GRANT , REVOKE . Query \u00b6 Richiesta inviata al database per leggere o modificare dati. Una query pu\u00f2 essere: - di lettura ( SELECT ) - di modifica ( INSERT , UPDATE , DELETE ) - di definizione ( CREATE , ALTER , DROP ) SELECT \u00b6 Comando SQL che legge dati da una o pi\u00f9 tabelle. \u00c8 spesso combinato con clausole come WHERE , ORDER BY , LIMIT . INSERT \u00b6 Comando SQL che inserisce nuove righe in una tabella. UPDATE \u00b6 Comando SQL che modifica righe esistenti in una tabella. DELETE \u00b6 Comando SQL che rimuove righe da una tabella. WHERE \u00b6 Clausola che filtra le righe in una query in base a condizioni logiche. ORDER BY \u00b6 Clausola che ordina i risultati di una query per una o pi\u00f9 colonne. LIMIT \u00b6 Clausola che limita il numero massimo di righe restituite. OFFSET \u00b6 Clausola che salta un certo numero di righe prima di restituire i risultati. JOIN \u00b6 Operazione che combina righe di due o pi\u00f9 tabelle usando una condizione di collegamento. INNER JOIN \u00b6 Tipo di JOIN che restituisce solo le righe con corrispondenza in entrambe le tabelle. LEFT JOIN \u00b6 Tipo di JOIN che restituisce tutte le righe della tabella di sinistra, anche senza corrispondenza a destra. Alias \u00b6 Nome temporaneo dato a una tabella o a una colonna per rendere una query pi\u00f9 leggibile. Aggregazione \u00b6 Operazione che sintetizza pi\u00f9 righe in un unico risultato (es. somme, conteggi, medie). GROUP BY \u00b6 Clausola che raggruppa le righe con valori uguali per applicare funzioni di aggregazione. COUNT \u00b6 Funzione di aggregazione che conta il numero di righe (o valori non NULL ). NULL \u00b6 Valore speciale che indica \u201cassenza di valore\u201d in una colonna. Si verifica con IS NULL o IS NOT NULL . Autoincremento \u00b6 Meccanismo che assegna automaticamente un valore numerico crescente a una primary key. CRUD \u00b6 Acronimo che identifica le quattro operazioni fondamentali sui dati: Create Read Update Delete DB-agnostic \u00b6 Approccio che evita dipendenze da un database specifico. Un modello o una query DB-agnostic pu\u00f2 essere eseguita su pi\u00f9 database con minime o nessune modifiche. Normalizzazione \u00b6 Processo di organizzazione dei dati per ridurre duplicazioni e anomalie. \u00c8 una conseguenza di una corretta modellazione, non un obiettivo fine a s\u00e9 stesso. Transazione \u00b6 Gruppo di operazioni eseguite come un\u2019unica unit\u00e0 logica. Una transazione \u00e8: - atomica - consistente - isolata - durabile (ACID) Progetto unico \u00b6 Approccio didattico in cui tutte le lezioni contribuiscono allo sviluppo di un unico sistema coerente. Il progetto evolve, ma non viene mai azzerato.","title":"Glossario"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#glossario-modulo-01-fondamenti-dei-database","text":"Questo glossario raccoglie i termini fondamentali introdotti nel Modulo 01 . Le definizioni sono: - intenzionalmente precise - coerenti con il corso - pensate per essere riutilizzate nei moduli successivi","title":"Glossario \u2014 Modulo 01: Fondamenti dei database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#database","text":"Collezione organizzata di dati progettata per essere memorizzata, interrogata e mantenuta in modo coerente e affidabile. Un database non \u00e8 solo storage, ma un sistema che impone regole sui dati.","title":"Database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#database-relazionale","text":"Tipo di database che organizza i dati in tabelle collegate tra loro tramite relazioni esplicite. Le relazioni sono implementate tramite chiavi e vincoli.","title":"Database relazionale"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#tabella","text":"Struttura che rappresenta un insieme di entit\u00e0 omogenee. \u00c8 composta da righe (record) e colonne (campi).","title":"Tabella"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#record-riga","text":"Singola istanza di un\u2019entit\u00e0 all\u2019interno di una tabella. Ogni record rappresenta un elemento specifico (es. un utente).","title":"Record (riga)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#campo-colonna","text":"Propriet\u00e0 di un\u2019entit\u00e0. Ogni campo ha: - un nome - un tipo di dato - eventuali vincoli","title":"Campo (colonna)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#schema","text":"Definizione strutturale del database. Include: - tabelle - campi - tipi di dato - vincoli - relazioni","title":"Schema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#tipo-di-dato","text":"Categoria che definisce quali valori sono ammessi in una colonna e come vengono memorizzati. Esempi comuni: INTEGER , TEXT , REAL .","title":"Tipo di dato"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#entita","text":"Concetto astratto che rappresenta qualcosa di rilevante nel dominio del problema. Un\u2019entit\u00e0 diventa una tabella quando viene implementata in un database relazionale.","title":"Entit\u00e0"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#relazione","text":"Collegamento logico tra due entit\u00e0. Nel database relazionale \u00e8 implementata tramite foreign key o tabelle di collegamento.","title":"Relazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#cardinalita","text":"Descrive quante istanze di un\u2019entit\u00e0 possono essere associate a un\u2019altra. Forme principali: - 1:1 (uno a uno) - 1:N (uno a molti) - N:M (molti a molti)","title":"Cardinalit\u00e0"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#tabella-ponte-junction-table","text":"Tabella usata per rappresentare una relazione N:M tra due entit\u00e0. Contiene tipicamente due foreign key, una per ciascuna tabella collegata.","title":"Tabella ponte (junction table)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#primary-key-pk","text":"Campo o insieme di campi che identifica univocamente un record in una tabella. Una primary key: - \u00e8 unica - non pu\u00f2 essere NULL - \u00e8 stabile nel tempo","title":"Primary Key (PK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#foreign-key-fk","text":"Campo che fa riferimento alla primary key di un\u2019altra tabella. Serve a: - creare relazioni - garantire integrit\u00e0 referenziale","title":"Foreign Key (FK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#integrita-referenziale","text":"Propriet\u00e0 che assicura che ogni foreign key punti a un record esistente nella tabella referenziata.","title":"Integrit\u00e0 referenziale"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#vincolo-constraint","text":"Regola applicata dal database per impedire stati invalidi dei dati. Esempi: - PRIMARY KEY - FOREIGN KEY - UNIQUE - NOT NULL","title":"Vincolo (Constraint)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#integrita-dei-dati","text":"Propriet\u00e0 che garantisce che i dati siano corretti, coerenti e consistenti nel tempo. \u00c8 garantita tramite vincoli e regole del database.","title":"Integrit\u00e0 dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#modello-dei-dati","text":"Rappresentazione strutturata delle entit\u00e0, delle relazioni e dei vincoli del sistema. Pu\u00f2 essere: - concettuale - logico - fisico","title":"Modello dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#sql-structured-query-language","text":"Linguaggio standard per interagire con database relazionali. SQL \u00e8 dichiarativo: descrive cosa ottenere, non come ottenerlo.","title":"SQL (Structured Query Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#ddl-data-definition-language","text":"Famiglia di comandi SQL che definisce o modifica la struttura del database. Esempi: CREATE , ALTER , DROP .","title":"DDL (Data Definition Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#dml-data-manipulation-language","text":"Famiglia di comandi SQL che inserisce, aggiorna o elimina dati. Esempi: INSERT , UPDATE , DELETE .","title":"DML (Data Manipulation Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#dql-data-query-language","text":"Famiglia di comandi SQL che legge i dati. Esempio: SELECT .","title":"DQL (Data Query Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#tcl-transaction-control-language","text":"Famiglia di comandi SQL che gestisce le transazioni. Esempi: BEGIN , COMMIT , ROLLBACK , SAVEPOINT .","title":"TCL (Transaction Control Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#dcl-data-control-language","text":"Famiglia di comandi SQL che gestisce permessi e ruoli. Esempi: GRANT , REVOKE .","title":"DCL (Data Control Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#query","text":"Richiesta inviata al database per leggere o modificare dati. Una query pu\u00f2 essere: - di lettura ( SELECT ) - di modifica ( INSERT , UPDATE , DELETE ) - di definizione ( CREATE , ALTER , DROP )","title":"Query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#select","text":"Comando SQL che legge dati da una o pi\u00f9 tabelle. \u00c8 spesso combinato con clausole come WHERE , ORDER BY , LIMIT .","title":"SELECT"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#insert","text":"Comando SQL che inserisce nuove righe in una tabella.","title":"INSERT"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#update","text":"Comando SQL che modifica righe esistenti in una tabella.","title":"UPDATE"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#delete","text":"Comando SQL che rimuove righe da una tabella.","title":"DELETE"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#where","text":"Clausola che filtra le righe in una query in base a condizioni logiche.","title":"WHERE"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#order-by","text":"Clausola che ordina i risultati di una query per una o pi\u00f9 colonne.","title":"ORDER BY"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#limit","text":"Clausola che limita il numero massimo di righe restituite.","title":"LIMIT"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#offset","text":"Clausola che salta un certo numero di righe prima di restituire i risultati.","title":"OFFSET"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#join","text":"Operazione che combina righe di due o pi\u00f9 tabelle usando una condizione di collegamento.","title":"JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#inner-join","text":"Tipo di JOIN che restituisce solo le righe con corrispondenza in entrambe le tabelle.","title":"INNER JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#left-join","text":"Tipo di JOIN che restituisce tutte le righe della tabella di sinistra, anche senza corrispondenza a destra.","title":"LEFT JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#alias","text":"Nome temporaneo dato a una tabella o a una colonna per rendere una query pi\u00f9 leggibile.","title":"Alias"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#aggregazione","text":"Operazione che sintetizza pi\u00f9 righe in un unico risultato (es. somme, conteggi, medie).","title":"Aggregazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#group-by","text":"Clausola che raggruppa le righe con valori uguali per applicare funzioni di aggregazione.","title":"GROUP BY"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#count","text":"Funzione di aggregazione che conta il numero di righe (o valori non NULL ).","title":"COUNT"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#null","text":"Valore speciale che indica \u201cassenza di valore\u201d in una colonna. Si verifica con IS NULL o IS NOT NULL .","title":"NULL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#autoincremento","text":"Meccanismo che assegna automaticamente un valore numerico crescente a una primary key.","title":"Autoincremento"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#crud","text":"Acronimo che identifica le quattro operazioni fondamentali sui dati: Create Read Update Delete","title":"CRUD"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#db-agnostic","text":"Approccio che evita dipendenze da un database specifico. Un modello o una query DB-agnostic pu\u00f2 essere eseguita su pi\u00f9 database con minime o nessune modifiche.","title":"DB-agnostic"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#normalizzazione","text":"Processo di organizzazione dei dati per ridurre duplicazioni e anomalie. \u00c8 una conseguenza di una corretta modellazione, non un obiettivo fine a s\u00e9 stesso.","title":"Normalizzazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#transazione","text":"Gruppo di operazioni eseguite come un\u2019unica unit\u00e0 logica. Una transazione \u00e8: - atomica - consistente - isolata - durabile (ACID)","title":"Transazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#progetto-unico","text":"Approccio didattico in cui tutte le lezioni contribuiscono allo sviluppo di un unico sistema coerente. Il progetto evolve, ma non viene mai azzerato.","title":"Progetto unico"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/","text":"Lezione 01 \u2014 Introduzione ai database \u00b6 Problema \u00b6 Stiamo sviluppando un sistema informatico che deve gestire dati reali: - utenti - contenuti creati dagli utenti - relazioni tra utenti e contenuti All\u2019inizio potremmo pensare di usare semplici file ( .txt , .csv , .json ), ma emergono subito problemi concreti: come garantiamo che i dati siano coerenti? come evitiamo duplicazioni? come gestiamo pi\u00f9 utenti che accedono agli stessi dati? come modelliamo relazioni complesse (es. utenti \u2192 post \u2192 commenti)? Problema centrale: come memorizzare, organizzare e interrogare dati in modo strutturato, scalabile e affidabile? Questa lezione introduce lo strumento che useremo per risolvere il problema: il database . Teoria \u00b6 Cos\u2019\u00e8 un database \u00b6 Un database \u00e8 una collezione organizzata di dati progettata per: memorizzare informazioni in modo strutturato permettere accesso efficiente ai dati garantire coerenza e integrit\u00e0 supportare accesso concorrente Un database non \u00e8 solo storage , ma un sistema che impone regole. Perch\u00e9 non bastano i file \u00b6 L\u2019uso di file presenta limiti strutturali: nessuna garanzia di unicit\u00e0 relazioni gestite \u201ca mano\u201d difficolt\u00e0 di accesso concorrente ricerca inefficiente su grandi volumi di dati assenza di vincoli formali Un database introduce regole esplicite che impediscono stati inconsistenti. Tipi di database \u00b6 Database relazionali (SQL) \u00b6 dati organizzati in tabelle struttura definita (schema) relazioni esplicite tra dati linguaggio SQL per interrogazione Esempi: SQLite, MySQL, PostgreSQL. Database non relazionali (NoSQL) \u00b6 struttura pi\u00f9 flessibile modelli diversi (documenti, key-value, grafi) utili in contesti specifici \ud83d\udc49 In questo corso useremo database relazionali . Tabelle, righe e colonne \u00b6 Una tabella rappresenta un insieme di entit\u00e0 omogenee. Riga (record) : una singola entit\u00e0 Colonna (campo) : una propriet\u00e0 dell\u2019entit\u00e0 Esempio concettuale: id username email 1 alice alice@example.com Chiavi e vincoli \u00b6 Quando progettiamo una tabella, non basta decidere \u201cquali colonne mettere\u201d. Dobbiamo anche stabilire quali regole rendono i dati affidabili e collegabili tra loro. In un database relazionale queste regole si esprimono soprattutto attraverso: chiavi (primary key e foreign key) vincoli (constraints). L\u2019obiettivo \u00e8 sempre lo stesso: evitare dati \u201csporchi\u201d o incoerenti e rendere le relazioni tra tabelle solide. Primary Key (PK) \u00b6 La Primary Key \u00e8 la colonna (o l\u2019insieme di colonne) che identifica in modo univoco ogni riga della tabella. In pratica \u00e8 \u201cil documento di identit\u00e0\u201d del record: due righe non possono avere la stessa PK e la PK non pu\u00f2 mancare. La Primary Key \u00e8 fondamentale per due motivi: ti permette di recuperare e modificare una riga in modo preciso; permette alle altre tabelle di riferirsi a quella riga quando si creano relazioni. Foreign Key (FK) \u00b6 La Foreign Key \u00e8 un vincolo che dice: \u201cquesta colonna contiene un valore che deve esistere come PK in un\u2019altra tabella\u201d. Serve a rappresentare relazioni e, soprattutto, a far rispettare la coerenza. Esempio: se nella tabella posts hai user_id , quel valore deve corrispondere a un users.id realmente presente. Se provi a inserire un post con user_id = 999 ma l\u2019utente 999 non esiste, il database pu\u00f2 rifiutare l\u2019operazione. In questo modo eviti record \u201corfani\u201d (post senza utente). Vincoli (constraints) \u00b6 I vincoli sono regole applicate direttamente dal database per impedire stati non validi. L\u2019idea \u00e8 spostare la \u201cresponsabilit\u00e0\u201d della correttezza dei dati dal codice applicativo al database, cos\u00ec i controlli sono automatici e coerenti per ogni inserimento/modifica. I vincoli pi\u00f9 comuni che incontreremo sono: PRIMARY KEY : garantisce identificazione univoca della riga. FOREIGN KEY : garantisce che i riferimenti tra tabelle siano validi. UNIQUE : impedisce duplicati in una colonna (o combinazione di colonne), ad esempio per email . NOT NULL : impone che un valore sia sempre presente, ad esempio per username . In sintesi: chiavi + vincoli servono a mantenere l\u2019 integrit\u00e0 dei dati , cio\u00e8 dati corretti, consistenti e collegati in modo affidabile. Relazioni tra tabelle (logica in SQL) \u00b6 In un database relazionale, una relazione tra due \u201centit\u00e0\u201d non \u00e8 un collegamento \u201cmagico\u201d: viene rappresentata tramite valori e vincoli . Prima ragioniamo a livello logico (modello) identifichiamo le entit\u00e0 (es. users , posts , comments ) decidiamo le cardinalit\u00e0 (1:1, 1:N, N:M) scegliamo quali dati identificano un record ( Primary Key ) Poi traduciamo il modello in SQL (implementazione) usiamo Primary Key (PK) per identificare univocamente le righe usiamo Foreign Key (FK) per \u201cpuntare\u201d a una PK di un\u2019altra tabella applichiamo vincoli per evitare stati incoerenti (es. FK che punta a un record inesistente) Di fatto, la relazione \u00e8 il fatto che una colonna contiene l\u2019identificatore (PK) di un\u2019altra tabella , e il database pu\u00f2 far rispettare questa regola con una FK. One-to-One (1:1) \u00b6 Idea logica: un record di A corrisponde a al massimo un record di B (e viceversa). In SQL: si usa una FK con vincolo UNIQUE (oppure si condivide la stessa PK). Esempio (profilo utente separato): CREATE TABLE user_profiles ( user_id INTEGER PRIMARY KEY, bio TEXT, FOREIGN KEY (user_id) REFERENCES users(id) ); Qui user_id \u00e8 anche PK: garantisce un solo profilo per utente . One-to-Many (1:N) \u00b6 Idea logica: un record di A pu\u00f2 essere associato a molti record di B, ma ogni record di B appartiene a un solo record di A. In SQL: la FK sta nella tabella \u201cmolti\u201d (tabella B). Esempio (un utente pu\u00f2 avere molti post): CREATE TABLE posts ( id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, title TEXT NOT NULL, FOREIGN KEY (user_id) REFERENCES users(id) ); posts.user_id collega ogni post a un utente, mentre lo stesso utente pu\u00f2 comparire in molte righe di posts . Many-to-Many (N:M) \u00b6 Idea logica: molti record di A possono essere associati a molti record di B. In SQL: non si mette una FK \u201cdiretta\u201d da una parte all\u2019altra: si crea una tabella ponte (junction table o pivot table) con due FK . Esempio (utenti che mettono \u201clike\u201d ai post): CREATE TABLE post_likes ( user_id INTEGER NOT NULL, post_id INTEGER NOT NULL, PRIMARY KEY (user_id, post_id), FOREIGN KEY (user_id) REFERENCES users(id), FOREIGN KEY (post_id) REFERENCES posts(id) ); ogni riga rappresenta una singola associazione (utente, post) la PRIMARY KEY (user_id, post_id) impedisce duplicati (stesso like ripetuto) Nota importante: le FK servono a mantenere l\u2019integrit\u00e0 (coerenza) dei dati; le query ( JOIN ) servono a leggere le relazioni combinando le tabelle quando ti serve. Esempi \u00b6 Esempio: creare un nuovo database sqlite \u00b6 Iniziamo con una procedura corretta per creare (o aprire) un database SQLite. Su Ubuntu installa SQLite aggiornando prima l\u2019indice dei pacchetti: sudo apt update sudo apt install -y sqlite3 Verifica che l\u2019installazione sia andata a buon fine controllando la versione: sqlite3 --version Crea/apri un database eseguendo sqlite3 indicando il nome del file: sqlite3 nome_database.db Se nome_database.db non esiste, SQLite lo crea automaticamente nella cartella corrente (puoi verificarla con pwd prima di lanciare il comando). Dentro la shell di SQLite controlla quali database sono \u201cagganciati\u201d e il relativo percorso: .databases Per uscire dalla shell: .exit Esempio: struttura dati del progetto \u00b6 Come illustato nel nostro progetto iniziale gestiremo le seguenti tabelle: utenti post commenti Tabella users \u00b6 Creiamo la tabella utenti. CREATE TABLE users ( id INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE, email TEXT NOT NULL UNIQUE, born_year INTEGER, born_month INTEGER, born_day INTEGER ); Qui: id identifica univocamente l\u2019utente UNIQUE e NOT NULL sono vincoli il database impedisce stati invalidi Tabella posts \u00b6 Creiamo la tabella posts. CREATE TABLE posts ( id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, title TEXT NOT NULL, content TEXT, FOREIGN KEY (user_id) REFERENCES users(id) ); La foreign key rende esplicita la relazione 1:N. Tabella Commments \u00b6 Creiamo la tabella commenti. CREATE TABLE comments ( id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, post_id INTEGER NOT NULL, content TEXT NOT NULL, FOREIGN KEY (user_id) REFERENCES users(id), FOREIGN KEY (post_id) REFERENCES posts(id) );","title":"Lezione 01 \u2014 Introduzione ai database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#lezione-01-introduzione-ai-database","text":"","title":"Lezione 01 \u2014 Introduzione ai database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#problema","text":"Stiamo sviluppando un sistema informatico che deve gestire dati reali: - utenti - contenuti creati dagli utenti - relazioni tra utenti e contenuti All\u2019inizio potremmo pensare di usare semplici file ( .txt , .csv , .json ), ma emergono subito problemi concreti: come garantiamo che i dati siano coerenti? come evitiamo duplicazioni? come gestiamo pi\u00f9 utenti che accedono agli stessi dati? come modelliamo relazioni complesse (es. utenti \u2192 post \u2192 commenti)? Problema centrale: come memorizzare, organizzare e interrogare dati in modo strutturato, scalabile e affidabile? Questa lezione introduce lo strumento che useremo per risolvere il problema: il database .","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#cose-un-database","text":"Un database \u00e8 una collezione organizzata di dati progettata per: memorizzare informazioni in modo strutturato permettere accesso efficiente ai dati garantire coerenza e integrit\u00e0 supportare accesso concorrente Un database non \u00e8 solo storage , ma un sistema che impone regole.","title":"Cos\u2019\u00e8 un database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#perche-non-bastano-i-file","text":"L\u2019uso di file presenta limiti strutturali: nessuna garanzia di unicit\u00e0 relazioni gestite \u201ca mano\u201d difficolt\u00e0 di accesso concorrente ricerca inefficiente su grandi volumi di dati assenza di vincoli formali Un database introduce regole esplicite che impediscono stati inconsistenti.","title":"Perch\u00e9 non bastano i file"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tipi-di-database","text":"","title":"Tipi di database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#database-relazionali-sql","text":"dati organizzati in tabelle struttura definita (schema) relazioni esplicite tra dati linguaggio SQL per interrogazione Esempi: SQLite, MySQL, PostgreSQL.","title":"Database relazionali (SQL)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#database-non-relazionali-nosql","text":"struttura pi\u00f9 flessibile modelli diversi (documenti, key-value, grafi) utili in contesti specifici \ud83d\udc49 In questo corso useremo database relazionali .","title":"Database non relazionali (NoSQL)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabelle-righe-e-colonne","text":"Una tabella rappresenta un insieme di entit\u00e0 omogenee. Riga (record) : una singola entit\u00e0 Colonna (campo) : una propriet\u00e0 dell\u2019entit\u00e0 Esempio concettuale: id username email 1 alice alice@example.com","title":"Tabelle, righe e colonne"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#chiavi-e-vincoli","text":"Quando progettiamo una tabella, non basta decidere \u201cquali colonne mettere\u201d. Dobbiamo anche stabilire quali regole rendono i dati affidabili e collegabili tra loro. In un database relazionale queste regole si esprimono soprattutto attraverso: chiavi (primary key e foreign key) vincoli (constraints). L\u2019obiettivo \u00e8 sempre lo stesso: evitare dati \u201csporchi\u201d o incoerenti e rendere le relazioni tra tabelle solide.","title":"Chiavi e vincoli"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#primary-key-pk","text":"La Primary Key \u00e8 la colonna (o l\u2019insieme di colonne) che identifica in modo univoco ogni riga della tabella. In pratica \u00e8 \u201cil documento di identit\u00e0\u201d del record: due righe non possono avere la stessa PK e la PK non pu\u00f2 mancare. La Primary Key \u00e8 fondamentale per due motivi: ti permette di recuperare e modificare una riga in modo preciso; permette alle altre tabelle di riferirsi a quella riga quando si creano relazioni.","title":"Primary Key (PK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#foreign-key-fk","text":"La Foreign Key \u00e8 un vincolo che dice: \u201cquesta colonna contiene un valore che deve esistere come PK in un\u2019altra tabella\u201d. Serve a rappresentare relazioni e, soprattutto, a far rispettare la coerenza. Esempio: se nella tabella posts hai user_id , quel valore deve corrispondere a un users.id realmente presente. Se provi a inserire un post con user_id = 999 ma l\u2019utente 999 non esiste, il database pu\u00f2 rifiutare l\u2019operazione. In questo modo eviti record \u201corfani\u201d (post senza utente).","title":"Foreign Key (FK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#vincoli-constraints","text":"I vincoli sono regole applicate direttamente dal database per impedire stati non validi. L\u2019idea \u00e8 spostare la \u201cresponsabilit\u00e0\u201d della correttezza dei dati dal codice applicativo al database, cos\u00ec i controlli sono automatici e coerenti per ogni inserimento/modifica. I vincoli pi\u00f9 comuni che incontreremo sono: PRIMARY KEY : garantisce identificazione univoca della riga. FOREIGN KEY : garantisce che i riferimenti tra tabelle siano validi. UNIQUE : impedisce duplicati in una colonna (o combinazione di colonne), ad esempio per email . NOT NULL : impone che un valore sia sempre presente, ad esempio per username . In sintesi: chiavi + vincoli servono a mantenere l\u2019 integrit\u00e0 dei dati , cio\u00e8 dati corretti, consistenti e collegati in modo affidabile.","title":"Vincoli (constraints)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#relazioni-tra-tabelle-logica-in-sql","text":"In un database relazionale, una relazione tra due \u201centit\u00e0\u201d non \u00e8 un collegamento \u201cmagico\u201d: viene rappresentata tramite valori e vincoli . Prima ragioniamo a livello logico (modello) identifichiamo le entit\u00e0 (es. users , posts , comments ) decidiamo le cardinalit\u00e0 (1:1, 1:N, N:M) scegliamo quali dati identificano un record ( Primary Key ) Poi traduciamo il modello in SQL (implementazione) usiamo Primary Key (PK) per identificare univocamente le righe usiamo Foreign Key (FK) per \u201cpuntare\u201d a una PK di un\u2019altra tabella applichiamo vincoli per evitare stati incoerenti (es. FK che punta a un record inesistente) Di fatto, la relazione \u00e8 il fatto che una colonna contiene l\u2019identificatore (PK) di un\u2019altra tabella , e il database pu\u00f2 far rispettare questa regola con una FK.","title":"Relazioni tra tabelle (logica in SQL)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#one-to-one-11","text":"Idea logica: un record di A corrisponde a al massimo un record di B (e viceversa). In SQL: si usa una FK con vincolo UNIQUE (oppure si condivide la stessa PK). Esempio (profilo utente separato): CREATE TABLE user_profiles ( user_id INTEGER PRIMARY KEY, bio TEXT, FOREIGN KEY (user_id) REFERENCES users(id) ); Qui user_id \u00e8 anche PK: garantisce un solo profilo per utente .","title":"One-to-One (1:1)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#one-to-many-1n","text":"Idea logica: un record di A pu\u00f2 essere associato a molti record di B, ma ogni record di B appartiene a un solo record di A. In SQL: la FK sta nella tabella \u201cmolti\u201d (tabella B). Esempio (un utente pu\u00f2 avere molti post): CREATE TABLE posts ( id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, title TEXT NOT NULL, FOREIGN KEY (user_id) REFERENCES users(id) ); posts.user_id collega ogni post a un utente, mentre lo stesso utente pu\u00f2 comparire in molte righe di posts .","title":"One-to-Many (1:N)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#many-to-many-nm","text":"Idea logica: molti record di A possono essere associati a molti record di B. In SQL: non si mette una FK \u201cdiretta\u201d da una parte all\u2019altra: si crea una tabella ponte (junction table o pivot table) con due FK . Esempio (utenti che mettono \u201clike\u201d ai post): CREATE TABLE post_likes ( user_id INTEGER NOT NULL, post_id INTEGER NOT NULL, PRIMARY KEY (user_id, post_id), FOREIGN KEY (user_id) REFERENCES users(id), FOREIGN KEY (post_id) REFERENCES posts(id) ); ogni riga rappresenta una singola associazione (utente, post) la PRIMARY KEY (user_id, post_id) impedisce duplicati (stesso like ripetuto) Nota importante: le FK servono a mantenere l\u2019integrit\u00e0 (coerenza) dei dati; le query ( JOIN ) servono a leggere le relazioni combinando le tabelle quando ti serve.","title":"Many-to-Many (N:M)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#esempi","text":"","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#esempio-creare-un-nuovo-database-sqlite","text":"Iniziamo con una procedura corretta per creare (o aprire) un database SQLite. Su Ubuntu installa SQLite aggiornando prima l\u2019indice dei pacchetti: sudo apt update sudo apt install -y sqlite3 Verifica che l\u2019installazione sia andata a buon fine controllando la versione: sqlite3 --version Crea/apri un database eseguendo sqlite3 indicando il nome del file: sqlite3 nome_database.db Se nome_database.db non esiste, SQLite lo crea automaticamente nella cartella corrente (puoi verificarla con pwd prima di lanciare il comando). Dentro la shell di SQLite controlla quali database sono \u201cagganciati\u201d e il relativo percorso: .databases Per uscire dalla shell: .exit","title":"Esempio: creare un nuovo database sqlite"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#esempio-struttura-dati-del-progetto","text":"Come illustato nel nostro progetto iniziale gestiremo le seguenti tabelle: utenti post commenti","title":"Esempio: struttura dati del progetto"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabella-users","text":"Creiamo la tabella utenti. CREATE TABLE users ( id INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE, email TEXT NOT NULL UNIQUE, born_year INTEGER, born_month INTEGER, born_day INTEGER ); Qui: id identifica univocamente l\u2019utente UNIQUE e NOT NULL sono vincoli il database impedisce stati invalidi","title":"Tabella users"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabella-posts","text":"Creiamo la tabella posts. CREATE TABLE posts ( id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, title TEXT NOT NULL, content TEXT, FOREIGN KEY (user_id) REFERENCES users(id) ); La foreign key rende esplicita la relazione 1:N.","title":"Tabella posts"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabella-commments","text":"Creiamo la tabella commenti. CREATE TABLE comments ( id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, post_id INTEGER NOT NULL, content TEXT NOT NULL, FOREIGN KEY (user_id) REFERENCES users(id), FOREIGN KEY (post_id) REFERENCES posts(id) );","title":"Tabella Commments"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/","text":"Lezione 02 \u2014 Primo contatto con SQL \u00b6 Problema \u00b6 Abbiamo un modello concettuale ed abbiamo creato le tabelle utenti, posts e commenti. Ora dobbiamo trasformarlo in una struttura reale: inserire dati di esempio interrogare e modificare quei dati in modo controllato Obiettivo: passare da \u201cidea\u201d a \u201csistema interrogabile\u201d. Questo significa introdurre SQL come strumento operativo. Teoria \u00b6 Cos\u2019\u00e8 SQL \u00b6 SQL (Structured Query Language) \u00e8 il linguaggio standard usato per: definire la struttura del database inserire dati leggere dati modificarli cancellarli SQL non \u00e8 un linguaggio di programmazione generale , ma un linguaggio dichiarativo: dici cosa vuoi ottenere, non come ottenerlo. SQL: linguaggio dichiarativo \u00b6 SQL \u00e8 un linguaggio dichiarativo : quando scrivi una query descrivi il risultato che vuoi (quali righe/colonne), non i passaggi operativi per ottenerlo. Questo significa che: tu specifichi vincoli e condizioni ( WHERE , JOIN , GROUP BY , ORDER BY ) il database decide come eseguire la richiesta nel modo pi\u00f9 efficiente (piano di esecuzione: indici, ordine delle operazioni, strategie di join) In altre parole, non dici \u201cscorri tutte le righe una per una\u201d, ma \u201cdammi le righe che rispettano queste condizioni\u201d. Esempio (tu descrivi il risultato): SELECT id, username FROM users WHERE born_year >= 1999 ORDER BY username; Il DB stabilisce il \u201ccome\u201d (se usare un indice, in che ordine leggere i dati, ecc.). Famiglie di comandi che useremo \u00b6 Nelle lezioni useremo e nomineremo queste famiglie di comandi SQL (in base al DB, alcune classificazioni possono variare): DDL (Data Definition Language) : definisce o modifica la struttura del database (schema) Comandi tipici: CREATE , ALTER , DROP , TRUNCATE DML (Data Manipulation Language) : inserisce, aggiorna o elimina i dati Comandi tipici: INSERT , UPDATE , DELETE , MERGE (non sempre disponibile) DQL (Data Query Language) : interroga/legge i dati (spesso considerata parte della DML) Comandi tipici: SELECT (+ WHERE , JOIN , GROUP BY , HAVING , ORDER BY , LIMIT ) TCL (Transaction Control Language) : controlla le transazioni (atomicit\u00e0/rollback) Comandi tipici: BEGIN / START TRANSACTION , COMMIT , ROLLBACK , SAVEPOINT DCL (Data Control Language) : gestisce permessi e sicurezza (utenti/ruoli) Comandi tipici: GRANT , REVOKE Regola pratica: - DDL = struttura , - DQL/DML = dati , - TCL = coerenza delle operazioni , - DCL = accessi . In genere: prima si crea lo schema (DDL), poi si lavora/interroga sui dati (DQL/DML), eventualmente dentro transazioni (TCL). Il concetto di schema \u00b6 Lo schema rappresenta la struttura del database: tabelle colonne tipi di dato vincoli relazioni \u00c8 il passaggio formale dal modello logico all\u2019 implementazione fisica . Tipi di dato (DB-agnostic) \u00b6 Ogni colonna deve avere un tipo di dato. I tipi indicano: che valori sono ammessi come vengono memorizzati quali operazioni sono possibili I tipi di dato in DB-agnostic sono: INTEGER TEXT Di seguito una tabella riepilogativa dei principali tipi di dato, con la corrispondenza tra SQLite, MySQL e PostgreSQL e un\u2019indicazione della memoria occupata per campo. Tipo di dato SQLite MySQL PostgreSQL Memoria (indicativa) BOOLEAN INTEGER (0/1) BOOLEAN BOOLEAN 1 byte SMALLINT INTEGER SMALLINT SMALLINT 2 byte INTEGER INTEGER INT INTEGER 4 byte BIGINT INTEGER BIGINT BIGINT 8 byte DECIMAL/NUMERIC REAL / NUMERIC DECIMAL NUMERIC variabile REAL REAL FLOAT REAL 4 byte DOUBLE REAL DOUBLE DOUBLE PRECISION 8 byte CHAR TEXT CHAR CHAR fisso (n) VARCHAR TEXT VARCHAR VARCHAR variabile (n) TEXT TEXT TEXT TEXT variabile DATE TEXT / REAL DATE DATE 4 byte (PG), variabile TIME TEXT / REAL TIME TIME 8 byte (PG), variabile DATETIME TEXT / REAL DATETIME \u274c variabile TIMESTAMP TEXT / REAL TIMESTAMP TIMESTAMP 8 byte (PG), variabile BLOB/BINARY BLOB BLOB / BINARY BYTEA variabile JSON TEXT JSON JSON/JSONB variabile UUID TEXT \u274c UUID 16 byte CRUD \u00b6 Le operazioni fondamentali sui dati sono quattro: Operazione Significato SQL Create inserire dati INSERT Read leggere dati SELECT Update modificare dati UPDATE Delete cancellare dati DELETE Ogni sistema informativo, senza eccezioni, ruota attorno a queste operazioni. Query \u00b6 Una query \u00e8 una richiesta fatta al database. Caratteristiche: \u00e8 deterministica produce un risultato pu\u00f2 leggere o modificare dati La query pi\u00f9 comune \u00e8 SELECT . Esempi \u00b6 Usiamo SQLite (semplice e locale), ma cerchiamo di scrivere SQL standard e portabile quando possibile. Inserimento dei dati (INSERT) \u00b6 INSERT serve a creare nuove righe in una tabella. La forma pi\u00f9 comune \u00e8: INSERT INTO <table> (<colonne>) indica tabella e colonne da valorizzare VALUES (<valori>) indica i valori (nello stesso ordine delle colonne) Esempio: inseriamo un utente. INSERT INTO users (username, email) VALUES ('alice', 'alice@example.com'); Il database: assegna automaticamente la primary key (se id \u00e8 autoincrement) controlla i vincoli (es. NOT NULL , UNIQUE , CHECK ) controlla le foreign key (se abilitate/attive) Esempio: inseriamo un post collegato a un utente. INSERT INTO posts (user_id, title, content) VALUES (1, 'Primo post', 'Contenuto di esempio'); Se user_id = 1 non esiste nella tabella users \u2192 errore di integrit\u00e0 referenziale (vincolo FK). Inserire pi\u00f9 righe in una sola query \u00b6 \u00c8 pi\u00f9 efficiente e riduce il numero di query. INSERT INTO users (username, email, born_year, born_month, born_day) VALUES ('bob', 'bob@example.com', 1999, 10, 1), ('rob', 'rob@example.com', 1999, 1, 10), ('carlo', 'carlo@example.com', 2000, 7, 22), ('dina', 'dina@example.com', 1997, 11, 5), ('elena', 'elena@example.com', 2001, 1, 9), ('franco','franco@example.com',1995, 9, 30), ('giada', 'giada@example.com', 1996, 12, 14), ('luca', 'luca@example.com', 1999, 4, 2); Suggerimento: se stai inserendo dati \u201ccritici\u201d, considera l\u2019uso di transazioni ( BEGIN / COMMIT ) per rendere l\u2019operazione atomica. Lettura dei dati (SELECT) \u00b6 SELECT serve a leggere dati. Una query tipica \u00e8 composta da: SELECT <colonne> quali colonne vuoi vedere (oppure * per tutte) FROM <tabella> da dove leggere WHERE <condizioni> filtri (opzionale) ORDER BY <colonna> ASC|DESC ordinamento (opzionale) LIMIT <n> massimo numero di righe (opzionale) OFFSET <n> salta le prime n righe (opzionale, utile per paginazione) Nota: la sintassi corretta \u00e8 ORDER BY , non ORDERED BY . Selezionare tutte le righe \u00b6 SELECT * FROM users; Selezionare colonne specifiche e usare alias ( AS ) \u00b6 Mostriamo title e content rinominato come description : SELECT title, content AS description FROM posts; AS \u00e8 utile per rendere pi\u00f9 leggibile l\u2019output (o per nomi calcolati). Filtrare con WHERE (logica booleana) \u00b6 Esempio: tutti i post dell\u2019utente con user_id = 1 , ordinati alfabeticamente per titolo. SELECT title, content AS description FROM posts WHERE user_id = 1 ORDER BY title ASC; Operatori utili in WHERE : confronti: = , != (o <> ), < , <= , > , >= combinazioni: AND , OR , NOT insiemi: IN (...) pattern: LIKE con % (qualsiasi sequenza) e _ (un carattere) intervalli: BETWEEN ... AND ... valori mancanti: IS NULL / IS NOT NULL (attenzione: = NULL non funziona) Esempi rapidi: -- utenti nati dal 1999 in poi SELECT username, born_year FROM users WHERE born_year >= 1999; -- utenti con username in una lista SELECT id, username FROM users WHERE username IN ('alice', 'bob', 'luca'); -- utenti con email su un dominio SELECT id, email FROM users WHERE email LIKE '%@example.com'; -- utenti senza anno di nascita (se la colonna pu\u00f2 essere NULL) SELECT id, username FROM users WHERE born_year IS NULL; LIMIT e OFFSET (paginazione) \u00b6 Mostriamo 5 utenti per pagina, saltando i primi 10: SELECT id, username, email FROM users ORDER BY id ASC LIMIT 5 OFFSET 10; In paginazione, ORDER BY \u00e8 importante per avere risultati stabili e ripetibili. Modifica dei dati (UPDATE) \u00b6 UPDATE serve a modificare una o pi\u00f9 righe esistenti. Struttura: UPDATE <table> tabella da aggiornare SET <assegnazioni> colonne da cambiare ( colonna = valore ) WHERE <condizioni> quali righe aggiornare (quasi sempre necessario) Senza WHERE aggiorni tutte le righe della tabella: \u00e8 uno degli errori pi\u00f9 comuni e pericolosi. Aggiornare una singola riga \u00b6 Esempio: cambiamo l\u2019email dell\u2019utente con id = 1 . UPDATE users SET email = 'alice@newmail.com' WHERE id = 1; Aggiornare pi\u00f9 colonne nella stessa query \u00b6 UPDATE users SET username = 'alice_2', email = 'alice2@example.com' WHERE id = 1; Aggiornare pi\u00f9 righe (in modo controllato) \u00b6 Esempio: cambiamo il dominio email di tutti gli utenti che hanno @example.com . UPDATE users SET email = REPLACE(email, '@example.com', '@newdomain.com') WHERE email LIKE '%@example.com'; % indica \u201cqualsiasi sequenza di caratteri\u201d. Buone pratiche \u00b6 Prima di un UPDATE , esegui una SELECT con lo stesso WHERE per vedere quante righe verranno coinvolte: SELECT * FROM users WHERE id = 1; Usa WHERE specifici (PK, email univoche, combinazioni precise di condizioni). Se possibile, lavora in transazione quando aggiorni dati importanti (per poter annullare in caso di errore). Aggiorna solo i campi necessari. UPDATE modifica i dati: trattalo come un\u2019operazione potenzialmente irreversibile senza backup o transazioni. Cancellazione dei dati (DELETE) \u00b6 Il comando di cancellazione dei dati serve a rimuovere una o pi\u00f9 righe da una tabella. \u00c8 composto dalle seguenti parti: DELETE FROM <table> indica da quale tabella eliminare i record WHERE <filter conditions> specifica quali righe cancellare (quasi sempre necessario) Senza WHERE cancelli tutte le righe della tabella: \u00e8 un errore molto comune. Esempio: cancelliamo il post con id = 1 . DELETE FROM posts WHERE id = 1; Anche qui: senza WHERE \u2192 distruzione totale.","title":"Lezione 02 \u2014 Primo contatto con SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#lezione-02-primo-contatto-con-sql","text":"","title":"Lezione 02 \u2014 Primo contatto con SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#problema","text":"Abbiamo un modello concettuale ed abbiamo creato le tabelle utenti, posts e commenti. Ora dobbiamo trasformarlo in una struttura reale: inserire dati di esempio interrogare e modificare quei dati in modo controllato Obiettivo: passare da \u201cidea\u201d a \u201csistema interrogabile\u201d. Questo significa introdurre SQL come strumento operativo.","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#cose-sql","text":"SQL (Structured Query Language) \u00e8 il linguaggio standard usato per: definire la struttura del database inserire dati leggere dati modificarli cancellarli SQL non \u00e8 un linguaggio di programmazione generale , ma un linguaggio dichiarativo: dici cosa vuoi ottenere, non come ottenerlo.","title":"Cos\u2019\u00e8 SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#sql-linguaggio-dichiarativo","text":"SQL \u00e8 un linguaggio dichiarativo : quando scrivi una query descrivi il risultato che vuoi (quali righe/colonne), non i passaggi operativi per ottenerlo. Questo significa che: tu specifichi vincoli e condizioni ( WHERE , JOIN , GROUP BY , ORDER BY ) il database decide come eseguire la richiesta nel modo pi\u00f9 efficiente (piano di esecuzione: indici, ordine delle operazioni, strategie di join) In altre parole, non dici \u201cscorri tutte le righe una per una\u201d, ma \u201cdammi le righe che rispettano queste condizioni\u201d. Esempio (tu descrivi il risultato): SELECT id, username FROM users WHERE born_year >= 1999 ORDER BY username; Il DB stabilisce il \u201ccome\u201d (se usare un indice, in che ordine leggere i dati, ecc.).","title":"SQL: linguaggio dichiarativo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#famiglie-di-comandi-che-useremo","text":"Nelle lezioni useremo e nomineremo queste famiglie di comandi SQL (in base al DB, alcune classificazioni possono variare): DDL (Data Definition Language) : definisce o modifica la struttura del database (schema) Comandi tipici: CREATE , ALTER , DROP , TRUNCATE DML (Data Manipulation Language) : inserisce, aggiorna o elimina i dati Comandi tipici: INSERT , UPDATE , DELETE , MERGE (non sempre disponibile) DQL (Data Query Language) : interroga/legge i dati (spesso considerata parte della DML) Comandi tipici: SELECT (+ WHERE , JOIN , GROUP BY , HAVING , ORDER BY , LIMIT ) TCL (Transaction Control Language) : controlla le transazioni (atomicit\u00e0/rollback) Comandi tipici: BEGIN / START TRANSACTION , COMMIT , ROLLBACK , SAVEPOINT DCL (Data Control Language) : gestisce permessi e sicurezza (utenti/ruoli) Comandi tipici: GRANT , REVOKE Regola pratica: - DDL = struttura , - DQL/DML = dati , - TCL = coerenza delle operazioni , - DCL = accessi . In genere: prima si crea lo schema (DDL), poi si lavora/interroga sui dati (DQL/DML), eventualmente dentro transazioni (TCL).","title":"Famiglie di comandi che useremo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#il-concetto-di-schema","text":"Lo schema rappresenta la struttura del database: tabelle colonne tipi di dato vincoli relazioni \u00c8 il passaggio formale dal modello logico all\u2019 implementazione fisica .","title":"Il concetto di schema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#tipi-di-dato-db-agnostic","text":"Ogni colonna deve avere un tipo di dato. I tipi indicano: che valori sono ammessi come vengono memorizzati quali operazioni sono possibili I tipi di dato in DB-agnostic sono: INTEGER TEXT Di seguito una tabella riepilogativa dei principali tipi di dato, con la corrispondenza tra SQLite, MySQL e PostgreSQL e un\u2019indicazione della memoria occupata per campo. Tipo di dato SQLite MySQL PostgreSQL Memoria (indicativa) BOOLEAN INTEGER (0/1) BOOLEAN BOOLEAN 1 byte SMALLINT INTEGER SMALLINT SMALLINT 2 byte INTEGER INTEGER INT INTEGER 4 byte BIGINT INTEGER BIGINT BIGINT 8 byte DECIMAL/NUMERIC REAL / NUMERIC DECIMAL NUMERIC variabile REAL REAL FLOAT REAL 4 byte DOUBLE REAL DOUBLE DOUBLE PRECISION 8 byte CHAR TEXT CHAR CHAR fisso (n) VARCHAR TEXT VARCHAR VARCHAR variabile (n) TEXT TEXT TEXT TEXT variabile DATE TEXT / REAL DATE DATE 4 byte (PG), variabile TIME TEXT / REAL TIME TIME 8 byte (PG), variabile DATETIME TEXT / REAL DATETIME \u274c variabile TIMESTAMP TEXT / REAL TIMESTAMP TIMESTAMP 8 byte (PG), variabile BLOB/BINARY BLOB BLOB / BINARY BYTEA variabile JSON TEXT JSON JSON/JSONB variabile UUID TEXT \u274c UUID 16 byte","title":"Tipi di dato (DB-agnostic)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#crud","text":"Le operazioni fondamentali sui dati sono quattro: Operazione Significato SQL Create inserire dati INSERT Read leggere dati SELECT Update modificare dati UPDATE Delete cancellare dati DELETE Ogni sistema informativo, senza eccezioni, ruota attorno a queste operazioni.","title":"CRUD"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#query","text":"Una query \u00e8 una richiesta fatta al database. Caratteristiche: \u00e8 deterministica produce un risultato pu\u00f2 leggere o modificare dati La query pi\u00f9 comune \u00e8 SELECT .","title":"Query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#esempi","text":"Usiamo SQLite (semplice e locale), ma cerchiamo di scrivere SQL standard e portabile quando possibile.","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#inserimento-dei-dati-insert","text":"INSERT serve a creare nuove righe in una tabella. La forma pi\u00f9 comune \u00e8: INSERT INTO <table> (<colonne>) indica tabella e colonne da valorizzare VALUES (<valori>) indica i valori (nello stesso ordine delle colonne) Esempio: inseriamo un utente. INSERT INTO users (username, email) VALUES ('alice', 'alice@example.com'); Il database: assegna automaticamente la primary key (se id \u00e8 autoincrement) controlla i vincoli (es. NOT NULL , UNIQUE , CHECK ) controlla le foreign key (se abilitate/attive) Esempio: inseriamo un post collegato a un utente. INSERT INTO posts (user_id, title, content) VALUES (1, 'Primo post', 'Contenuto di esempio'); Se user_id = 1 non esiste nella tabella users \u2192 errore di integrit\u00e0 referenziale (vincolo FK).","title":"Inserimento dei dati (INSERT)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#inserire-piu-righe-in-una-sola-query","text":"\u00c8 pi\u00f9 efficiente e riduce il numero di query. INSERT INTO users (username, email, born_year, born_month, born_day) VALUES ('bob', 'bob@example.com', 1999, 10, 1), ('rob', 'rob@example.com', 1999, 1, 10), ('carlo', 'carlo@example.com', 2000, 7, 22), ('dina', 'dina@example.com', 1997, 11, 5), ('elena', 'elena@example.com', 2001, 1, 9), ('franco','franco@example.com',1995, 9, 30), ('giada', 'giada@example.com', 1996, 12, 14), ('luca', 'luca@example.com', 1999, 4, 2); Suggerimento: se stai inserendo dati \u201ccritici\u201d, considera l\u2019uso di transazioni ( BEGIN / COMMIT ) per rendere l\u2019operazione atomica.","title":"Inserire pi\u00f9 righe in una sola query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#lettura-dei-dati-select","text":"SELECT serve a leggere dati. Una query tipica \u00e8 composta da: SELECT <colonne> quali colonne vuoi vedere (oppure * per tutte) FROM <tabella> da dove leggere WHERE <condizioni> filtri (opzionale) ORDER BY <colonna> ASC|DESC ordinamento (opzionale) LIMIT <n> massimo numero di righe (opzionale) OFFSET <n> salta le prime n righe (opzionale, utile per paginazione) Nota: la sintassi corretta \u00e8 ORDER BY , non ORDERED BY .","title":"Lettura dei dati (SELECT)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#selezionare-tutte-le-righe","text":"SELECT * FROM users;","title":"Selezionare tutte le righe"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#selezionare-colonne-specifiche-e-usare-alias-as","text":"Mostriamo title e content rinominato come description : SELECT title, content AS description FROM posts; AS \u00e8 utile per rendere pi\u00f9 leggibile l\u2019output (o per nomi calcolati).","title":"Selezionare colonne specifiche e usare alias (AS)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#filtrare-con-where-logica-booleana","text":"Esempio: tutti i post dell\u2019utente con user_id = 1 , ordinati alfabeticamente per titolo. SELECT title, content AS description FROM posts WHERE user_id = 1 ORDER BY title ASC; Operatori utili in WHERE : confronti: = , != (o <> ), < , <= , > , >= combinazioni: AND , OR , NOT insiemi: IN (...) pattern: LIKE con % (qualsiasi sequenza) e _ (un carattere) intervalli: BETWEEN ... AND ... valori mancanti: IS NULL / IS NOT NULL (attenzione: = NULL non funziona) Esempi rapidi: -- utenti nati dal 1999 in poi SELECT username, born_year FROM users WHERE born_year >= 1999; -- utenti con username in una lista SELECT id, username FROM users WHERE username IN ('alice', 'bob', 'luca'); -- utenti con email su un dominio SELECT id, email FROM users WHERE email LIKE '%@example.com'; -- utenti senza anno di nascita (se la colonna pu\u00f2 essere NULL) SELECT id, username FROM users WHERE born_year IS NULL;","title":"Filtrare con WHERE (logica booleana)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#limit-e-offset-paginazione","text":"Mostriamo 5 utenti per pagina, saltando i primi 10: SELECT id, username, email FROM users ORDER BY id ASC LIMIT 5 OFFSET 10; In paginazione, ORDER BY \u00e8 importante per avere risultati stabili e ripetibili.","title":"LIMIT e OFFSET (paginazione)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#modifica-dei-dati-update","text":"UPDATE serve a modificare una o pi\u00f9 righe esistenti. Struttura: UPDATE <table> tabella da aggiornare SET <assegnazioni> colonne da cambiare ( colonna = valore ) WHERE <condizioni> quali righe aggiornare (quasi sempre necessario) Senza WHERE aggiorni tutte le righe della tabella: \u00e8 uno degli errori pi\u00f9 comuni e pericolosi.","title":"Modifica dei dati (UPDATE)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#aggiornare-una-singola-riga","text":"Esempio: cambiamo l\u2019email dell\u2019utente con id = 1 . UPDATE users SET email = 'alice@newmail.com' WHERE id = 1;","title":"Aggiornare una singola riga"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#aggiornare-piu-colonne-nella-stessa-query","text":"UPDATE users SET username = 'alice_2', email = 'alice2@example.com' WHERE id = 1;","title":"Aggiornare pi\u00f9 colonne nella stessa query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#aggiornare-piu-righe-in-modo-controllato","text":"Esempio: cambiamo il dominio email di tutti gli utenti che hanno @example.com . UPDATE users SET email = REPLACE(email, '@example.com', '@newdomain.com') WHERE email LIKE '%@example.com'; % indica \u201cqualsiasi sequenza di caratteri\u201d.","title":"Aggiornare pi\u00f9 righe (in modo controllato)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#buone-pratiche","text":"Prima di un UPDATE , esegui una SELECT con lo stesso WHERE per vedere quante righe verranno coinvolte: SELECT * FROM users WHERE id = 1; Usa WHERE specifici (PK, email univoche, combinazioni precise di condizioni). Se possibile, lavora in transazione quando aggiorni dati importanti (per poter annullare in caso di errore). Aggiorna solo i campi necessari. UPDATE modifica i dati: trattalo come un\u2019operazione potenzialmente irreversibile senza backup o transazioni.","title":"Buone pratiche"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#cancellazione-dei-dati-delete","text":"Il comando di cancellazione dei dati serve a rimuovere una o pi\u00f9 righe da una tabella. \u00c8 composto dalle seguenti parti: DELETE FROM <table> indica da quale tabella eliminare i record WHERE <filter conditions> specifica quali righe cancellare (quasi sempre necessario) Senza WHERE cancelli tutte le righe della tabella: \u00e8 un errore molto comune. Esempio: cancelliamo il post con id = 1 . DELETE FROM posts WHERE id = 1; Anche qui: senza WHERE \u2192 distruzione totale.","title":"Cancellazione dei dati (DELETE)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/","text":"Lezione 03 \u2014 Relazioni e JOIN \u00b6 Problema \u00b6 Nel progetto i dati sono distribuiti su pi\u00f9 tabelle: un post ha un autore (utente) un commento ha un autore e un post Se facciamo solo SELECT * FROM posts , otteniamo user_id , non il nome dell\u2019autore. Serve una query che combini tabelle in modo coerente. Obiettivo: leggere dati \u201crelazionali\u201d (post + autore, post + numero commenti, ecc.). Teoria \u00b6 JOIN: unire tabelle tramite chiavi \u00b6 Un JOIN combina righe di due (o pi\u00f9) tabelle usando una condizione (tipicamente FK \u2192 PK). Tipi principali: INNER JOIN : restituisce solo righe che matchano in entrambe le tabelle LEFT JOIN : restituisce tutte le righe della tabella a sinistra, anche se a destra non c\u2019\u00e8 match Regola mentale: INNER = \u201csolo ci\u00f2 che \u00e8 completo\u201d LEFT = \u201ctutto ci\u00f2 che \u00e8 a sinistra, con arricchimento quando possibile\u201d Alias e naming \u00b6 Usa alias ( users u ) per migliorare la leggibilit\u00e0 ed evitare ambiguit\u00e0 di nomi colonna. Esempi \u00b6 Mostrare i post insieme al nome dell\u2019autore (JOIN users ) \u00b6 Nella tabella posts abbiamo solo user_id (chiave esterna), quindi facciamo un JOIN verso users (chiave primaria users.id ) per \u201ctradurre\u201d l\u2019id in dati leggibili. SELECT p.id, -- id del post p.title, -- titolo del post u.username AS author -- username dell'autore (preso da users) FROM posts p JOIN users u ON u.id = p.user_id -- collega ogni post al suo autore ORDER BY p.id DESC; -- ordina dal post pi\u00f9 recente (id pi\u00f9 alto) Cosa succede: posts p : partiamo dalla tabella dei post (alias p ). JOIN users u ON u.id = p.user_id : per ogni riga di posts , cerchiamo l\u2019utente con users.id uguale al user_id del post. Essendo un INNER JOIN (scrivere solo JOIN equivale a INNER JOIN ), i post senza autore valido (user_id che non punta a un utente esistente) non compariranno . Commenti con autore e post \u00b6 Se si volesse mostrare ogni commento arricchito con: - autore del commento (da users ) - titolo del post a cui il commento appartiene (da posts ) SELECT c.id, -- id del commento c.content, -- testo del commento u.username AS author, -- autore del commento p.title AS post_title -- titolo del post commentato FROM comments c JOIN users u ON u.id = c.user_id -- collega commento -> autore JOIN posts p ON p.id = c.post_id -- collega commento -> post ORDER BY c.id DESC; -- dal commento pi\u00f9 recente Cosa succede: comments c : la tabella \u201ccentrale\u201d \u00e8 comments . Primo JOIN: c.user_id -> u.id per ottenere l\u2019autore. Secondo JOIN: c.post_id -> p.id per ottenere il post. Con INNER JOIN , verranno mostrati solo i commenti che: hanno un autore esistente e puntano a un post esistente Post anche senza commenti (LEFT JOIN) \u00b6 Adesso si vuole ottenere tutti i post e contare quanti commenti hanno, inclusi quelli con 0 commenti. Per includere anche i post senza match in comments , serve LEFT JOIN . SELECT p.id, -- id del post p.title, -- titolo del post COUNT(c.id) AS comment_count -- numero di commenti associati FROM posts p LEFT JOIN comments c ON c.post_id = p.id -- post -> commenti (se ci sono) GROUP BY p.id, p.title -- raggruppa per post per poter contare ORDER BY p.id DESC; Cosa succede: LEFT JOIN : mantiene tutte le righe di posts . Se un post non ha commenti, le colonne di comments risultano NULL . COUNT(c.id) : conta solo i valori non NULL . Quindi, se non ci sono commenti, c.id \u00e8 NULL e il conteggio diventa 0 . GROUP BY p.id, p.title : serve perch\u00e9 stiamo facendo un\u2019aggregazione ( COUNT ) e vogliamo un risultato \u201cper post\u201d. Nota: evitare COUNT(*) in questo caso \u00e8 una buona pratica perch\u00e9 con il LEFT JOIN conteresti comunque la riga del post anche quando non esistono commenti, ottenendo 1 invece di 0 . Nota: la parte GROUP BY la formalizziamo nella prossima lezione, ma qui serve gi\u00e0 per \u201ccontare\u201d. Esercizi \u00b6 Obiettivo \u00b6 Progettare e interrogare un database relazionale che permetta di gestire: studenti corsi (classi) iscrizioni degli studenti ai corsi Parte 1 \u2014 Creazione delle tabelle \u00b6 Crea una tabella students con i seguenti campi: \u00b6 id (chiave primaria, autoincrement) name (testo, obbligatorio) surname (testo, facoltativo) email (testo, obbligatorio) Crea una tabella classes con i seguenti campi: \u00b6 id (chiave primaria, autoincrement) name (testo, obbligatorio e univoco) hours (numero, obbligatorio) cfu (numero, facoltativo) Crea una tabella students_classes che rappresenti la relazione molti-a-molti tra studenti e corsi, contenente: \u00b6 id (chiave primaria) students_id (chiave esterna) classes_id (chiave esterna) Parte 2 \u2014 Inserimento dei dati \u00b6 Inserisci: almeno 7 studenti almeno 3 corsi associa gli studenti ai corsi tramite la tabella students_classes Parte 3 \u2014 Verifica \u00b6 Mostra il contenuto di tutte le tabelle tramite query SELECT . Parte 4 \u2014 Join tra tabelle \u00b6 Scrivi una query che mostri: nome dello studente cognome dello studente nome del corso a cui \u00e8 iscritto Soluzione \u00b6 Ecco la soluzione fornita: soluzione \u00b6","title":"Lezione 03 \u2014 Relazioni e JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#lezione-03-relazioni-e-join","text":"","title":"Lezione 03 \u2014 Relazioni e JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#problema","text":"Nel progetto i dati sono distribuiti su pi\u00f9 tabelle: un post ha un autore (utente) un commento ha un autore e un post Se facciamo solo SELECT * FROM posts , otteniamo user_id , non il nome dell\u2019autore. Serve una query che combini tabelle in modo coerente. Obiettivo: leggere dati \u201crelazionali\u201d (post + autore, post + numero commenti, ecc.).","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#join-unire-tabelle-tramite-chiavi","text":"Un JOIN combina righe di due (o pi\u00f9) tabelle usando una condizione (tipicamente FK \u2192 PK). Tipi principali: INNER JOIN : restituisce solo righe che matchano in entrambe le tabelle LEFT JOIN : restituisce tutte le righe della tabella a sinistra, anche se a destra non c\u2019\u00e8 match Regola mentale: INNER = \u201csolo ci\u00f2 che \u00e8 completo\u201d LEFT = \u201ctutto ci\u00f2 che \u00e8 a sinistra, con arricchimento quando possibile\u201d","title":"JOIN: unire tabelle tramite chiavi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#alias-e-naming","text":"Usa alias ( users u ) per migliorare la leggibilit\u00e0 ed evitare ambiguit\u00e0 di nomi colonna.","title":"Alias e naming"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#esempi","text":"","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#mostrare-i-post-insieme-al-nome-dellautore-join-users","text":"Nella tabella posts abbiamo solo user_id (chiave esterna), quindi facciamo un JOIN verso users (chiave primaria users.id ) per \u201ctradurre\u201d l\u2019id in dati leggibili. SELECT p.id, -- id del post p.title, -- titolo del post u.username AS author -- username dell'autore (preso da users) FROM posts p JOIN users u ON u.id = p.user_id -- collega ogni post al suo autore ORDER BY p.id DESC; -- ordina dal post pi\u00f9 recente (id pi\u00f9 alto) Cosa succede: posts p : partiamo dalla tabella dei post (alias p ). JOIN users u ON u.id = p.user_id : per ogni riga di posts , cerchiamo l\u2019utente con users.id uguale al user_id del post. Essendo un INNER JOIN (scrivere solo JOIN equivale a INNER JOIN ), i post senza autore valido (user_id che non punta a un utente esistente) non compariranno .","title":"Mostrare i post insieme al nome dell\u2019autore (JOIN users)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#commenti-con-autore-e-post","text":"Se si volesse mostrare ogni commento arricchito con: - autore del commento (da users ) - titolo del post a cui il commento appartiene (da posts ) SELECT c.id, -- id del commento c.content, -- testo del commento u.username AS author, -- autore del commento p.title AS post_title -- titolo del post commentato FROM comments c JOIN users u ON u.id = c.user_id -- collega commento -> autore JOIN posts p ON p.id = c.post_id -- collega commento -> post ORDER BY c.id DESC; -- dal commento pi\u00f9 recente Cosa succede: comments c : la tabella \u201ccentrale\u201d \u00e8 comments . Primo JOIN: c.user_id -> u.id per ottenere l\u2019autore. Secondo JOIN: c.post_id -> p.id per ottenere il post. Con INNER JOIN , verranno mostrati solo i commenti che: hanno un autore esistente e puntano a un post esistente","title":"Commenti con autore e post"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#post-anche-senza-commenti-left-join","text":"Adesso si vuole ottenere tutti i post e contare quanti commenti hanno, inclusi quelli con 0 commenti. Per includere anche i post senza match in comments , serve LEFT JOIN . SELECT p.id, -- id del post p.title, -- titolo del post COUNT(c.id) AS comment_count -- numero di commenti associati FROM posts p LEFT JOIN comments c ON c.post_id = p.id -- post -> commenti (se ci sono) GROUP BY p.id, p.title -- raggruppa per post per poter contare ORDER BY p.id DESC; Cosa succede: LEFT JOIN : mantiene tutte le righe di posts . Se un post non ha commenti, le colonne di comments risultano NULL . COUNT(c.id) : conta solo i valori non NULL . Quindi, se non ci sono commenti, c.id \u00e8 NULL e il conteggio diventa 0 . GROUP BY p.id, p.title : serve perch\u00e9 stiamo facendo un\u2019aggregazione ( COUNT ) e vogliamo un risultato \u201cper post\u201d. Nota: evitare COUNT(*) in questo caso \u00e8 una buona pratica perch\u00e9 con il LEFT JOIN conteresti comunque la riga del post anche quando non esistono commenti, ottenendo 1 invece di 0 . Nota: la parte GROUP BY la formalizziamo nella prossima lezione, ma qui serve gi\u00e0 per \u201ccontare\u201d.","title":"Post anche senza commenti (LEFT JOIN)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#esercizi","text":"","title":"Esercizi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#obiettivo","text":"Progettare e interrogare un database relazionale che permetta di gestire: studenti corsi (classi) iscrizioni degli studenti ai corsi","title":"Obiettivo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-1-creazione-delle-tabelle","text":"","title":"Parte 1 \u2014 Creazione delle tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#crea-una-tabella-students-con-i-seguenti-campi","text":"id (chiave primaria, autoincrement) name (testo, obbligatorio) surname (testo, facoltativo) email (testo, obbligatorio)","title":"Crea una tabella students con i seguenti campi:"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#crea-una-tabella-classes-con-i-seguenti-campi","text":"id (chiave primaria, autoincrement) name (testo, obbligatorio e univoco) hours (numero, obbligatorio) cfu (numero, facoltativo)","title":"Crea una tabella classes con i seguenti campi:"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#crea-una-tabella-students_classes-che-rappresenti-la-relazione-molti-a-molti-tra-studenti-e-corsi-contenente","text":"id (chiave primaria) students_id (chiave esterna) classes_id (chiave esterna)","title":"Crea una tabella students_classes che rappresenti la relazione molti-a-molti tra studenti e corsi, contenente:"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-2-inserimento-dei-dati","text":"Inserisci: almeno 7 studenti almeno 3 corsi associa gli studenti ai corsi tramite la tabella students_classes","title":"Parte 2 \u2014 Inserimento dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-3-verifica","text":"Mostra il contenuto di tutte le tabelle tramite query SELECT .","title":"Parte 3 \u2014 Verifica"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-4-join-tra-tabelle","text":"Scrivi una query che mostri: nome dello studente cognome dello studente nome del corso a cui \u00e8 iscritto","title":"Parte 4 \u2014 Join tra tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#soluzione","text":"","title":"Soluzione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#ecco-la-soluzione-fornita-soluzione","text":"","title":"Ecco la soluzione fornita: soluzione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/","text":"Esercizio 3.1 \u2014 Spiegazione \u00b6 In questo esercizio abbiamo costruito un database relazionale completo , applicando i concetti fondamentali di SQL visti a lezione. 1 Creazione delle tabelle \u00b6 Tabella students \u00b6 Rappresenta gli studenti. id \u00e8 la chiave primaria ed \u00e8 autoincrementale name ed email sono obbligatori surname pu\u00f2 essere vuoto Questo garantisce che ogni studente sia identificabile in modo univoco. Tabella classes \u00b6 Rappresenta i corsi. name \u00e8 UNIQUE , quindi non possono esistere due corsi con lo stesso nome hours indica il numero di ore del corso cfu \u00e8 facoltativo Tabella students_classes \u00b6 Serve a modellare una relazione molti-a-molti : uno studente pu\u00f2 seguire pi\u00f9 corsi un corso pu\u00f2 avere pi\u00f9 studenti Questa tabella contiene: due chiavi esterne nessun dato descrittivo, solo relazioni 2 Inserimento dei dati \u00b6 Abbiamo usato INSERT INTO ... VALUES per: popolare la tabella students popolare la tabella classes creare le iscrizioni nella tabella students_classes Ogni riga in students_classes rappresenta un\u2019iscrizione di uno studente a un corso . 3 Visualizzazione delle tabelle \u00b6 Per verificare i dati abbiamo usato: SELECT * FROM students; SELECT * FROM classes; SELECT * FROM students_classes; Questo passaggio \u00e8 fondamentale per: controllare errori verificare le relazioni capire se il modello funziona correttamente 4 Join tra tabelle \u00b6 Per ottenere informazioni \u201cleggibili\u201d (cio\u00e8 nomi di studenti e corsi) dobbiamo unire pi\u00f9 tabelle, perch\u00e9 nella tabella ponte students_classes ci sono solo gli ID (le chiavi esterne), non i dati descrittivi. Perch\u00e9 serve il JOIN \u00b6 students_classes contiene la relazione: quale studente \u00e8 iscritto a quale corso students contiene i dati dello studente ( name , surname , email , \u2026) classes contiene i dati del corso ( name , hours , cfu , \u2026) Il JOIN permette di \u201cseguire\u201d le chiavi esterne e ricostruire una vista completa. Query base (INNER JOIN) \u00b6 SELECT students.name AS nome, students.surname AS cognome, classes.name AS nome_classe FROM students_classes JOIN students ON students_classes.students_id = students.id JOIN classes ON students_classes.classes_id = classes.id; Cosa fa: - parte da students_classes (la tabella che \u201ccollega\u201d) - collega students_classes.students_id con students.id - collega students_classes.classes_id con classes.id - restituisce una riga per ogni iscrizione Nota: JOIN senza specifica \u00e8 equivalente a INNER JOIN . Quindi: - mostra solo le righe in cui esiste corrispondenza in tutte le tabelle coinvolte Variante 1: usare alias (pi\u00f9 leggibile) \u00b6 SELECT s.name AS nome, s.surname AS cognome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id; Variante 2: ordinare i risultati \u00b6 SELECT s.surname AS cognome, s.name AS nome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id ORDER BY c.name, s.surname, s.name; Variante 3: filtrare (es. iscrizioni a un corso specifico) \u00b6 SELECT s.name AS nome, s.surname AS cognome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id WHERE c.name = 'Database SQL'; Variante 4: includere anche gli ID (utile per debug/verifica) \u00b6 SELECT sc.students_id, sc.classes_id, s.name AS nome, s.surname AS cognome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id; Variante 5: vedere tutti i corsi anche se non hanno studenti (LEFT JOIN) \u00b6 Se vuoi mostrare tutti i corsi , anche quelli senza iscrizioni: SELECT c.name AS nome_classe, s.name AS nome, s.surname AS cognome FROM classes c LEFT JOIN students_classes sc ON sc.classes_id = c.id LEFT JOIN students s ON sc.students_id = s.id ORDER BY c.name; Qui: - ogni corso appare comunque - per i corsi senza iscritti, i campi dello studente risultano NULL Variante 6: contare quanti studenti ci sono per corso (aggregazione) \u00b6 SELECT c.name AS nome_classe, COUNT(sc.students_id) AS numero_studenti FROM classes c LEFT JOIN students_classes sc ON sc.classes_id = c.id GROUP BY c.id, c.name ORDER BY numero_studenti DESC, c.name; Questa variante \u00e8 utile per fare report e statistiche sulle iscrizioni.","title":"Esercizio 03-01"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#esercizio-31-spiegazione","text":"In questo esercizio abbiamo costruito un database relazionale completo , applicando i concetti fondamentali di SQL visti a lezione.","title":"Esercizio 3.1 \u2014 Spiegazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#1-creazione-delle-tabelle","text":"","title":"1 Creazione delle tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#tabella-students","text":"Rappresenta gli studenti. id \u00e8 la chiave primaria ed \u00e8 autoincrementale name ed email sono obbligatori surname pu\u00f2 essere vuoto Questo garantisce che ogni studente sia identificabile in modo univoco.","title":"Tabella students"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#tabella-classes","text":"Rappresenta i corsi. name \u00e8 UNIQUE , quindi non possono esistere due corsi con lo stesso nome hours indica il numero di ore del corso cfu \u00e8 facoltativo","title":"Tabella classes"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#tabella-students_classes","text":"Serve a modellare una relazione molti-a-molti : uno studente pu\u00f2 seguire pi\u00f9 corsi un corso pu\u00f2 avere pi\u00f9 studenti Questa tabella contiene: due chiavi esterne nessun dato descrittivo, solo relazioni","title":"Tabella students_classes"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#2-inserimento-dei-dati","text":"Abbiamo usato INSERT INTO ... VALUES per: popolare la tabella students popolare la tabella classes creare le iscrizioni nella tabella students_classes Ogni riga in students_classes rappresenta un\u2019iscrizione di uno studente a un corso .","title":"2 Inserimento dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#3-visualizzazione-delle-tabelle","text":"Per verificare i dati abbiamo usato: SELECT * FROM students; SELECT * FROM classes; SELECT * FROM students_classes; Questo passaggio \u00e8 fondamentale per: controllare errori verificare le relazioni capire se il modello funziona correttamente","title":"3 Visualizzazione delle tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#4-join-tra-tabelle","text":"Per ottenere informazioni \u201cleggibili\u201d (cio\u00e8 nomi di studenti e corsi) dobbiamo unire pi\u00f9 tabelle, perch\u00e9 nella tabella ponte students_classes ci sono solo gli ID (le chiavi esterne), non i dati descrittivi.","title":"4 Join tra tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#perche-serve-il-join","text":"students_classes contiene la relazione: quale studente \u00e8 iscritto a quale corso students contiene i dati dello studente ( name , surname , email , \u2026) classes contiene i dati del corso ( name , hours , cfu , \u2026) Il JOIN permette di \u201cseguire\u201d le chiavi esterne e ricostruire una vista completa.","title":"Perch\u00e9 serve il JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#query-base-inner-join","text":"SELECT students.name AS nome, students.surname AS cognome, classes.name AS nome_classe FROM students_classes JOIN students ON students_classes.students_id = students.id JOIN classes ON students_classes.classes_id = classes.id; Cosa fa: - parte da students_classes (la tabella che \u201ccollega\u201d) - collega students_classes.students_id con students.id - collega students_classes.classes_id con classes.id - restituisce una riga per ogni iscrizione Nota: JOIN senza specifica \u00e8 equivalente a INNER JOIN . Quindi: - mostra solo le righe in cui esiste corrispondenza in tutte le tabelle coinvolte","title":"Query base (INNER JOIN)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#variante-1-usare-alias-piu-leggibile","text":"SELECT s.name AS nome, s.surname AS cognome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id;","title":"Variante 1: usare alias (pi\u00f9 leggibile)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#variante-2-ordinare-i-risultati","text":"SELECT s.surname AS cognome, s.name AS nome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id ORDER BY c.name, s.surname, s.name;","title":"Variante 2: ordinare i risultati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#variante-3-filtrare-es-iscrizioni-a-un-corso-specifico","text":"SELECT s.name AS nome, s.surname AS cognome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id WHERE c.name = 'Database SQL';","title":"Variante 3: filtrare (es. iscrizioni a un corso specifico)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#variante-4-includere-anche-gli-id-utile-per-debugverifica","text":"SELECT sc.students_id, sc.classes_id, s.name AS nome, s.surname AS cognome, c.name AS nome_classe FROM students_classes sc JOIN students s ON sc.students_id = s.id JOIN classes c ON sc.classes_id = c.id;","title":"Variante 4: includere anche gli ID (utile per debug/verifica)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#variante-5-vedere-tutti-i-corsi-anche-se-non-hanno-studenti-left-join","text":"Se vuoi mostrare tutti i corsi , anche quelli senza iscrizioni: SELECT c.name AS nome_classe, s.name AS nome, s.surname AS cognome FROM classes c LEFT JOIN students_classes sc ON sc.classes_id = c.id LEFT JOIN students s ON sc.students_id = s.id ORDER BY c.name; Qui: - ogni corso appare comunque - per i corsi senza iscritti, i campi dello studente risultano NULL","title":"Variante 5: vedere tutti i corsi anche se non hanno studenti (LEFT JOIN)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/soluzioni/esercizio-03-01/#variante-6-contare-quanti-studenti-ci-sono-per-corso-aggregazione","text":"SELECT c.name AS nome_classe, COUNT(sc.students_id) AS numero_studenti FROM classes c LEFT JOIN students_classes sc ON sc.classes_id = c.id GROUP BY c.id, c.name ORDER BY numero_studenti DESC, c.name; Questa variante \u00e8 utile per fare report e statistiche sulle iscrizioni.","title":"Variante 6: contare quanti studenti ci sono per corso (aggregazione)"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/","text":"Modulo 02 \u2014 Query SQL \u00b6 Questo modulo introduce le query SQL come strumento per leggere e analizzare i dati del progetto. Non si tratta solo di \u201cscrivere SELECT\u201d, ma di ragionare sui dati : aggregazioni, raggruppamenti e filtri sul risultato. Il focus \u00e8 trasformare dati grezzi in informazioni utili. Perch\u00e9 questo modulo \u00e8 fondamentale \u00b6 Senza saper fare query efficaci: i dati restano \u201cinermi\u201d non puoi misurare attivit\u00e0 o risultati non riesci a verificare le ipotesi del progetto Questo modulo costruisce le basi per: report e statistiche analisi del comportamento utenti verifiche di consistenza Obiettivi di apprendimento \u00b6 Al termine di questo modulo lo studente sapr\u00e0: usare funzioni di aggregazione ( COUNT , SUM , AVG , MIN , MAX ) raggruppare dati con GROUP BY filtrare gruppi con HAVING ordinare risultati in modo corretto e leggibile Collegamento con il progetto \u00b6 In questo modulo: iniziamo a misurare il progetto (conteggi, statistiche, classifiche) trasformiamo le tabelle in informazioni utili introduciamo query leggibili e riutilizzabili Contenuti del modulo \u00b6 Lezione 04 \u2014 Aggregazioni, GROUP BY e HAVING \u00b6 Problema \u2014 Rispondere a domande reali (conteggi, top utenti, post pi\u00f9 attivi). Teoria \u2014 Funzioni di aggregazione; regole di GROUP BY ; differenza tra WHERE e HAVING . Esempi pratici \u2014 Commenti per post; post con almeno N commenti; utenti pi\u00f9 attivi. \ud83d\udc49 Vai alla lezione Output del modulo \u00b6 Alla fine del modulo esistono: query di aggregazione corrette raggruppamenti coerenti con il modello filtri post-aggregazione ben definiti risultati ordinati e pronti per report Errori comuni da evitare \u00b6 usare COUNT(*) in presenza di LEFT JOIN quando serve COUNT(colonna) dimenticare colonne nel GROUP BY usare WHERE su aggregati invece di HAVING ordinare per posizione (es. ORDER BY 2 ) invece che per alias Navigazione \u00b6 Lezione 04 Moduli","title":"Indice"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#modulo-02-query-sql","text":"Questo modulo introduce le query SQL come strumento per leggere e analizzare i dati del progetto. Non si tratta solo di \u201cscrivere SELECT\u201d, ma di ragionare sui dati : aggregazioni, raggruppamenti e filtri sul risultato. Il focus \u00e8 trasformare dati grezzi in informazioni utili.","title":"Modulo 02 \u2014 Query SQL"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#perche-questo-modulo-e-fondamentale","text":"Senza saper fare query efficaci: i dati restano \u201cinermi\u201d non puoi misurare attivit\u00e0 o risultati non riesci a verificare le ipotesi del progetto Questo modulo costruisce le basi per: report e statistiche analisi del comportamento utenti verifiche di consistenza","title":"Perch\u00e9 questo modulo \u00e8 fondamentale"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#obiettivi-di-apprendimento","text":"Al termine di questo modulo lo studente sapr\u00e0: usare funzioni di aggregazione ( COUNT , SUM , AVG , MIN , MAX ) raggruppare dati con GROUP BY filtrare gruppi con HAVING ordinare risultati in modo corretto e leggibile","title":"Obiettivi di apprendimento"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#collegamento-con-il-progetto","text":"In questo modulo: iniziamo a misurare il progetto (conteggi, statistiche, classifiche) trasformiamo le tabelle in informazioni utili introduciamo query leggibili e riutilizzabili","title":"Collegamento con il progetto"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#contenuti-del-modulo","text":"","title":"Contenuti del modulo"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#lezione-04-aggregazioni-group-by-e-having","text":"Problema \u2014 Rispondere a domande reali (conteggi, top utenti, post pi\u00f9 attivi). Teoria \u2014 Funzioni di aggregazione; regole di GROUP BY ; differenza tra WHERE e HAVING . Esempi pratici \u2014 Commenti per post; post con almeno N commenti; utenti pi\u00f9 attivi. \ud83d\udc49 Vai alla lezione","title":"Lezione 04 \u2014 Aggregazioni, GROUP BY e HAVING"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#output-del-modulo","text":"Alla fine del modulo esistono: query di aggregazione corrette raggruppamenti coerenti con il modello filtri post-aggregazione ben definiti risultati ordinati e pronti per report","title":"Output del modulo"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#errori-comuni-da-evitare","text":"usare COUNT(*) in presenza di LEFT JOIN quando serve COUNT(colonna) dimenticare colonne nel GROUP BY usare WHERE su aggregati invece di HAVING ordinare per posizione (es. ORDER BY 2 ) invece che per alias","title":"Errori comuni da evitare"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/#navigazione","text":"Lezione 04 Moduli","title":"Navigazione"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/","text":"Lezione 04 \u2014 Aggregazioni, GROUP BY e HAVING \u00b6 Problema \u00b6 Nel progetto vogliamo rispondere a domande reali: quanti commenti ha ogni post? quali utenti sono pi\u00f9 attivi? quali post hanno almeno N commenti? Per rispondere a queste domande usiamo tre \u201cmattoni\u201d SQL: Funzioni di aggregazione ( COUNT , SUM , AVG , \u2026): calcolano un valore riassuntivo su pi\u00f9 righe (es. numero di commenti, media voti). GROUP BY : divide le righe in gruppi (es. per post_id o user_id ) cos\u00ec l\u2019aggregazione viene calcolata per ogni gruppo , non sull\u2019intera tabella. HAVING : filtra i gruppi dopo l\u2019aggregazione (es. tieni solo i post con COUNT(comments.id) >= N ). Teoria \u00b6 Funzioni di aggregazione \u00b6 Le funzioni di aggregazione \u201criassumono\u201d un insieme di righe in un singolo valore (di solito per calcolare conteggi, somme o medie). Aggregazioni pi\u00f9 comuni: COUNT() \u2192 conteggio MIN() \u2192 valore minimo MAX() \u2192 valore massimo SUM() \u2192 somma AVG() \u2192 media Differenza importante tra COUNT(*) e COUNT(colonna) COUNT(*) conta tutte le righe prodotte dalla FROM (anche se alcune colonne sono NULL ). COUNT(colonna) conta solo le righe in cui quella colonna non \u00e8 NULL . Questo \u00e8 cruciale con le LEFT JOIN : se un post non ha commenti, le colonne di comments risultano NULL quindi COUNT(*) conterebbe comunque 1 riga (quella del post \u201csenza match\u201d) mentre COUNT(c.id) resterebbe 0 (perch\u00e9 c.id \u00e8 NULL ) Regola pratica: con LEFT JOIN , per contare \u201cquanti elementi collegati esistono davvero\u201d, usa spesso COUNT(tabella.id) . GROUP BY \u00b6 GROUP BY serve a raggruppare le righe in \u201cblocchi\u201d che condividono gli stessi valori, cos\u00ec da calcolare un\u2019aggregazione per gruppo . Esempio mentale: senza GROUP BY \u2192 ottieni un solo risultato aggregato sull\u2019intera tabella con GROUP BY post_id \u2192 ottieni un risultato per ogni post_id Regola fondamentale In una query con GROUP BY , ogni colonna nel SELECT deve essere: dentro una funzione di aggregazione ( COUNT , SUM , AVG , \u2026) oppure elencata nel GROUP BY Esempio valido: SELECT c.post_id, COUNT(*) AS comment_count FROM comments c GROUP BY c.post_id; Esempio NON valido (perch\u00e9 title non \u00e8 aggregata e non \u00e8 nel GROUP BY ): SELECT p.id, p.title, COUNT(c.id) FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id; Corretto: SELECT p.id, p.title, COUNT(c.id) FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id, p.title; Definisce \u201ccome raggruppare\u201d prima dell\u2019aggregazione. Regola: ogni colonna selezionata deve essere: - in una funzione di aggregazione oppure - presente nel GROUP BY HAVING \u00b6 WHERE filtra righe prima del grouping HAVING filtra gruppi dopo il grouping ORDER BY e alias \u00b6 Si pu\u00f2 ordinare per: - colonna - alias (es. comment_count ) Meglio ordinare per alias, non per posizione. Esempi \u00b6 Commenti per post \u00b6 SELECT c.post_id, COUNT(*) AS comment_count FROM comments c GROUP BY c.post_id ORDER BY comment_count DESC; Post con titolo + conteggio commenti (LEFT JOIN) \u00b6 SELECT p.id, p.title, COUNT(c.id) AS comment_count FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id, p.title ORDER BY comment_count DESC, p.id DESC; Post con almeno 3 commenti (HAVING) \u00b6 SELECT p.id, p.title, COUNT(c.id) AS comment_count FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id, p.title HAVING COUNT(c.id) >= 3 ORDER BY comment_count DESC; Utenti pi\u00f9 attivi (numero post) \u00b6 SELECT u.id, u.username, COUNT(p.id) AS post_count FROM users u LEFT JOIN posts p ON p.user_id = u.id GROUP BY u.id, u.username ORDER BY post_count DESC, u.id ASC;","title":"Lezione 04 \u2014 Aggregazioni e GROUP BY"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#lezione-04-aggregazioni-group-by-e-having","text":"","title":"Lezione 04 \u2014 Aggregazioni, GROUP BY e HAVING"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#problema","text":"Nel progetto vogliamo rispondere a domande reali: quanti commenti ha ogni post? quali utenti sono pi\u00f9 attivi? quali post hanno almeno N commenti? Per rispondere a queste domande usiamo tre \u201cmattoni\u201d SQL: Funzioni di aggregazione ( COUNT , SUM , AVG , \u2026): calcolano un valore riassuntivo su pi\u00f9 righe (es. numero di commenti, media voti). GROUP BY : divide le righe in gruppi (es. per post_id o user_id ) cos\u00ec l\u2019aggregazione viene calcolata per ogni gruppo , non sull\u2019intera tabella. HAVING : filtra i gruppi dopo l\u2019aggregazione (es. tieni solo i post con COUNT(comments.id) >= N ).","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#funzioni-di-aggregazione","text":"Le funzioni di aggregazione \u201criassumono\u201d un insieme di righe in un singolo valore (di solito per calcolare conteggi, somme o medie). Aggregazioni pi\u00f9 comuni: COUNT() \u2192 conteggio MIN() \u2192 valore minimo MAX() \u2192 valore massimo SUM() \u2192 somma AVG() \u2192 media Differenza importante tra COUNT(*) e COUNT(colonna) COUNT(*) conta tutte le righe prodotte dalla FROM (anche se alcune colonne sono NULL ). COUNT(colonna) conta solo le righe in cui quella colonna non \u00e8 NULL . Questo \u00e8 cruciale con le LEFT JOIN : se un post non ha commenti, le colonne di comments risultano NULL quindi COUNT(*) conterebbe comunque 1 riga (quella del post \u201csenza match\u201d) mentre COUNT(c.id) resterebbe 0 (perch\u00e9 c.id \u00e8 NULL ) Regola pratica: con LEFT JOIN , per contare \u201cquanti elementi collegati esistono davvero\u201d, usa spesso COUNT(tabella.id) .","title":"Funzioni di aggregazione"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#group-by","text":"GROUP BY serve a raggruppare le righe in \u201cblocchi\u201d che condividono gli stessi valori, cos\u00ec da calcolare un\u2019aggregazione per gruppo . Esempio mentale: senza GROUP BY \u2192 ottieni un solo risultato aggregato sull\u2019intera tabella con GROUP BY post_id \u2192 ottieni un risultato per ogni post_id Regola fondamentale In una query con GROUP BY , ogni colonna nel SELECT deve essere: dentro una funzione di aggregazione ( COUNT , SUM , AVG , \u2026) oppure elencata nel GROUP BY Esempio valido: SELECT c.post_id, COUNT(*) AS comment_count FROM comments c GROUP BY c.post_id; Esempio NON valido (perch\u00e9 title non \u00e8 aggregata e non \u00e8 nel GROUP BY ): SELECT p.id, p.title, COUNT(c.id) FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id; Corretto: SELECT p.id, p.title, COUNT(c.id) FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id, p.title; Definisce \u201ccome raggruppare\u201d prima dell\u2019aggregazione. Regola: ogni colonna selezionata deve essere: - in una funzione di aggregazione oppure - presente nel GROUP BY","title":"GROUP BY"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#having","text":"WHERE filtra righe prima del grouping HAVING filtra gruppi dopo il grouping","title":"HAVING"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#order-by-e-alias","text":"Si pu\u00f2 ordinare per: - colonna - alias (es. comment_count ) Meglio ordinare per alias, non per posizione.","title":"ORDER BY e alias"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#esempi","text":"","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#commenti-per-post","text":"SELECT c.post_id, COUNT(*) AS comment_count FROM comments c GROUP BY c.post_id ORDER BY comment_count DESC;","title":"Commenti per post"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#post-con-titolo-conteggio-commenti-left-join","text":"SELECT p.id, p.title, COUNT(c.id) AS comment_count FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id, p.title ORDER BY comment_count DESC, p.id DESC;","title":"Post con titolo + conteggio commenti (LEFT JOIN)"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#post-con-almeno-3-commenti-having","text":"SELECT p.id, p.title, COUNT(c.id) AS comment_count FROM posts p LEFT JOIN comments c ON c.post_id = p.id GROUP BY p.id, p.title HAVING COUNT(c.id) >= 3 ORDER BY comment_count DESC;","title":"Post con almeno 3 commenti (HAVING)"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-04/#utenti-piu-attivi-numero-post","text":"SELECT u.id, u.username, COUNT(p.id) AS post_count FROM users u LEFT JOIN posts p ON p.user_id = u.id GROUP BY u.id, u.username ORDER BY post_count DESC, u.id ASC;","title":"Utenti pi\u00f9 attivi (numero post)"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-05/","text":"","title":"Lezione 05 \u2014 VIEW e query riutilizzabili"},{"location":"corsi/corso-database-sql/moduli/02-query-sql/lezione-06/","text":"","title":"Lezione 06 \u2014 UPSERT e gestione conflitti"},{"location":"corsi/corso-database-sql/moduli/03-schema-performance/","text":"","title":"Indice"},{"location":"corsi/corso-database-sql/moduli/03-schema-performance/lezione-07/","text":"","title":"Lezione 07 \u2014 Indici ed EXPLAIN"},{"location":"corsi/corso-database-sql/moduli/03-schema-performance/lezione-08/","text":"","title":"Lezione 08 \u2014 Vincoli, soft delete e migrazioni"},{"location":"corsi/corso-database-sql/moduli/04-migrazione-produzione/","text":"","title":"Indice"},{"location":"corsi/corso-database-sql/moduli/04-migrazione-produzione/lezione-09/","text":"","title":"Lezione 09 \u2014 Transazioni e consistenza"},{"location":"corsi/corso-database-sql/moduli/04-migrazione-produzione/lezione-10/","text":"","title":"Lezione 10 \u2014 Da SQLite a MySQL"},{"location":"corsi/corso-database-sql/progetto/","text":"Progetto del corso \u00b6 Tutto il corso di Database SQL \u00e8 costruito attorno a un unico progetto reale , che evolve progressivamente modulo dopo modulo. L\u2019obiettivo non \u00e8 imparare SQL a memoria , ma capire perch\u00e9 e quando usare gli strumenti che SQL mette a disposizione. Obiettivo del progetto \u00b6 Progettare e sviluppare un sistema di gestione dati per una piattaforma con: utenti contenuti creati dagli utenti relazioni tra contenuti possibilit\u00e0 di estensione futura Il progetto deve essere: - coerente - scalabile - modellato correttamente - indipendente dal database specifico (DB-agnostic) Metodo di lavoro \u00b6 Ogni modulo del corso: 1. introduce un problema reale 2. fornisce gli strumenti teorici necessari 3. applica tali strumenti al progetto 4. estende progressivamente il modello dati Il progetto non viene mai azzerato : cresce con il corso. Navigazione \u00b6 Problema iniziale Requisiti Modello dati","title":"Introduzione"},{"location":"corsi/corso-database-sql/progetto/#progetto-del-corso","text":"Tutto il corso di Database SQL \u00e8 costruito attorno a un unico progetto reale , che evolve progressivamente modulo dopo modulo. L\u2019obiettivo non \u00e8 imparare SQL a memoria , ma capire perch\u00e9 e quando usare gli strumenti che SQL mette a disposizione.","title":"Progetto del corso"},{"location":"corsi/corso-database-sql/progetto/#obiettivo-del-progetto","text":"Progettare e sviluppare un sistema di gestione dati per una piattaforma con: utenti contenuti creati dagli utenti relazioni tra contenuti possibilit\u00e0 di estensione futura Il progetto deve essere: - coerente - scalabile - modellato correttamente - indipendente dal database specifico (DB-agnostic)","title":"Obiettivo del progetto"},{"location":"corsi/corso-database-sql/progetto/#metodo-di-lavoro","text":"Ogni modulo del corso: 1. introduce un problema reale 2. fornisce gli strumenti teorici necessari 3. applica tali strumenti al progetto 4. estende progressivamente il modello dati Il progetto non viene mai azzerato : cresce con il corso.","title":"Metodo di lavoro"},{"location":"corsi/corso-database-sql/progetto/#navigazione","text":"Problema iniziale Requisiti Modello dati","title":"Navigazione"},{"location":"corsi/corso-database-sql/progetto/modello-dati/","text":"Modello dei dati \u00b6 Questa sezione introduce il modello dei dati iniziale , che verr\u00e0 esteso progressivamente durante il corso. Il modello non \u00e8 definitivo : evolve insieme alle competenze acquisite. Entit\u00e0 principali \u00b6 In base al problema e ai requisiti individuiamo le seguenti entit\u00e0 fondamentali. Utente ( users ) \u00b6 Rappresenta una persona che utilizza la piattaforma. Attributi principali: identificatore univoco username email born_year born_month born_day Contenuto ( posts ) \u00b6 Rappresenta un contenuto creato da un utente. Attributi principali: identificatore univoco autore titolo testo Relazione: ogni contenuto appartiene a un solo utente un utente pu\u00f2 creare pi\u00f9 contenuti Commento ( comments ) \u00b6 Rappresenta un\u2019interazione su un contenuto. Attributi principali: identificatore univoco autore contenuto testuale Relazioni: ogni commento \u00e8 associato a un utente ogni commento \u00e8 associato a un contenuto Categoria ( categories ) \u00b6 Serve per classificare i contenuti. Relazione: un contenuto pu\u00f2 appartenere a pi\u00f9 categorie una categoria pu\u00f2 essere associata a pi\u00f9 contenuti Questo richiede una relazione many-to-many . Relazioni tra entit\u00e0 \u00b6 Entit\u00e0 A Entit\u00e0 B Tipo users posts 1 : N users comments 1 : N posts comments 1 : N posts categories N : M Considerazioni di modellazione \u00b6 ogni entit\u00e0 ha una primary key le relazioni sono esplicite tramite foreign key le relazioni N:M usano una tabella di collegamento nessuna informazione \u00e8 duplicata inutilmente Questo modello segue i principi della normalizzazione e pu\u00f2 essere implementato su qualsiasi database relazionale. Evoluzione del modello \u00b6 Durante il corso il modello verr\u00e0 esteso con: metadati gestione temporale ottimizzazioni di performance adattamenti per database diversi Il modello \u00e8 un oggetto vivo , non un diagramma statico.","title":"Modello dati"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#modello-dei-dati","text":"Questa sezione introduce il modello dei dati iniziale , che verr\u00e0 esteso progressivamente durante il corso. Il modello non \u00e8 definitivo : evolve insieme alle competenze acquisite.","title":"Modello dei dati"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#entita-principali","text":"In base al problema e ai requisiti individuiamo le seguenti entit\u00e0 fondamentali.","title":"Entit\u00e0 principali"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#utente-users","text":"Rappresenta una persona che utilizza la piattaforma. Attributi principali: identificatore univoco username email born_year born_month born_day","title":"Utente (users)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#contenuto-posts","text":"Rappresenta un contenuto creato da un utente. Attributi principali: identificatore univoco autore titolo testo Relazione: ogni contenuto appartiene a un solo utente un utente pu\u00f2 creare pi\u00f9 contenuti","title":"Contenuto (posts)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#commento-comments","text":"Rappresenta un\u2019interazione su un contenuto. Attributi principali: identificatore univoco autore contenuto testuale Relazioni: ogni commento \u00e8 associato a un utente ogni commento \u00e8 associato a un contenuto","title":"Commento (comments)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#categoria-categories","text":"Serve per classificare i contenuti. Relazione: un contenuto pu\u00f2 appartenere a pi\u00f9 categorie una categoria pu\u00f2 essere associata a pi\u00f9 contenuti Questo richiede una relazione many-to-many .","title":"Categoria (categories)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#relazioni-tra-entita","text":"Entit\u00e0 A Entit\u00e0 B Tipo users posts 1 : N users comments 1 : N posts comments 1 : N posts categories N : M","title":"Relazioni tra entit\u00e0"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#considerazioni-di-modellazione","text":"ogni entit\u00e0 ha una primary key le relazioni sono esplicite tramite foreign key le relazioni N:M usano una tabella di collegamento nessuna informazione \u00e8 duplicata inutilmente Questo modello segue i principi della normalizzazione e pu\u00f2 essere implementato su qualsiasi database relazionale.","title":"Considerazioni di modellazione"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#evoluzione-del-modello","text":"Durante il corso il modello verr\u00e0 esteso con: metadati gestione temporale ottimizzazioni di performance adattamenti per database diversi Il modello \u00e8 un oggetto vivo , non un diagramma statico.","title":"Evoluzione del modello"},{"location":"corsi/corso-database-sql/progetto/problema/","text":"Problema iniziale \u00b6 Il corso nasce dalla necessit\u00e0 di risolvere un problema concreto e realistico: progettare un sistema affidabile per la gestione di dati strutturati, interconnessi e soggetti a evoluzione nel tempo. Non partiamo dal linguaggio SQL, ma dal problema che rende necessario SQL . Contesto \u00b6 Immaginiamo di dover sviluppare una piattaforma che permetta a pi\u00f9 utenti di: registrarsi e autenticarsi creare contenuti interagire con contenuti creati da altri utenti organizzare e classificare i contenuti Il sistema deve funzionare: nel tempo con dati in crescita con pi\u00f9 utenti simultanei senza perdere coerenza dei dati Approccio ingenuo (e perch\u00e9 fallisce) \u00b6 Una prima soluzione potrebbe essere usare: file di testo file CSV file JSON Questa soluzione fallisce rapidamente perch\u00e9: non esiste un\u2019identit\u00e0 univoca garantita le relazioni sono fragili e manuali i dati possono diventare incoerenti la ricerca diventa inefficiente la concorrenza non \u00e8 gestibile Problema centrale \u00b6 Il problema non \u00e8 salvare dati , ma: modellare correttamente le informazioni definire relazioni affidabili garantire integrit\u00e0 e coerenza permettere interrogazioni efficienti supportare evoluzione e manutenzione \ud83d\udc49 Questo \u00e8 esattamente ci\u00f2 che un database relazionale risolve. Obiettivo del corso rispetto al problema \u00b6 Il corso mostra come risolvere questo problema passo dopo passo , introducendo solo gli strumenti necessari nel momento in cui servono. Non studiamo SQL \u201cper capitoli\u201d, ma per esigenze reali che emergono dal progetto.","title":"Problema iniziale"},{"location":"corsi/corso-database-sql/progetto/problema/#problema-iniziale","text":"Il corso nasce dalla necessit\u00e0 di risolvere un problema concreto e realistico: progettare un sistema affidabile per la gestione di dati strutturati, interconnessi e soggetti a evoluzione nel tempo. Non partiamo dal linguaggio SQL, ma dal problema che rende necessario SQL .","title":"Problema iniziale"},{"location":"corsi/corso-database-sql/progetto/problema/#contesto","text":"Immaginiamo di dover sviluppare una piattaforma che permetta a pi\u00f9 utenti di: registrarsi e autenticarsi creare contenuti interagire con contenuti creati da altri utenti organizzare e classificare i contenuti Il sistema deve funzionare: nel tempo con dati in crescita con pi\u00f9 utenti simultanei senza perdere coerenza dei dati","title":"Contesto"},{"location":"corsi/corso-database-sql/progetto/problema/#approccio-ingenuo-e-perche-fallisce","text":"Una prima soluzione potrebbe essere usare: file di testo file CSV file JSON Questa soluzione fallisce rapidamente perch\u00e9: non esiste un\u2019identit\u00e0 univoca garantita le relazioni sono fragili e manuali i dati possono diventare incoerenti la ricerca diventa inefficiente la concorrenza non \u00e8 gestibile","title":"Approccio ingenuo (e perch\u00e9 fallisce)"},{"location":"corsi/corso-database-sql/progetto/problema/#problema-centrale","text":"Il problema non \u00e8 salvare dati , ma: modellare correttamente le informazioni definire relazioni affidabili garantire integrit\u00e0 e coerenza permettere interrogazioni efficienti supportare evoluzione e manutenzione \ud83d\udc49 Questo \u00e8 esattamente ci\u00f2 che un database relazionale risolve.","title":"Problema centrale"},{"location":"corsi/corso-database-sql/progetto/problema/#obiettivo-del-corso-rispetto-al-problema","text":"Il corso mostra come risolvere questo problema passo dopo passo , introducendo solo gli strumenti necessari nel momento in cui servono. Non studiamo SQL \u201cper capitoli\u201d, ma per esigenze reali che emergono dal progetto.","title":"Obiettivo del corso rispetto al problema"},{"location":"corsi/corso-database-sql/progetto/requisiti/","text":"Requisiti del sistema \u00b6 Questa sezione definisce cosa il sistema deve fare e quali vincoli deve rispettare . I requisiti guidano tutte le decisioni di progettazione che verranno prese nel corso. Requisiti funzionali \u00b6 Il sistema deve permettere di: gestire utenti identificazione univoca informazioni di base (username, email) gestire contenuti ogni contenuto \u00e8 associato a un autore i contenuti hanno titolo e corpo testuale gestire interazioni commenti ai contenuti relazioni chiare tra utenti e contenuti classificare i contenuti categorie o tag possibilit\u00e0 di estensione futura Requisiti non funzionali \u00b6 Il sistema deve essere: coerente i dati non devono mai trovarsi in stati invalidi scalabile il modello deve reggere l\u2019aumento dei dati manutenibile facile da estendere senza riscrivere tutto DB-agnostic il modello non deve dipendere da un singolo database collaborativo la documentazione e le soluzioni devono poter evolvere Vincoli progettuali \u00b6 Durante il corso imponiamo alcuni vincoli intenzionali: uso esclusivo di database relazionali utilizzo di SQL standard quando possibile separazione chiara tra: modello concettuale modello logico implementazione fisica Questi vincoli non limitano , ma aiutano a ragionare correttamente. Implicazioni \u00b6 Dai requisiti derivano scelte fondamentali: uso di primary key e foreign key normalizzazione dei dati modellazione esplicita delle relazioni utilizzo di transazioni Ogni concetto teorico del corso nasce da qui.","title":"Requisiti"},{"location":"corsi/corso-database-sql/progetto/requisiti/#requisiti-del-sistema","text":"Questa sezione definisce cosa il sistema deve fare e quali vincoli deve rispettare . I requisiti guidano tutte le decisioni di progettazione che verranno prese nel corso.","title":"Requisiti del sistema"},{"location":"corsi/corso-database-sql/progetto/requisiti/#requisiti-funzionali","text":"Il sistema deve permettere di: gestire utenti identificazione univoca informazioni di base (username, email) gestire contenuti ogni contenuto \u00e8 associato a un autore i contenuti hanno titolo e corpo testuale gestire interazioni commenti ai contenuti relazioni chiare tra utenti e contenuti classificare i contenuti categorie o tag possibilit\u00e0 di estensione futura","title":"Requisiti funzionali"},{"location":"corsi/corso-database-sql/progetto/requisiti/#requisiti-non-funzionali","text":"Il sistema deve essere: coerente i dati non devono mai trovarsi in stati invalidi scalabile il modello deve reggere l\u2019aumento dei dati manutenibile facile da estendere senza riscrivere tutto DB-agnostic il modello non deve dipendere da un singolo database collaborativo la documentazione e le soluzioni devono poter evolvere","title":"Requisiti non funzionali"},{"location":"corsi/corso-database-sql/progetto/requisiti/#vincoli-progettuali","text":"Durante il corso imponiamo alcuni vincoli intenzionali: uso esclusivo di database relazionali utilizzo di SQL standard quando possibile separazione chiara tra: modello concettuale modello logico implementazione fisica Questi vincoli non limitano , ma aiutano a ragionare correttamente.","title":"Vincoli progettuali"},{"location":"corsi/corso-database-sql/progetto/requisiti/#implicazioni","text":"Dai requisiti derivano scelte fondamentali: uso di primary key e foreign key normalizzazione dei dati modellazione esplicita delle relazioni utilizzo di transazioni Ogni concetto teorico del corso nasce da qui.","title":"Implicazioni"},{"location":"corsi/makedocs/","text":"Introduzione a MakeDocs \u00b6 Questa guida spiega passo\u2011passo come usare MakeDocs per creare una documentazione ordinata, versionabile e pubblicabile come sito statico. L\u2019obiettivo \u00e8 doppio: iniziare senza errori costruire una base solida per una conoscenza pi\u00f9 approfondita 1. Cos\u2019\u00e8 MakeDocs \u00b6 MakeDocs \u00e8 un generatore di documentazione statica : prende file Markdown e produce un sito HTML pronto per il browser. Il flusso \u00e8 semplice: Markdown \u2192 build \u2192 HTML statico MkDocs non \u00e8 un CMS e non richiede un database . \u00c8 pensato per documentazione tecnica, corsi, progetti e librerie. 2. Perch\u00e9 usarlo \u00b6 MkDocs ti permette di: separare contenuti e codice versionare la documentazione con Git pubblicare un sito statico facilmente mantenere struttura e navigazione coerenti \u00c8 ideale quando vuoi ordine, chiarezza e manutenzione semplice . 3. Requisiti minimi \u00b6 Prima di iniziare assicurati di avere: Python \u2265 3.8 pip terminale/CLI Verifica: python --version pip --version 4. Installazione \u00b6 Installa MkDocs con pip : pip install mkdocs Verifica: mkdocs --help Se vedi l\u2019help, l\u2019installazione \u00e8 corretta. 5. Struttura di un progetto MkDocs \u00b6 Una struttura tipica \u00e8 questa: project/ \u251c\u2500\u2500 docs/ \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 introduzione.md \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 site/ Significato: docs/ \u2192 contenuti sorgente in Markdown mkdocs.yml \u2192 configurazione del sito site/ \u2192 output generato (HTML, CSS, JS) site/ non si modifica a mano . 6. Il file di configurazione ( mkdocs.yml ) \u00b6 Questo file controlla tutto: titolo, URL, tema e navigazione. Esempio minimo: site_name: Corso Database SQL site_url: http://localhost nav: - Home: index.md - Introduzione: introduzione.md Significato delle voci principali \u00b6 site_name : titolo del sito site_url : URL base (locale o produzione) nav : menu di navigazione La nav definisce ordine e visibilit\u00e0 . Se un file non \u00e8 nella nav , non appare nel sito . 7. I file Markdown \u00b6 Ogni file .md in docs/ rappresenta una pagina. Consigli fondamentali: un file = una pagina nomi senza spazi (usa - ) struttura coerente con la navigazione Per la sintassi Markdown, usa il corso dedicato: \u27a1\ufe0f Corso Markdown 8. Front\u2011matter (titolo pagina) \u00b6 MkDocs supporta il front\u2011matter in YAML per titoli e metadata. Esempio minimo: --- title: Introduzione --- \u00c8 consigliato su tutte le pagine perch\u00e9 rende il sito coerente e leggibile . 9. Organizzazione dei contenuti \u00b6 Regole pratiche: i titoli devono essere coerenti con la nav ogni cartella rappresenta un\u2019area logica evita duplicazioni tieni il percorso breve e comprensibile Una buona organizzazione rende il sito scalabile . 10. Build della documentazione \u00b6 Per generare il sito: mkdocs build Risultato: cartella site/ creata/aggiornata HTML pronto per la pubblicazione Ogni modifica ai .md richiede una nuova build. 11. Anteprima locale \u00b6 Per vedere il sito in locale: mkdocs serve Indirizzo predefinito: http://127.0.0.1:8000 Vantaggi: hot reload preview immediata ambiente di lavoro sicuro 12. Modificare correttamente la documentazione \u00b6 Workflow consigliato: apri un file .md modifica il contenuto salva aggiorna il browser (se sei in serve ) Non modificare mai i file dentro site/ . 13. Aggiungere una nuova pagina \u00b6 Passaggi obbligatori: crea il file in docs/ scrivi il contenuto aggiungilo al nav in mkdocs.yml Esempio: nav: - Home: index.md - Modelli: modelli.md Se salti il punto 3, la pagina non esiste nel sito . 14. Errori comuni \u00b6 Errori frequenti che bloccano la build o \u201cnascondono\u201d pagine: file creati ma non inseriti in nav nomi in nav che non corrispondono ai file reali modifiche ai file in site/ struttura docs/ disordinata In caso di problemi, controlla sempre mkdocs.yml . 15. Versionamento con Git \u00b6 Buona pratica: versionare docs/ versionare mkdocs.yml non versionare site/ In .gitignore aggiungi: site/ 16. Passo successivo: approfondire \u00b6 Per passare da \u201cuso base\u201d a conoscenza solida: esplora temi e personalizzazioni studia le estensioni Markdown supportate organizza il sito in sezioni e moduli usa la nav come struttura didattica Quando il progetto cresce, la disciplina sulla struttura \u00e8 ci\u00f2 che distingue un sito chiaro da uno caotico . 17. Collegamento al corso Markdown \u00b6 Per imparare Markdown in modo sistematico: \u27a1\ufe0f Corso Markdown Link interno: /corsi/markdown","title":"MakeDocs"},{"location":"corsi/makedocs/#introduzione-a-makedocs","text":"Questa guida spiega passo\u2011passo come usare MakeDocs per creare una documentazione ordinata, versionabile e pubblicabile come sito statico. L\u2019obiettivo \u00e8 doppio: iniziare senza errori costruire una base solida per una conoscenza pi\u00f9 approfondita","title":"Introduzione a MakeDocs"},{"location":"corsi/makedocs/#1-cose-makedocs","text":"MakeDocs \u00e8 un generatore di documentazione statica : prende file Markdown e produce un sito HTML pronto per il browser. Il flusso \u00e8 semplice: Markdown \u2192 build \u2192 HTML statico MkDocs non \u00e8 un CMS e non richiede un database . \u00c8 pensato per documentazione tecnica, corsi, progetti e librerie.","title":"1. Cos\u2019\u00e8 MakeDocs"},{"location":"corsi/makedocs/#2-perche-usarlo","text":"MkDocs ti permette di: separare contenuti e codice versionare la documentazione con Git pubblicare un sito statico facilmente mantenere struttura e navigazione coerenti \u00c8 ideale quando vuoi ordine, chiarezza e manutenzione semplice .","title":"2. Perch\u00e9 usarlo"},{"location":"corsi/makedocs/#3-requisiti-minimi","text":"Prima di iniziare assicurati di avere: Python \u2265 3.8 pip terminale/CLI Verifica: python --version pip --version","title":"3. Requisiti minimi"},{"location":"corsi/makedocs/#4-installazione","text":"Installa MkDocs con pip : pip install mkdocs Verifica: mkdocs --help Se vedi l\u2019help, l\u2019installazione \u00e8 corretta.","title":"4. Installazione"},{"location":"corsi/makedocs/#5-struttura-di-un-progetto-mkdocs","text":"Una struttura tipica \u00e8 questa: project/ \u251c\u2500\u2500 docs/ \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 introduzione.md \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 site/ Significato: docs/ \u2192 contenuti sorgente in Markdown mkdocs.yml \u2192 configurazione del sito site/ \u2192 output generato (HTML, CSS, JS) site/ non si modifica a mano .","title":"5. Struttura di un progetto MkDocs"},{"location":"corsi/makedocs/#6-il-file-di-configurazione-mkdocsyml","text":"Questo file controlla tutto: titolo, URL, tema e navigazione. Esempio minimo: site_name: Corso Database SQL site_url: http://localhost nav: - Home: index.md - Introduzione: introduzione.md","title":"6. Il file di configurazione (mkdocs.yml)"},{"location":"corsi/makedocs/#significato-delle-voci-principali","text":"site_name : titolo del sito site_url : URL base (locale o produzione) nav : menu di navigazione La nav definisce ordine e visibilit\u00e0 . Se un file non \u00e8 nella nav , non appare nel sito .","title":"Significato delle voci principali"},{"location":"corsi/makedocs/#7-i-file-markdown","text":"Ogni file .md in docs/ rappresenta una pagina. Consigli fondamentali: un file = una pagina nomi senza spazi (usa - ) struttura coerente con la navigazione Per la sintassi Markdown, usa il corso dedicato: \u27a1\ufe0f Corso Markdown","title":"7. I file Markdown"},{"location":"corsi/makedocs/#8-frontmatter-titolo-pagina","text":"MkDocs supporta il front\u2011matter in YAML per titoli e metadata. Esempio minimo: --- title: Introduzione --- \u00c8 consigliato su tutte le pagine perch\u00e9 rende il sito coerente e leggibile .","title":"8. Front\u2011matter (titolo pagina)"},{"location":"corsi/makedocs/#9-organizzazione-dei-contenuti","text":"Regole pratiche: i titoli devono essere coerenti con la nav ogni cartella rappresenta un\u2019area logica evita duplicazioni tieni il percorso breve e comprensibile Una buona organizzazione rende il sito scalabile .","title":"9. Organizzazione dei contenuti"},{"location":"corsi/makedocs/#10-build-della-documentazione","text":"Per generare il sito: mkdocs build Risultato: cartella site/ creata/aggiornata HTML pronto per la pubblicazione Ogni modifica ai .md richiede una nuova build.","title":"10. Build della documentazione"},{"location":"corsi/makedocs/#11-anteprima-locale","text":"Per vedere il sito in locale: mkdocs serve Indirizzo predefinito: http://127.0.0.1:8000 Vantaggi: hot reload preview immediata ambiente di lavoro sicuro","title":"11. Anteprima locale"},{"location":"corsi/makedocs/#12-modificare-correttamente-la-documentazione","text":"Workflow consigliato: apri un file .md modifica il contenuto salva aggiorna il browser (se sei in serve ) Non modificare mai i file dentro site/ .","title":"12. Modificare correttamente la documentazione"},{"location":"corsi/makedocs/#13-aggiungere-una-nuova-pagina","text":"Passaggi obbligatori: crea il file in docs/ scrivi il contenuto aggiungilo al nav in mkdocs.yml Esempio: nav: - Home: index.md - Modelli: modelli.md Se salti il punto 3, la pagina non esiste nel sito .","title":"13. Aggiungere una nuova pagina"},{"location":"corsi/makedocs/#14-errori-comuni","text":"Errori frequenti che bloccano la build o \u201cnascondono\u201d pagine: file creati ma non inseriti in nav nomi in nav che non corrispondono ai file reali modifiche ai file in site/ struttura docs/ disordinata In caso di problemi, controlla sempre mkdocs.yml .","title":"14. Errori comuni"},{"location":"corsi/makedocs/#15-versionamento-con-git","text":"Buona pratica: versionare docs/ versionare mkdocs.yml non versionare site/ In .gitignore aggiungi: site/","title":"15. Versionamento con Git"},{"location":"corsi/makedocs/#16-passo-successivo-approfondire","text":"Per passare da \u201cuso base\u201d a conoscenza solida: esplora temi e personalizzazioni studia le estensioni Markdown supportate organizza il sito in sezioni e moduli usa la nav come struttura didattica Quando il progetto cresce, la disciplina sulla struttura \u00e8 ci\u00f2 che distingue un sito chiaro da uno caotico .","title":"16. Passo successivo: approfondire"},{"location":"corsi/makedocs/#17-collegamento-al-corso-markdown","text":"Per imparare Markdown in modo sistematico: \u27a1\ufe0f Corso Markdown Link interno: /corsi/markdown","title":"17. Collegamento al corso Markdown"},{"location":"corsi/markdown/","text":"Introduzione a Markdown \u00b6 Markdown \u00e8 un linguaggio di formattazione leggero che permette di scrivere testo con una sintassi semplice e leggibile, convertibile in HTML o altri formati. Serve per creare documenti chiari, strutturati e facilmente manutenibili, senza dover scrivere codice HTML. \u00c8 ideale per documentazione, appunti tecnici, guide e contenuti che devono essere versionati con Git. Sintassi essenziale con esempi \u00b6 Titoli \u00b6 # Titolo 1 ## Titolo 2 ### Titolo 3 #### Titolo 4 ##### Titolo 5 ###### Titolo 6 Paragrafi e a capo \u00b6 Questo \u00e8 un paragrafo. Questo \u00e8 un nuovo paragrafo. Grassetto e corsivo \u00b6 **grassetto** *corsivo* Liste puntate e numerate \u00b6 - voce uno - voce due - sotto\u2011voce 1. primo 2. secondo 3. terzo Checklist \u00b6 - [x] completato - [ ] da fare Link \u00b6 [Testo del link](https://example.com) Immagini \u00b6 ![Testo alternativo](img/diagramma.png) Citazioni \u00b6 > Questa \u00e8 una citazione. Codice inline e blocchi di codice \u00b6 Usa il comando `git status`. ```bash git status ``` Tabelle \u00b6 | Colonna | Descrizione | |---|---| | A | Prima voce | | B | Seconda voce | Linea orizzontale \u00b6 --- Front\u2011matter (metadata della pagina) \u00b6 --- title: Titolo della pagina --- Buone pratiche \u00b6 un file = una pagina titoli in ordine gerarchico nomi file semplici, senza spazi usare esempi reali e coerenti Markdown premia la chiarezza: pi\u00f9 la struttura \u00e8 pulita, pi\u00f9 il documento \u00e8 facile da leggere e mantenere. Esempio completo di pagina (Lorem ipsum) \u00b6 Sorgente Markdown \u00b6 --- title: Pagina di esempio --- # Pagina di esempio Lorem ipsum dolor sit amet, consectetur adipiscing elit. **Aenean** *viverra* magna. ## Sezione introduttiva Lorem ipsum dolor sit amet, consectetur adipiscing elit. ### Lista di punti - Lorem ipsum - Dolor sit amet - Consectetur adipiscing ### Lista numerata 1. Primo punto 2. Secondo punto 3. Terzo punto ### Checklist - [x] Bozza completata - [ ] Revisione in corso ### Link [Vai al sito](https://example.com) ### Citazione > Lorem ipsum dolor sit amet, consectetur adipiscing elit. ### Codice Usa il comando `echo` per stampare testo. ```bash echo \"Lorem ipsum\" ``` ### Tabella | Campo | Descrizione | |---|---| | A | Lorem ipsum | | B | Dolor sit amet | --- Fine pagina. Risultato atteso \u00b6 Il risutato atteso \u00e8 la pagina stessa che stai visualizzando.","title":"MarkDown"},{"location":"corsi/markdown/#introduzione-a-markdown","text":"Markdown \u00e8 un linguaggio di formattazione leggero che permette di scrivere testo con una sintassi semplice e leggibile, convertibile in HTML o altri formati. Serve per creare documenti chiari, strutturati e facilmente manutenibili, senza dover scrivere codice HTML. \u00c8 ideale per documentazione, appunti tecnici, guide e contenuti che devono essere versionati con Git.","title":"Introduzione a Markdown"},{"location":"corsi/markdown/#sintassi-essenziale-con-esempi","text":"","title":"Sintassi essenziale con esempi"},{"location":"corsi/markdown/#titoli","text":"# Titolo 1 ## Titolo 2 ### Titolo 3 #### Titolo 4 ##### Titolo 5 ###### Titolo 6","title":"Titoli"},{"location":"corsi/markdown/#paragrafi-e-a-capo","text":"Questo \u00e8 un paragrafo. Questo \u00e8 un nuovo paragrafo.","title":"Paragrafi e a capo"},{"location":"corsi/markdown/#grassetto-e-corsivo","text":"**grassetto** *corsivo*","title":"Grassetto e corsivo"},{"location":"corsi/markdown/#liste-puntate-e-numerate","text":"- voce uno - voce due - sotto\u2011voce 1. primo 2. secondo 3. terzo","title":"Liste puntate e numerate"},{"location":"corsi/markdown/#checklist","text":"- [x] completato - [ ] da fare","title":"Checklist"},{"location":"corsi/markdown/#link","text":"[Testo del link](https://example.com)","title":"Link"},{"location":"corsi/markdown/#immagini","text":"![Testo alternativo](img/diagramma.png)","title":"Immagini"},{"location":"corsi/markdown/#citazioni","text":"> Questa \u00e8 una citazione.","title":"Citazioni"},{"location":"corsi/markdown/#codice-inline-e-blocchi-di-codice","text":"Usa il comando `git status`. ```bash git status ```","title":"Codice inline e blocchi di codice"},{"location":"corsi/markdown/#tabelle","text":"| Colonna | Descrizione | |---|---| | A | Prima voce | | B | Seconda voce |","title":"Tabelle"},{"location":"corsi/markdown/#linea-orizzontale","text":"---","title":"Linea orizzontale"},{"location":"corsi/markdown/#frontmatter-metadata-della-pagina","text":"--- title: Titolo della pagina ---","title":"Front\u2011matter (metadata della pagina)"},{"location":"corsi/markdown/#buone-pratiche","text":"un file = una pagina titoli in ordine gerarchico nomi file semplici, senza spazi usare esempi reali e coerenti Markdown premia la chiarezza: pi\u00f9 la struttura \u00e8 pulita, pi\u00f9 il documento \u00e8 facile da leggere e mantenere.","title":"Buone pratiche"},{"location":"corsi/markdown/#esempio-completo-di-pagina-lorem-ipsum","text":"","title":"Esempio completo di pagina (Lorem ipsum)"},{"location":"corsi/markdown/#sorgente-markdown","text":"--- title: Pagina di esempio --- # Pagina di esempio Lorem ipsum dolor sit amet, consectetur adipiscing elit. **Aenean** *viverra* magna. ## Sezione introduttiva Lorem ipsum dolor sit amet, consectetur adipiscing elit. ### Lista di punti - Lorem ipsum - Dolor sit amet - Consectetur adipiscing ### Lista numerata 1. Primo punto 2. Secondo punto 3. Terzo punto ### Checklist - [x] Bozza completata - [ ] Revisione in corso ### Link [Vai al sito](https://example.com) ### Citazione > Lorem ipsum dolor sit amet, consectetur adipiscing elit. ### Codice Usa il comando `echo` per stampare testo. ```bash echo \"Lorem ipsum\" ``` ### Tabella | Campo | Descrizione | |---|---| | A | Lorem ipsum | | B | Dolor sit amet | --- Fine pagina.","title":"Sorgente Markdown"},{"location":"corsi/markdown/#risultato-atteso","text":"Il risutato atteso \u00e8 la pagina stessa che stai visualizzando.","title":"Risultato atteso"}]}