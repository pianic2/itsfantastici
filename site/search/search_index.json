{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentazione ITS Fantastici \u00b6 Questa piattaforma raccoglie la documentazione tecnica dei corsi ITS Fantastici. L\u2019obiettivo non \u00e8 fornire semplici appunti, ma costruire una base di conoscenza strutturata, collaborativa e riutilizzabile , orientata allo sviluppo di competenze reali e alla risoluzione di problemi concreti. Caratteristiche principali \u00b6 organizzazione per corsi e moduli documentazione versionata tramite Git contributi collaborativi con revisione della community esempi pratici e progetto unico per ogni corso focus su scalabilit\u00e0, modellizzazione e correttezza tecnica Corsi disponibili \u00b6 Vai all\u2019 indice dei corsi .","title":"Home"},{"location":"#documentazione-its-fantastici","text":"Questa piattaforma raccoglie la documentazione tecnica dei corsi ITS Fantastici. L\u2019obiettivo non \u00e8 fornire semplici appunti, ma costruire una base di conoscenza strutturata, collaborativa e riutilizzabile , orientata allo sviluppo di competenze reali e alla risoluzione di problemi concreti.","title":"Documentazione ITS Fantastici"},{"location":"#caratteristiche-principali","text":"organizzazione per corsi e moduli documentazione versionata tramite Git contributi collaborativi con revisione della community esempi pratici e progetto unico per ogni corso focus su scalabilit\u00e0, modellizzazione e correttezza tecnica","title":"Caratteristiche principali"},{"location":"#corsi-disponibili","text":"Vai all\u2019 indice dei corsi .","title":"Corsi disponibili"},{"location":"esempio-lezione/","text":"Lezione XX \u2014 Titolo \u00b6 Problema \u00b6 Descrizione chiara e concreta del problema che vogliamo risolvere. contesto reale vincoli noti cosa non sappiamo ancora fare perch\u00e9 il problema \u00e8 rilevante Questa sezione d\u00e0 senso a tutta la lezione. Teoria \u00b6 Spiegazione dei concetti necessari solo per affrontare il problema. definizioni modelli concettuali regole e vincoli diagrammi (se servono) La teoria non \u00e8 fine a s\u00e9 stessa , ma strumentale. Esempi \u00b6 Applicazione pratica immediata dei concetti teorici. esempi SQL commentati casi semplici \u2192 casi realistici tutto coerente con il progetto unico ```sql -- esempio esplicativo SELECT ...","title":"Lezione XX \u2014 Titolo"},{"location":"esempio-lezione/#lezione-xx-titolo","text":"","title":"Lezione XX \u2014 Titolo"},{"location":"esempio-lezione/#problema","text":"Descrizione chiara e concreta del problema che vogliamo risolvere. contesto reale vincoli noti cosa non sappiamo ancora fare perch\u00e9 il problema \u00e8 rilevante Questa sezione d\u00e0 senso a tutta la lezione.","title":"Problema"},{"location":"esempio-lezione/#teoria","text":"Spiegazione dei concetti necessari solo per affrontare il problema. definizioni modelli concettuali regole e vincoli diagrammi (se servono) La teoria non \u00e8 fine a s\u00e9 stessa , ma strumentale.","title":"Teoria"},{"location":"esempio-lezione/#esempi","text":"Applicazione pratica immediata dei concetti teorici. esempi SQL commentati casi semplici \u2192 casi realistici tutto coerente con il progetto unico ```sql -- esempio esplicativo SELECT ...","title":"Esempi"},{"location":"corsi/","text":"Corsi \u00b6 In questa sezione trovi tutti i corsi documentati sulla piattaforma. Ogni corso segue uno standard comune : - un problema iniziale da risolvere - sviluppo incrementale delle competenze - progetto unico come filo conduttore - contributi della community integrati nella documentazione Elenco corsi \u00b6 Corso Database SQL","title":"Indice corsi"},{"location":"corsi/#corsi","text":"In questa sezione trovi tutti i corsi documentati sulla piattaforma. Ogni corso segue uno standard comune : - un problema iniziale da risolvere - sviluppo incrementale delle competenze - progetto unico come filo conduttore - contributi della community integrati nella documentazione","title":"Corsi"},{"location":"corsi/#elenco-corsi","text":"Corso Database SQL","title":"Elenco corsi"},{"location":"corsi/corso-database-sql/","text":"Corso Database SQL \u00b6 Questo corso introduce i concetti fondamentali dei database relazionali e del linguaggio SQL, partendo dalle basi teoriche fino ad arrivare a progettazione, query avanzate e deploy. Il corso \u00e8 costruito attorno a un progetto unico , che evolve modulo dopo modulo, mantenendo sempre un filo logico tra teoria e pratica. Non \u00e8 un corso di sola sintassi: l\u2019obiettivo \u00e8 imparare a progettare, interrogare e mantenere dati correttamente , ragionando come chi costruisce sistemi reali. Idea centrale del corso \u00b6 Tutto il corso ruota attorno a un unico progetto , che evolve nel tempo. Non studiamo SQL \u201cper argomenti isolati\u201d, ma perch\u00e9: - emerge un problema reale - serve uno strumento specifico - lo applichiamo subito al progetto Questo garantisce: - continuit\u00e0 logica - coerenza tra le lezioni - competenze realmente spendibili Obiettivi del corso \u00b6 comprendere come e perch\u00e9 usare un database relazionale progettare correttamente uno schema dati scrivere query SQL corrette, leggibili e scalabili comprendere le differenze tra motori SQL (SQLite \u2192 MySQL) lavorare in modo collaborativo su documentazione e soluzioni Struttura del corso \u00b6 Progetto : definizione del problema e del modello dati Moduli : concetti teorici + applicazione pratica Esercizi : approfondimento guidato, non verifica Soluzioni community : le migliori spiegazioni vengono integrate Partecipazione della community \u00b6 Gli studenti possono: - proporre esercizi - migliorare spiegazioni - suggerire soluzioni alternative Ogni modifica passa tramite Pull Request e viene approvata secondo la regola 50% + 1 . Tecnologie utilizzate \u00b6 SQL standard (approccio DB-agnostic) SQLite per sviluppo iniziale MySQL per scenari di produzione Git + GitHub per collaborazione MkDocs per la documentazione Navigazione rapida \u00b6 Progetto Moduli Linee guida community Changelog","title":"Home corso"},{"location":"corsi/corso-database-sql/#corso-database-sql","text":"Questo corso introduce i concetti fondamentali dei database relazionali e del linguaggio SQL, partendo dalle basi teoriche fino ad arrivare a progettazione, query avanzate e deploy. Il corso \u00e8 costruito attorno a un progetto unico , che evolve modulo dopo modulo, mantenendo sempre un filo logico tra teoria e pratica. Non \u00e8 un corso di sola sintassi: l\u2019obiettivo \u00e8 imparare a progettare, interrogare e mantenere dati correttamente , ragionando come chi costruisce sistemi reali.","title":"Corso Database SQL"},{"location":"corsi/corso-database-sql/#idea-centrale-del-corso","text":"Tutto il corso ruota attorno a un unico progetto , che evolve nel tempo. Non studiamo SQL \u201cper argomenti isolati\u201d, ma perch\u00e9: - emerge un problema reale - serve uno strumento specifico - lo applichiamo subito al progetto Questo garantisce: - continuit\u00e0 logica - coerenza tra le lezioni - competenze realmente spendibili","title":"Idea centrale del corso"},{"location":"corsi/corso-database-sql/#obiettivi-del-corso","text":"comprendere come e perch\u00e9 usare un database relazionale progettare correttamente uno schema dati scrivere query SQL corrette, leggibili e scalabili comprendere le differenze tra motori SQL (SQLite \u2192 MySQL) lavorare in modo collaborativo su documentazione e soluzioni","title":"Obiettivi del corso"},{"location":"corsi/corso-database-sql/#struttura-del-corso","text":"Progetto : definizione del problema e del modello dati Moduli : concetti teorici + applicazione pratica Esercizi : approfondimento guidato, non verifica Soluzioni community : le migliori spiegazioni vengono integrate","title":"Struttura del corso"},{"location":"corsi/corso-database-sql/#partecipazione-della-community","text":"Gli studenti possono: - proporre esercizi - migliorare spiegazioni - suggerire soluzioni alternative Ogni modifica passa tramite Pull Request e viene approvata secondo la regola 50% + 1 .","title":"Partecipazione della community"},{"location":"corsi/corso-database-sql/#tecnologie-utilizzate","text":"SQL standard (approccio DB-agnostic) SQLite per sviluppo iniziale MySQL per scenari di produzione Git + GitHub per collaborazione MkDocs per la documentazione","title":"Tecnologie utilizzate"},{"location":"corsi/corso-database-sql/#navigazione-rapida","text":"Progetto Moduli Linee guida community Changelog","title":"Navigazione rapida"},{"location":"corsi/corso-database-sql/changelog/","text":"Changelog \u00b6 Questo documento registra le modifiche rilevanti alla documentazione del corso Database SQL . Il changelog: - riflette l\u2019evoluzione reale del corso - \u00e8 supportato da Git - documenta solo cambiamenti concettuali o strutturali Modifiche minori (refusi, formattazione) possono non essere elencate. [Unreleased] \u00b6 Added \u00b6 modello di documentazione collaborativa standard globale per corsi ITS Fantastici struttura modulare con progetto unico governance community basata su Pull Request Changed \u00b6 approccio didattico orientato al problema, non alla sintassi [v0.1.0] \u2014 Fondazioni iniziali \u00b6 Added \u00b6 piattaforma documentale ITS Fantastici struttura scalabile per pi\u00f9 corsi corso Database SQL progetto unico del corso problema iniziale requisiti modello dati iniziale Modulo 01 \u2014 Fondamenti dei database Lezione 01 \u2014 Introduzione ai database Lezione 02 \u2014 Primo contatto con SQL template standard di lezione linee guida per contributi della community Lezione 03 - Relazioni e JOIN Convenzioni \u00b6 Added : nuove funzionalit\u00e0, sezioni o concetti Changed : modifiche a contenuti esistenti Deprecated : concetti o strutture non pi\u00f9 consigliati Removed : contenuti rimossi Fixed : correzioni concettuali importanti Ogni modifica che influisce sul significato didattico del corso deve essere tracciata qui. Note operative \u00b6 ogni release corrisponde a uno stato coerente del corso il changelog non sostituisce la cronologia Git le decisioni didattiche importanti devono essere esplicite","title":"Changelog"},{"location":"corsi/corso-database-sql/changelog/#changelog","text":"Questo documento registra le modifiche rilevanti alla documentazione del corso Database SQL . Il changelog: - riflette l\u2019evoluzione reale del corso - \u00e8 supportato da Git - documenta solo cambiamenti concettuali o strutturali Modifiche minori (refusi, formattazione) possono non essere elencate.","title":"Changelog"},{"location":"corsi/corso-database-sql/changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"corsi/corso-database-sql/changelog/#added","text":"modello di documentazione collaborativa standard globale per corsi ITS Fantastici struttura modulare con progetto unico governance community basata su Pull Request","title":"Added"},{"location":"corsi/corso-database-sql/changelog/#changed","text":"approccio didattico orientato al problema, non alla sintassi","title":"Changed"},{"location":"corsi/corso-database-sql/changelog/#v010-fondazioni-iniziali","text":"","title":"[v0.1.0] \u2014 Fondazioni iniziali"},{"location":"corsi/corso-database-sql/changelog/#added_1","text":"piattaforma documentale ITS Fantastici struttura scalabile per pi\u00f9 corsi corso Database SQL progetto unico del corso problema iniziale requisiti modello dati iniziale Modulo 01 \u2014 Fondamenti dei database Lezione 01 \u2014 Introduzione ai database Lezione 02 \u2014 Primo contatto con SQL template standard di lezione linee guida per contributi della community Lezione 03 - Relazioni e JOIN","title":"Added"},{"location":"corsi/corso-database-sql/changelog/#convenzioni","text":"Added : nuove funzionalit\u00e0, sezioni o concetti Changed : modifiche a contenuti esistenti Deprecated : concetti o strutture non pi\u00f9 consigliati Removed : contenuti rimossi Fixed : correzioni concettuali importanti Ogni modifica che influisce sul significato didattico del corso deve essere tracciata qui.","title":"Convenzioni"},{"location":"corsi/corso-database-sql/changelog/#note-operative","text":"ogni release corrisponde a uno stato coerente del corso il changelog non sostituisce la cronologia Git le decisioni didattiche importanti devono essere esplicite","title":"Note operative"},{"location":"corsi/corso-database-sql/community/","text":"Community \u00b6 Questo corso \u00e8 costruito come documentazione collaborativa . Gli studenti non sono semplici fruitori, ma parte attiva nel miglioramento: - delle spiegazioni - degli esempi - degli esercizi - delle soluzioni Principi fondamentali \u00b6 la documentazione \u00e8 viva le soluzioni sono motivate, non \u201cgiuste\u201d le decisioni sono argomentate la qualit\u00e0 \u00e8 responsabilit\u00e0 collettiva Come contribuire \u00b6 \u00c8 possibile contribuire tramite: - proposte di esercizi - miglioramenti delle spiegazioni - estensioni delle soluzioni - correzioni tecniche Tutte le modifiche avvengono tramite Pull Request su GitHub . Approvazione delle modifiche \u00b6 Una modifica viene integrata solo se: - \u00e8 tecnicamente corretta - \u00e8 chiara e ben spiegata - viene approvata da almeno 50% + 1 degli studenti Documentazione di riferimento \u00b6 Linee guida Workflow di contribuzione","title":"Introduzione"},{"location":"corsi/corso-database-sql/community/#community","text":"Questo corso \u00e8 costruito come documentazione collaborativa . Gli studenti non sono semplici fruitori, ma parte attiva nel miglioramento: - delle spiegazioni - degli esempi - degli esercizi - delle soluzioni","title":"Community"},{"location":"corsi/corso-database-sql/community/#principi-fondamentali","text":"la documentazione \u00e8 viva le soluzioni sono motivate, non \u201cgiuste\u201d le decisioni sono argomentate la qualit\u00e0 \u00e8 responsabilit\u00e0 collettiva","title":"Principi fondamentali"},{"location":"corsi/corso-database-sql/community/#come-contribuire","text":"\u00c8 possibile contribuire tramite: - proposte di esercizi - miglioramenti delle spiegazioni - estensioni delle soluzioni - correzioni tecniche Tutte le modifiche avvengono tramite Pull Request su GitHub .","title":"Come contribuire"},{"location":"corsi/corso-database-sql/community/#approvazione-delle-modifiche","text":"Una modifica viene integrata solo se: - \u00e8 tecnicamente corretta - \u00e8 chiara e ben spiegata - viene approvata da almeno 50% + 1 degli studenti","title":"Approvazione delle modifiche"},{"location":"corsi/corso-database-sql/community/#documentazione-di-riferimento","text":"Linee guida Workflow di contribuzione","title":"Documentazione di riferimento"},{"location":"corsi/corso-database-sql/community/linee-guida/","text":"Linee guida della community \u00b6 Questa documentazione \u00e8 collaborativa . Il suo valore dipende dalla qualit\u00e0 dei contributi , non dalla quantit\u00e0. Queste linee guida definiscono come contribuire correttamente . Principi fondamentali \u00b6 Ogni contributo deve rispettare i seguenti principi: 1. Correttezza tecnica \u00b6 le informazioni devono essere verificabili niente scorciatoie concettuali niente soluzioni \u201cfunzionano ma non si spiegano\u201d 2. Chiarezza \u00b6 spiegare perch\u00e9 una scelta \u00e8 corretta evitare ambiguit\u00e0 usare terminologia coerente con il corso 3. Coerenza con il progetto \u00b6 ogni esempio deve essere coerente con il modello dati evitare esempi isolati o fuori contesto il progetto \u00e8 il filo conduttore 4. DB-agnostic \u00b6 preferire SQL standard specificare quando qualcosa \u00e8 dipendente dal database evitare soluzioni specifiche se non motivate Tipologie di contributo accettate \u00b6 \u00c8 possibile contribuire con: nuovi esercizi di approfondimento miglioramenti alle spiegazioni soluzioni alternative ben motivate correzioni concettuali chiarimenti su punti complessi Non sono accettati: - esercizi \u201cda verifica\u201d - soluzioni senza spiegazione - duplicazioni inutili - contenuti fuori scope Stile della documentazione \u00b6 usare Markdown conforme allo standard del corso seguire il template di lezione codice sempre commentato esempi realistici, non astratti Responsabilit\u00e0 \u00b6 Ogni contributore \u00e8 responsabile di: - ci\u00f2 che propone - la qualit\u00e0 tecnica del contenuto - l\u2019impatto sul resto del corso La community valuta contenuto , non persone.","title":"Linee guida"},{"location":"corsi/corso-database-sql/community/linee-guida/#linee-guida-della-community","text":"Questa documentazione \u00e8 collaborativa . Il suo valore dipende dalla qualit\u00e0 dei contributi , non dalla quantit\u00e0. Queste linee guida definiscono come contribuire correttamente .","title":"Linee guida della community"},{"location":"corsi/corso-database-sql/community/linee-guida/#principi-fondamentali","text":"Ogni contributo deve rispettare i seguenti principi:","title":"Principi fondamentali"},{"location":"corsi/corso-database-sql/community/linee-guida/#1-correttezza-tecnica","text":"le informazioni devono essere verificabili niente scorciatoie concettuali niente soluzioni \u201cfunzionano ma non si spiegano\u201d","title":"1. Correttezza tecnica"},{"location":"corsi/corso-database-sql/community/linee-guida/#2-chiarezza","text":"spiegare perch\u00e9 una scelta \u00e8 corretta evitare ambiguit\u00e0 usare terminologia coerente con il corso","title":"2. Chiarezza"},{"location":"corsi/corso-database-sql/community/linee-guida/#3-coerenza-con-il-progetto","text":"ogni esempio deve essere coerente con il modello dati evitare esempi isolati o fuori contesto il progetto \u00e8 il filo conduttore","title":"3. Coerenza con il progetto"},{"location":"corsi/corso-database-sql/community/linee-guida/#4-db-agnostic","text":"preferire SQL standard specificare quando qualcosa \u00e8 dipendente dal database evitare soluzioni specifiche se non motivate","title":"4. DB-agnostic"},{"location":"corsi/corso-database-sql/community/linee-guida/#tipologie-di-contributo-accettate","text":"\u00c8 possibile contribuire con: nuovi esercizi di approfondimento miglioramenti alle spiegazioni soluzioni alternative ben motivate correzioni concettuali chiarimenti su punti complessi Non sono accettati: - esercizi \u201cda verifica\u201d - soluzioni senza spiegazione - duplicazioni inutili - contenuti fuori scope","title":"Tipologie di contributo accettate"},{"location":"corsi/corso-database-sql/community/linee-guida/#stile-della-documentazione","text":"usare Markdown conforme allo standard del corso seguire il template di lezione codice sempre commentato esempi realistici, non astratti","title":"Stile della documentazione"},{"location":"corsi/corso-database-sql/community/linee-guida/#responsabilita","text":"Ogni contributore \u00e8 responsabile di: - ci\u00f2 che propone - la qualit\u00e0 tecnica del contenuto - l\u2019impatto sul resto del corso La community valuta contenuto , non persone.","title":"Responsabilit\u00e0"},{"location":"corsi/corso-database-sql/community/workflow/","text":"Workflow di contribuzione \u00b6 Questo documento descrive il processo operativo per proporre modifiche alla documentazione del corso. Tutte le modifiche passano tramite Git e GitHub . Strumenti \u00b6 repository GitHub: itsfantastici/docs branch principale: main contributi tramite Pull Request Non sono consentite modifiche dirette su main . Flusso di lavoro \u00b6 1. Fork o branch \u00b6 crea un fork del repository oppure crea un branch dedicato Nome branch consigliato: feature/nome-breve fix/descrizione-breve yaml Copia codice 2. Apporta le modifiche \u00b6 lavora solo sui file rilevanti mantieni le modifiche focalizzate rispetta struttura e template 3. Apri una Pull Request \u00b6 La Pull Request deve includere: descrizione chiara del cambiamento motivazione tecnica riferimento alla lezione/modulo coinvolto Pull Request vaghe o senza contesto verranno rifiutate . 4. Revisione della community \u00b6 Una Pull Request viene accettata solo se: \u00e8 tecnicamente corretta \u00e8 coerente con il corso \u00e8 chiara e ben spiegata ottiene l\u2019approvazione di almeno 50% + 1 degli studenti La revisione avviene tramite: - commenti - richieste di modifica - approvazioni GitHub 5. Approvazione finale \u00b6 Dopo il raggiungimento di 50% + 1 : - la Pull Request pu\u00f2 essere unita - il maintainer del corso (painic) ha l\u2019ultima parola tecnica Casi particolari \u00b6 Modifiche strutturali \u00b6 cambi di modello dati riorganizzazione moduli modifiche al template \ud83d\udc49 richiedono discussione preventiva e consenso esplicito. Correzioni urgenti \u00b6 errori concettuali gravi informazioni errate \ud83d\udc49 possono essere approvate pi\u00f9 rapidamente. Buone pratiche \u00b6 una PR = un obiettivo preferire modifiche piccole ma chiare discutere prima cambiamenti grandi documentare sempre il perch\u00e9","title":"Workflow di contribuzione"},{"location":"corsi/corso-database-sql/community/workflow/#workflow-di-contribuzione","text":"Questo documento descrive il processo operativo per proporre modifiche alla documentazione del corso. Tutte le modifiche passano tramite Git e GitHub .","title":"Workflow di contribuzione"},{"location":"corsi/corso-database-sql/community/workflow/#strumenti","text":"repository GitHub: itsfantastici/docs branch principale: main contributi tramite Pull Request Non sono consentite modifiche dirette su main .","title":"Strumenti"},{"location":"corsi/corso-database-sql/community/workflow/#flusso-di-lavoro","text":"","title":"Flusso di lavoro"},{"location":"corsi/corso-database-sql/community/workflow/#1-fork-o-branch","text":"crea un fork del repository oppure crea un branch dedicato Nome branch consigliato: feature/nome-breve fix/descrizione-breve yaml Copia codice","title":"1. Fork o branch"},{"location":"corsi/corso-database-sql/community/workflow/#2-apporta-le-modifiche","text":"lavora solo sui file rilevanti mantieni le modifiche focalizzate rispetta struttura e template","title":"2. Apporta le modifiche"},{"location":"corsi/corso-database-sql/community/workflow/#3-apri-una-pull-request","text":"La Pull Request deve includere: descrizione chiara del cambiamento motivazione tecnica riferimento alla lezione/modulo coinvolto Pull Request vaghe o senza contesto verranno rifiutate .","title":"3. Apri una Pull Request"},{"location":"corsi/corso-database-sql/community/workflow/#4-revisione-della-community","text":"Una Pull Request viene accettata solo se: \u00e8 tecnicamente corretta \u00e8 coerente con il corso \u00e8 chiara e ben spiegata ottiene l\u2019approvazione di almeno 50% + 1 degli studenti La revisione avviene tramite: - commenti - richieste di modifica - approvazioni GitHub","title":"4. Revisione della community"},{"location":"corsi/corso-database-sql/community/workflow/#5-approvazione-finale","text":"Dopo il raggiungimento di 50% + 1 : - la Pull Request pu\u00f2 essere unita - il maintainer del corso (painic) ha l\u2019ultima parola tecnica","title":"5. Approvazione finale"},{"location":"corsi/corso-database-sql/community/workflow/#casi-particolari","text":"","title":"Casi particolari"},{"location":"corsi/corso-database-sql/community/workflow/#modifiche-strutturali","text":"cambi di modello dati riorganizzazione moduli modifiche al template \ud83d\udc49 richiedono discussione preventiva e consenso esplicito.","title":"Modifiche strutturali"},{"location":"corsi/corso-database-sql/community/workflow/#correzioni-urgenti","text":"errori concettuali gravi informazioni errate \ud83d\udc49 possono essere approvate pi\u00f9 rapidamente.","title":"Correzioni urgenti"},{"location":"corsi/corso-database-sql/community/workflow/#buone-pratiche","text":"una PR = un obiettivo preferire modifiche piccole ma chiare discutere prima cambiamenti grandi documentare sempre il perch\u00e9","title":"Buone pratiche"},{"location":"corsi/corso-database-sql/moduli/","text":"Moduli del corso \u00b6 Il corso Database SQL \u00e8 strutturato in moduli progressivi . Ogni modulo: - introduce nuovi concetti - risolve problemi che emergono dal progetto - estende ci\u00f2 che \u00e8 stato costruito nei moduli precedenti Non esistono moduli indipendenti: il corso \u00e8 cumulativo . Come usare i moduli \u00b6 segui i moduli in ordine non saltare le lezioni iniziali usa il progetto come riferimento costante confronta teoria, esempi ed esercizi con il modello dati Elenco dei moduli \u00b6 \ud83d\udcd8 Modulo 01 \u2014 Fondamenti dei database \u00b6 Costruisce il modello mentale corretto . Contenuti chiave: - cos\u2019\u00e8 un database - modello relazionale - entit\u00e0, relazioni e vincoli - primo schema reale - primo contatto con SQL \ud83d\udc49 Vai al modulo \ud83d\udcd7 Modulo 02 \u2014 Query SQL \u00b6 Introduce la lettura e interrogazione avanzata dei dati . Contenuti chiave: - JOIN - aggregazioni - GROUP BY e HAVING - VIEW - gestione dei conflitti (UPSERT) \ud83d\udc49 Vai al modulo \ud83d\udcd9 Modulo 03 \u2014 Schema e performance \u00b6 Si concentra su qualit\u00e0 e prestazioni . Contenuti chiave: - indici - EXPLAIN - vincoli utili - soft delete - migrazioni di schema \ud83d\udc49 Vai al modulo \ud83d\udcd5 Modulo 04 \u2014 Migrazione e produzione \u00b6 Affronta il passaggio da progetto didattico a sistema reale . Contenuti chiave: - transazioni - concorrenza - differenze SQLite / MySQL - utenti e permessi - backup e manutenzione \ud83d\udc49 Vai al modulo Output complessivo del corso \u00b6 Al termine di tutti i moduli, lo studente avr\u00e0: un modello dati solido query SQL leggibili ed efficienti consapevolezza dei trade-off progettuali capacit\u00e0 di passare da prototipo a produzione esperienza di lavoro collaborativo su documentazione tecnica Navigazione \u00b6 Home corso Progetto Community Changelog","title":"Moduli del corso"},{"location":"corsi/corso-database-sql/moduli/#moduli-del-corso","text":"Il corso Database SQL \u00e8 strutturato in moduli progressivi . Ogni modulo: - introduce nuovi concetti - risolve problemi che emergono dal progetto - estende ci\u00f2 che \u00e8 stato costruito nei moduli precedenti Non esistono moduli indipendenti: il corso \u00e8 cumulativo .","title":"Moduli del corso"},{"location":"corsi/corso-database-sql/moduli/#come-usare-i-moduli","text":"segui i moduli in ordine non saltare le lezioni iniziali usa il progetto come riferimento costante confronta teoria, esempi ed esercizi con il modello dati","title":"Come usare i moduli"},{"location":"corsi/corso-database-sql/moduli/#elenco-dei-moduli","text":"","title":"Elenco dei moduli"},{"location":"corsi/corso-database-sql/moduli/#modulo-01-fondamenti-dei-database","text":"Costruisce il modello mentale corretto . Contenuti chiave: - cos\u2019\u00e8 un database - modello relazionale - entit\u00e0, relazioni e vincoli - primo schema reale - primo contatto con SQL \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd8 Modulo 01 \u2014 Fondamenti dei database"},{"location":"corsi/corso-database-sql/moduli/#modulo-02-query-sql","text":"Introduce la lettura e interrogazione avanzata dei dati . Contenuti chiave: - JOIN - aggregazioni - GROUP BY e HAVING - VIEW - gestione dei conflitti (UPSERT) \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd7 Modulo 02 \u2014 Query SQL"},{"location":"corsi/corso-database-sql/moduli/#modulo-03-schema-e-performance","text":"Si concentra su qualit\u00e0 e prestazioni . Contenuti chiave: - indici - EXPLAIN - vincoli utili - soft delete - migrazioni di schema \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd9 Modulo 03 \u2014 Schema e performance"},{"location":"corsi/corso-database-sql/moduli/#modulo-04-migrazione-e-produzione","text":"Affronta il passaggio da progetto didattico a sistema reale . Contenuti chiave: - transazioni - concorrenza - differenze SQLite / MySQL - utenti e permessi - backup e manutenzione \ud83d\udc49 Vai al modulo","title":"\ud83d\udcd5 Modulo 04 \u2014 Migrazione e produzione"},{"location":"corsi/corso-database-sql/moduli/#output-complessivo-del-corso","text":"Al termine di tutti i moduli, lo studente avr\u00e0: un modello dati solido query SQL leggibili ed efficienti consapevolezza dei trade-off progettuali capacit\u00e0 di passare da prototipo a produzione esperienza di lavoro collaborativo su documentazione tecnica","title":"Output complessivo del corso"},{"location":"corsi/corso-database-sql/moduli/#navigazione","text":"Home corso Progetto Community Changelog","title":"Navigazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/","text":"Modulo 01 \u2014 Fondamenti dei database \u00b6 Questo modulo introduce i concetti fondamentali necessari per comprendere e progettare un database relazionale. Non si parte dalla sintassi, ma dalla struttura mentale corretta : capire cosa stiamo costruendo prima di imparare come interrogarlo. Tutto ci\u00f2 che verr\u00e0 fatto nei moduli successivi dipende direttamente da questo modulo. Perch\u00e9 questo modulo \u00e8 fondamentale \u00b6 Senza una comprensione chiara di: - entit\u00e0 - relazioni - vincoli - integrit\u00e0 dei dati qualsiasi utilizzo di SQL diventa: - fragile - difficile da mantenere - impossibile da scalare Questo modulo serve a prevenire errori strutturali , non a imparare comandi a memoria. Obiettivi di apprendimento \u00b6 Al termine di questo modulo lo studente sar\u00e0 in grado di: spiegare cos\u2019\u00e8 un database e perch\u00e9 \u00e8 necessario distinguere database relazionali e non relazionali modellare entit\u00e0 e relazioni in modo corretto comprendere il ruolo di: primary key foreign key vincoli leggere, valutare e motivare un modello dati comprendere il ruolo di SQL come strumento, non come fine Collegamento con il progetto \u00b6 In questo modulo: viene introdotto il problema iniziale vengono definiti requisiti e vincoli viene costruito il modello dati iniziale si realizza la prima implementazione reale dello schema Il progetto nasce qui e non verr\u00e0 mai resettato . Contenuti del modulo \u00b6 Lezione 01 \u2014 Introduzione ai database \u00b6 problema: comprendere cos\u2019\u00e8 un database e perch\u00e9 serve oltre ai file teoria: cos\u2019\u00e8 un database perch\u00e9 i file non bastano modello relazionale entit\u00e0, relazioni e vincoli definizione del modello concettuale del progetto esempi pratici: confronto tra file e database esempio di entit\u00e0 e relazioni del progetto esercizi: identificare entit\u00e0 e relazioni dal problema definire i vincoli principali soluzione community e best practice \ud83d\udc49 Vai alla lezione Lezione 02 \u2014 Primo contatto con SQL \u00b6 problema: passare dal modello concettuale a uno schema reale interrogabile teoria: cos\u2019\u00e8 SQL e perch\u00e9 \u00e8 dichiarativo schema del database tipi di dato (DB-agnostic) operazioni CRUD esempi pratici: CREATE per tabelle del progetto INSERT di dati di esempio SELECT mirate UPDATE e DELETE con WHERE esercizi: definire lo schema completo del progetto scrivere query CRUD con vincoli corretti verificare errori di integrit\u00e0 referenziale soluzione community e best practice \ud83d\udc49 Vai alla lezione Lezione 03 \u2014 Relazioni e JOIN \u00b6 problema: perch\u00e9 servono le JOIN teoria: INNER JOIN e LEFT JOIN alias e naming esempi pratici: post con autore commenti con autore e post post anche senza commenti ( LEFT JOIN + COUNT ) esercizi: post + autore commenti dettagliati post senza commenti soluzione community e best practice \ud83d\udc49 Vai alla lezione Output del modulo \u00b6 Alla fine del modulo esistono: un problema ben definito un insieme di requisiti espliciti un modello dati coerente una prima implementazione reale un linguaggio tecnico condiviso tra tutti i partecipanti Questi elementi costituiscono la base tecnica comune dell\u2019intero corso. Errori comuni da evitare \u00b6 saltare la modellazione per \u201candare subito su SQL\u201d confondere tabelle con entit\u00e0 concettuali ignorare i vincoli pensando di gestirli \u201ca codice\u201d duplicare dati per comodit\u00e0 pensare che SQL sia solo sintassi Questo modulo serve a costruire fondamenta solide . Navigazione \u00b6 Progetto Lezione 01 Lezione 02 Lezione 03 Glossario Moduli","title":"Indice"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#modulo-01-fondamenti-dei-database","text":"Questo modulo introduce i concetti fondamentali necessari per comprendere e progettare un database relazionale. Non si parte dalla sintassi, ma dalla struttura mentale corretta : capire cosa stiamo costruendo prima di imparare come interrogarlo. Tutto ci\u00f2 che verr\u00e0 fatto nei moduli successivi dipende direttamente da questo modulo.","title":"Modulo 01 \u2014 Fondamenti dei database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#perche-questo-modulo-e-fondamentale","text":"Senza una comprensione chiara di: - entit\u00e0 - relazioni - vincoli - integrit\u00e0 dei dati qualsiasi utilizzo di SQL diventa: - fragile - difficile da mantenere - impossibile da scalare Questo modulo serve a prevenire errori strutturali , non a imparare comandi a memoria.","title":"Perch\u00e9 questo modulo \u00e8 fondamentale"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#obiettivi-di-apprendimento","text":"Al termine di questo modulo lo studente sar\u00e0 in grado di: spiegare cos\u2019\u00e8 un database e perch\u00e9 \u00e8 necessario distinguere database relazionali e non relazionali modellare entit\u00e0 e relazioni in modo corretto comprendere il ruolo di: primary key foreign key vincoli leggere, valutare e motivare un modello dati comprendere il ruolo di SQL come strumento, non come fine","title":"Obiettivi di apprendimento"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#collegamento-con-il-progetto","text":"In questo modulo: viene introdotto il problema iniziale vengono definiti requisiti e vincoli viene costruito il modello dati iniziale si realizza la prima implementazione reale dello schema Il progetto nasce qui e non verr\u00e0 mai resettato .","title":"Collegamento con il progetto"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#contenuti-del-modulo","text":"","title":"Contenuti del modulo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#lezione-01-introduzione-ai-database","text":"problema: comprendere cos\u2019\u00e8 un database e perch\u00e9 serve oltre ai file teoria: cos\u2019\u00e8 un database perch\u00e9 i file non bastano modello relazionale entit\u00e0, relazioni e vincoli definizione del modello concettuale del progetto esempi pratici: confronto tra file e database esempio di entit\u00e0 e relazioni del progetto esercizi: identificare entit\u00e0 e relazioni dal problema definire i vincoli principali soluzione community e best practice \ud83d\udc49 Vai alla lezione","title":"Lezione 01 \u2014 Introduzione ai database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#lezione-02-primo-contatto-con-sql","text":"problema: passare dal modello concettuale a uno schema reale interrogabile teoria: cos\u2019\u00e8 SQL e perch\u00e9 \u00e8 dichiarativo schema del database tipi di dato (DB-agnostic) operazioni CRUD esempi pratici: CREATE per tabelle del progetto INSERT di dati di esempio SELECT mirate UPDATE e DELETE con WHERE esercizi: definire lo schema completo del progetto scrivere query CRUD con vincoli corretti verificare errori di integrit\u00e0 referenziale soluzione community e best practice \ud83d\udc49 Vai alla lezione","title":"Lezione 02 \u2014 Primo contatto con SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#lezione-03-relazioni-e-join","text":"problema: perch\u00e9 servono le JOIN teoria: INNER JOIN e LEFT JOIN alias e naming esempi pratici: post con autore commenti con autore e post post anche senza commenti ( LEFT JOIN + COUNT ) esercizi: post + autore commenti dettagliati post senza commenti soluzione community e best practice \ud83d\udc49 Vai alla lezione","title":"Lezione 03 \u2014 Relazioni e JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#output-del-modulo","text":"Alla fine del modulo esistono: un problema ben definito un insieme di requisiti espliciti un modello dati coerente una prima implementazione reale un linguaggio tecnico condiviso tra tutti i partecipanti Questi elementi costituiscono la base tecnica comune dell\u2019intero corso.","title":"Output del modulo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#errori-comuni-da-evitare","text":"saltare la modellazione per \u201candare subito su SQL\u201d confondere tabelle con entit\u00e0 concettuali ignorare i vincoli pensando di gestirli \u201ca codice\u201d duplicare dati per comodit\u00e0 pensare che SQL sia solo sintassi Questo modulo serve a costruire fondamenta solide .","title":"Errori comuni da evitare"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/#navigazione","text":"Progetto Lezione 01 Lezione 02 Lezione 03 Glossario Moduli","title":"Navigazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/","text":"Esercizio 3.1 \u2014 Spiegazione \u00b6 In questo esercizio abbiamo costruito un database relazionale completo , applicando i concetti fondamentali di SQL visti a lezione. 1\ufe0f\u20e3 Creazione delle tabelle \u00b6 Tabella students \u00b6 Rappresenta gli studenti. id \u00e8 la chiave primaria ed \u00e8 autoincrementale name ed email sono obbligatori surname pu\u00f2 essere vuoto Questo garantisce che ogni studente sia identificabile in modo univoco. Tabella classes \u00b6 Rappresenta i corsi. name \u00e8 UNIQUE , quindi non possono esistere due corsi con lo stesso nome hours indica il numero di ore del corso cfu \u00e8 facoltativo Tabella students_classes \u00b6 Serve a modellare una relazione molti-a-molti : - uno studente pu\u00f2 seguire pi\u00f9 corsi - un corso pu\u00f2 avere pi\u00f9 studenti Questa tabella contiene: - due chiavi esterne - nessun dato descrittivo, solo relazioni 2\ufe0f\u20e3 Inserimento dei dati \u00b6 Abbiamo usato INSERT INTO ... VALUES per: - popolare la tabella students - popolare la tabella classes - creare le iscrizioni nella tabella students_classes Ogni riga in students_classes rappresenta un\u2019iscrizione di uno studente a un corso . 3\ufe0f\u20e3 Visualizzazione delle tabelle \u00b6 Per verificare i dati abbiamo usato: SELECT * FROM students ; SELECT * FROM classes ; SELECT * FROM students_classes ; Questo passaggio \u00e8 fondamentale per: controllare errori verificare le relazioni capire se il modello funziona correttamente 4\ufe0f\u20e3 Join tra tabelle \u00b6 Per ottenere informazioni leggibili abbiamo usato una query con JOIN . SELECT students . name AS nome , students . surname AS cognome , classes . name AS nome_classe FROM students_classes JOIN students ON students_classes . students_id = students . id JOIN classes ON students_classes . classes_id = classes . id ; Questa query: parte dalla tabella di collegamento recupera i dati reali dalle tabelle students e classes restituisce una vista \u201cumana\u201d dei dati","title":"Esercizio 3.1 \u2014 Spiegazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#esercizio-31-spiegazione","text":"In questo esercizio abbiamo costruito un database relazionale completo , applicando i concetti fondamentali di SQL visti a lezione.","title":"Esercizio 3.1 \u2014 Spiegazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#1-creazione-delle-tabelle","text":"","title":"1\ufe0f\u20e3 Creazione delle tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#tabella-students","text":"Rappresenta gli studenti. id \u00e8 la chiave primaria ed \u00e8 autoincrementale name ed email sono obbligatori surname pu\u00f2 essere vuoto Questo garantisce che ogni studente sia identificabile in modo univoco.","title":"Tabella students"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#tabella-classes","text":"Rappresenta i corsi. name \u00e8 UNIQUE , quindi non possono esistere due corsi con lo stesso nome hours indica il numero di ore del corso cfu \u00e8 facoltativo","title":"Tabella classes"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#tabella-students_classes","text":"Serve a modellare una relazione molti-a-molti : - uno studente pu\u00f2 seguire pi\u00f9 corsi - un corso pu\u00f2 avere pi\u00f9 studenti Questa tabella contiene: - due chiavi esterne - nessun dato descrittivo, solo relazioni","title":"Tabella students_classes"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#2-inserimento-dei-dati","text":"Abbiamo usato INSERT INTO ... VALUES per: - popolare la tabella students - popolare la tabella classes - creare le iscrizioni nella tabella students_classes Ogni riga in students_classes rappresenta un\u2019iscrizione di uno studente a un corso .","title":"2\ufe0f\u20e3 Inserimento dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#3-visualizzazione-delle-tabelle","text":"Per verificare i dati abbiamo usato: SELECT * FROM students ; SELECT * FROM classes ; SELECT * FROM students_classes ; Questo passaggio \u00e8 fondamentale per: controllare errori verificare le relazioni capire se il modello funziona correttamente","title":"3\ufe0f\u20e3 Visualizzazione delle tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/esercizio-03-01/#4-join-tra-tabelle","text":"Per ottenere informazioni leggibili abbiamo usato una query con JOIN . SELECT students . name AS nome , students . surname AS cognome , classes . name AS nome_classe FROM students_classes JOIN students ON students_classes . students_id = students . id JOIN classes ON students_classes . classes_id = classes . id ; Questa query: parte dalla tabella di collegamento recupera i dati reali dalle tabelle students e classes restituisce una vista \u201cumana\u201d dei dati","title":"4\ufe0f\u20e3 Join tra tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/","text":"Glossario \u2014 Modulo 01: Fondamenti dei database \u00b6 Questo glossario raccoglie i termini fondamentali introdotti nel Modulo 01 . Le definizioni sono: - intenzionalmente precise - coerenti con il corso - pensate per essere riutilizzate nei moduli successivi Database \u00b6 Collezione organizzata di dati progettata per essere memorizzata, interrogata e mantenuta in modo coerente e affidabile. Un database non \u00e8 solo storage, ma un sistema che impone regole sui dati. Database relazionale \u00b6 Tipo di database che organizza i dati in tabelle collegate tra loro tramite relazioni esplicite. Le relazioni sono implementate tramite chiavi e vincoli. Tabella \u00b6 Struttura che rappresenta un insieme di entit\u00e0 omogenee. \u00c8 composta da righe (record) e colonne (campi). Record (riga) \u00b6 Singola istanza di un\u2019entit\u00e0 all\u2019interno di una tabella. Ogni record rappresenta un elemento specifico (es. un utente). Campo (colonna) \u00b6 Propriet\u00e0 di un\u2019entit\u00e0. Ogni campo ha: - un nome - un tipo di dato - eventuali vincoli Schema \u00b6 Definizione strutturale del database. Include: - tabelle - campi - tipi di dato - vincoli - relazioni Entit\u00e0 \u00b6 Concetto astratto che rappresenta qualcosa di rilevante nel dominio del problema. Un\u2019entit\u00e0 diventa una tabella quando viene implementata in un database relazionale. Relazione \u00b6 Collegamento logico tra due entit\u00e0. Nel database relazionale \u00e8 implementata tramite foreign key o tabelle di collegamento. Primary Key (PK) \u00b6 Campo o insieme di campi che identifica univocamente un record in una tabella. Una primary key: - \u00e8 unica - non pu\u00f2 essere NULL - \u00e8 stabile nel tempo Foreign Key (FK) \u00b6 Campo che fa riferimento alla primary key di un\u2019altra tabella. Serve a: - creare relazioni - garantire integrit\u00e0 referenziale Vincolo (Constraint) \u00b6 Regola applicata dal database per impedire stati invalidi dei dati. Esempi: - PRIMARY KEY - FOREIGN KEY - UNIQUE - NOT NULL Integrit\u00e0 dei dati \u00b6 Propriet\u00e0 che garantisce che i dati siano corretti, coerenti e consistenti nel tempo. \u00c8 garantita tramite vincoli e regole del database. Modello dei dati \u00b6 Rappresentazione strutturata delle entit\u00e0, delle relazioni e dei vincoli del sistema. Pu\u00f2 essere: - concettuale - logico - fisico SQL (Structured Query Language) \u00b6 Linguaggio standard per interagire con database relazionali. SQL \u00e8 dichiarativo: descrive cosa ottenere, non come ottenerlo. Query \u00b6 Richiesta inviata al database per leggere o modificare dati. Una query pu\u00f2 essere: - di lettura ( SELECT ) - di modifica ( INSERT , UPDATE , DELETE ) - di definizione ( CREATE , ALTER , DROP ) CRUD \u00b6 Acronimo che identifica le quattro operazioni fondamentali sui dati: Create Read Update Delete DB-agnostic \u00b6 Approccio che evita dipendenze da un database specifico. Un modello o una query DB-agnostic pu\u00f2 essere eseguita su pi\u00f9 database con minime o nessune modifiche. Normalizzazione \u00b6 Processo di organizzazione dei dati per ridurre duplicazioni e anomalie. \u00c8 una conseguenza di una corretta modellazione, non un obiettivo fine a s\u00e9 stesso. Transazione \u00b6 Gruppo di operazioni eseguite come un\u2019unica unit\u00e0 logica. Una transazione \u00e8: - atomica - consistente - isolata - durabile (ACID) Progetto unico \u00b6 Approccio didattico in cui tutte le lezioni contribuiscono allo sviluppo di un unico sistema coerente. Il progetto evolve, ma non viene mai azzerato.","title":"Glossario"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#glossario-modulo-01-fondamenti-dei-database","text":"Questo glossario raccoglie i termini fondamentali introdotti nel Modulo 01 . Le definizioni sono: - intenzionalmente precise - coerenti con il corso - pensate per essere riutilizzate nei moduli successivi","title":"Glossario \u2014 Modulo 01: Fondamenti dei database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#database","text":"Collezione organizzata di dati progettata per essere memorizzata, interrogata e mantenuta in modo coerente e affidabile. Un database non \u00e8 solo storage, ma un sistema che impone regole sui dati.","title":"Database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#database-relazionale","text":"Tipo di database che organizza i dati in tabelle collegate tra loro tramite relazioni esplicite. Le relazioni sono implementate tramite chiavi e vincoli.","title":"Database relazionale"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#tabella","text":"Struttura che rappresenta un insieme di entit\u00e0 omogenee. \u00c8 composta da righe (record) e colonne (campi).","title":"Tabella"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#record-riga","text":"Singola istanza di un\u2019entit\u00e0 all\u2019interno di una tabella. Ogni record rappresenta un elemento specifico (es. un utente).","title":"Record (riga)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#campo-colonna","text":"Propriet\u00e0 di un\u2019entit\u00e0. Ogni campo ha: - un nome - un tipo di dato - eventuali vincoli","title":"Campo (colonna)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#schema","text":"Definizione strutturale del database. Include: - tabelle - campi - tipi di dato - vincoli - relazioni","title":"Schema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#entita","text":"Concetto astratto che rappresenta qualcosa di rilevante nel dominio del problema. Un\u2019entit\u00e0 diventa una tabella quando viene implementata in un database relazionale.","title":"Entit\u00e0"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#relazione","text":"Collegamento logico tra due entit\u00e0. Nel database relazionale \u00e8 implementata tramite foreign key o tabelle di collegamento.","title":"Relazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#primary-key-pk","text":"Campo o insieme di campi che identifica univocamente un record in una tabella. Una primary key: - \u00e8 unica - non pu\u00f2 essere NULL - \u00e8 stabile nel tempo","title":"Primary Key (PK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#foreign-key-fk","text":"Campo che fa riferimento alla primary key di un\u2019altra tabella. Serve a: - creare relazioni - garantire integrit\u00e0 referenziale","title":"Foreign Key (FK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#vincolo-constraint","text":"Regola applicata dal database per impedire stati invalidi dei dati. Esempi: - PRIMARY KEY - FOREIGN KEY - UNIQUE - NOT NULL","title":"Vincolo (Constraint)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#integrita-dei-dati","text":"Propriet\u00e0 che garantisce che i dati siano corretti, coerenti e consistenti nel tempo. \u00c8 garantita tramite vincoli e regole del database.","title":"Integrit\u00e0 dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#modello-dei-dati","text":"Rappresentazione strutturata delle entit\u00e0, delle relazioni e dei vincoli del sistema. Pu\u00f2 essere: - concettuale - logico - fisico","title":"Modello dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#sql-structured-query-language","text":"Linguaggio standard per interagire con database relazionali. SQL \u00e8 dichiarativo: descrive cosa ottenere, non come ottenerlo.","title":"SQL (Structured Query Language)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#query","text":"Richiesta inviata al database per leggere o modificare dati. Una query pu\u00f2 essere: - di lettura ( SELECT ) - di modifica ( INSERT , UPDATE , DELETE ) - di definizione ( CREATE , ALTER , DROP )","title":"Query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#crud","text":"Acronimo che identifica le quattro operazioni fondamentali sui dati: Create Read Update Delete","title":"CRUD"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#db-agnostic","text":"Approccio che evita dipendenze da un database specifico. Un modello o una query DB-agnostic pu\u00f2 essere eseguita su pi\u00f9 database con minime o nessune modifiche.","title":"DB-agnostic"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#normalizzazione","text":"Processo di organizzazione dei dati per ridurre duplicazioni e anomalie. \u00c8 una conseguenza di una corretta modellazione, non un obiettivo fine a s\u00e9 stesso.","title":"Normalizzazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#transazione","text":"Gruppo di operazioni eseguite come un\u2019unica unit\u00e0 logica. Una transazione \u00e8: - atomica - consistente - isolata - durabile (ACID)","title":"Transazione"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/glossary/#progetto-unico","text":"Approccio didattico in cui tutte le lezioni contribuiscono allo sviluppo di un unico sistema coerente. Il progetto evolve, ma non viene mai azzerato.","title":"Progetto unico"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/","text":"Lezione 01 \u2014 Introduzione ai database \u00b6 Problema \u00b6 Stiamo sviluppando un sistema informatico che deve gestire dati reali: - utenti - contenuti creati dagli utenti - relazioni tra utenti e contenuti All\u2019inizio potremmo pensare di usare semplici file ( .txt , .csv , .json ), ma emergono subito problemi concreti: come garantiamo che i dati siano coerenti? come evitiamo duplicazioni? come gestiamo pi\u00f9 utenti che accedono agli stessi dati? come modelliamo relazioni complesse (es. utenti \u2192 post \u2192 commenti)? Problema centrale: come memorizzare, organizzare e interrogare dati in modo strutturato, scalabile e affidabile? Questa lezione introduce lo strumento che useremo per risolvere il problema: il database . Teoria \u00b6 Cos\u2019\u00e8 un database \u00b6 Un database \u00e8 una collezione organizzata di dati progettata per: memorizzare informazioni in modo strutturato permettere accesso efficiente ai dati garantire coerenza e integrit\u00e0 supportare accesso concorrente Un database non \u00e8 solo storage , ma un sistema che impone regole. Perch\u00e9 non bastano i file \u00b6 L\u2019uso di file presenta limiti strutturali: nessuna garanzia di unicit\u00e0 relazioni gestite \u201ca mano\u201d difficolt\u00e0 di accesso concorrente ricerca inefficiente su grandi volumi di dati assenza di vincoli formali Un database introduce regole esplicite che impediscono stati inconsistenti. Tipi di database \u00b6 Database relazionali (SQL) \u00b6 dati organizzati in tabelle struttura definita (schema) relazioni esplicite tra dati linguaggio SQL per interrogazione Esempi: SQLite, MySQL, PostgreSQL. Database non relazionali (NoSQL) \u00b6 struttura pi\u00f9 flessibile modelli diversi (documenti, key-value, grafi) utili in contesti specifici \ud83d\udc49 In questo corso useremo database relazionali . Tabelle, righe e colonne \u00b6 Una tabella rappresenta un insieme di entit\u00e0 omogenee. Riga (record) : una singola entit\u00e0 Colonna (campo) : una propriet\u00e0 dell\u2019entit\u00e0 Esempio concettuale: id username email 1 alice alice@example.com Chiavi e vincoli \u00b6 Primary Key (PK) \u00b6 identifica univocamente ogni riga non pu\u00f2 essere NULL non pu\u00f2 duplicarsi Serve per: distinguere i record creare relazioni Foreign Key (FK) \u00b6 riferimento a una PK di un\u2019altra tabella impone coerenza tra tabelle Vincoli \u00b6 Regole applicate dal database: PRIMARY KEY FOREIGN KEY UNIQUE NOT NULL Obiettivo: integrit\u00e0 dei dati . Relazioni tra tabelle (logica in SQL) \u00b6 In un database relazionale, una relazione tra due \u201centit\u00e0\u201d non \u00e8 un collegamento \u201cmagico\u201d: viene rappresentata tramite valori e vincoli . Prima ragioniamo a livello logico (modello) identifichiamo le entit\u00e0 (es. users , posts , comments ) decidiamo le cardinalit\u00e0 (1:1, 1:N, N:M) scegliamo quali dati identificano un record ( Primary Key ) Poi traduciamo il modello in SQL (implementazione) usiamo Primary Key (PK) per identificare univocamente le righe usiamo Foreign Key (FK) per \u201cpuntare\u201d a una PK di un\u2019altra tabella applichiamo vincoli per evitare stati incoerenti (es. FK che punta a un record inesistente) Di fatto, la relazione \u00e8 il fatto che una colonna contiene l\u2019identificatore (PK) di un\u2019altra tabella , e il database pu\u00f2 far rispettare questa regola con una FK. One-to-One (1:1) \u00b6 Idea logica: un record di A corrisponde a al massimo un record di B (e viceversa). In SQL: si usa una FK con vincolo UNIQUE (oppure si condivide la stessa PK). Esempio (profilo utente separato): CREATE TABLE user_profiles ( user_id INTEGER PRIMARY KEY , bio TEXT , FOREIGN KEY ( user_id ) REFERENCES users ( id ) ); Qui user_id \u00e8 anche PK: garantisce un solo profilo per utente . One-to-Many (1:N) \u00b6 Idea logica: un record di A pu\u00f2 essere associato a molti record di B, ma ogni record di B appartiene a un solo record di A. In SQL: la FK sta nella tabella \u201cmolti\u201d. Esempio (un utente pu\u00f2 avere molti post): CREATE TABLE posts ( id INTEGER PRIMARY KEY , user_id INTEGER NOT NULL , title TEXT NOT NULL , FOREIGN KEY ( user_id ) REFERENCES users ( id ) ); posts.user_id collega ogni post a un utente, mentre lo stesso utente pu\u00f2 comparire in molte righe di posts . Many-to-Many (N:M) \u00b6 Idea logica: molti record di A possono essere associati a molti record di B. In SQL: non si mette una FK \u201cdiretta\u201d da una parte all\u2019altra: si crea una tabella ponte (junction table) con due FK . Esempio (utenti che mettono \u201clike\u201d ai post): CREATE TABLE post_likes ( user_id INTEGER NOT NULL , post_id INTEGER NOT NULL , PRIMARY KEY ( user_id , post_id ), FOREIGN KEY ( user_id ) REFERENCES users ( id ), FOREIGN KEY ( post_id ) REFERENCES posts ( id ) ); ogni riga rappresenta una singola associazione (utente, post) la PRIMARY KEY (user_id, post_id) impedisce duplicati (stesso like ripetuto) Nota importante: le FK servono a mantenere l\u2019integrit\u00e0 (coerenza) dei dati; le query ( JOIN ) servono a leggere le relazioni combinando le tabelle quando ti serve. Esempi \u00b6 Esempio: creare un nuovo database sqlite \u00b6 Per aggiornare gli indici dei pacchetti e installare SQLite su Ubuntu: sudo apt update sudo apt install -y sqlite3 Dopo l\u2019installazione puoi verificare la versione: sqlite3 --version sqlite3 nome_database.db Il file nome_database.db verr\u00e0 creato nella cartella corrente se non esiste. All\u2019interno della shell di SQLite puoi verificare con: . databases Per uscire: . exit Esempio: struttura dati del progetto \u00b6 Nel nostro progetto iniziale gestiremo: utenti post commenti Tabella users \u00b6 Creiamo la tabella utenti. CREATE TABLE users ( id INTEGER PRIMARY KEY , username TEXT NOT NULL UNIQUE , email TEXT NOT NULL UNIQUE , born_year INTEGER , born_month INTEGER , born_day INTEGER ); Qui: id identifica univocamente l\u2019utente UNIQUE e NOT NULL sono vincoli il database impedisce stati invalidi Tabella posts \u00b6 Creiamo la tabella posts. CREATE TABLE posts ( id INTEGER PRIMARY KEY , user_id INTEGER NOT NULL , title TEXT NOT NULL , content TEXT , FOREIGN KEY ( user_id ) REFERENCES users ( id ) ); La foreign key rende esplicita la relazione 1:N. Tabella Commments \u00b6 Creiamo la tabella commenti. CREATE TABLE comments ( id INTEGER PRIMARY KEY , user_id INTEGER NOT NULL , post_id INTEGER NOT NULL , content TEXT NOT NULL , FOREIGN KEY ( user_id ) REFERENCES users ( id ), FOREIGN KEY ( post_id ) REFERENCES posts ( id ) );","title":"Lezione 01 \u2014 Introduzione ai database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#lezione-01-introduzione-ai-database","text":"","title":"Lezione 01 \u2014 Introduzione ai database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#problema","text":"Stiamo sviluppando un sistema informatico che deve gestire dati reali: - utenti - contenuti creati dagli utenti - relazioni tra utenti e contenuti All\u2019inizio potremmo pensare di usare semplici file ( .txt , .csv , .json ), ma emergono subito problemi concreti: come garantiamo che i dati siano coerenti? come evitiamo duplicazioni? come gestiamo pi\u00f9 utenti che accedono agli stessi dati? come modelliamo relazioni complesse (es. utenti \u2192 post \u2192 commenti)? Problema centrale: come memorizzare, organizzare e interrogare dati in modo strutturato, scalabile e affidabile? Questa lezione introduce lo strumento che useremo per risolvere il problema: il database .","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#cose-un-database","text":"Un database \u00e8 una collezione organizzata di dati progettata per: memorizzare informazioni in modo strutturato permettere accesso efficiente ai dati garantire coerenza e integrit\u00e0 supportare accesso concorrente Un database non \u00e8 solo storage , ma un sistema che impone regole.","title":"Cos\u2019\u00e8 un database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#perche-non-bastano-i-file","text":"L\u2019uso di file presenta limiti strutturali: nessuna garanzia di unicit\u00e0 relazioni gestite \u201ca mano\u201d difficolt\u00e0 di accesso concorrente ricerca inefficiente su grandi volumi di dati assenza di vincoli formali Un database introduce regole esplicite che impediscono stati inconsistenti.","title":"Perch\u00e9 non bastano i file"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tipi-di-database","text":"","title":"Tipi di database"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#database-relazionali-sql","text":"dati organizzati in tabelle struttura definita (schema) relazioni esplicite tra dati linguaggio SQL per interrogazione Esempi: SQLite, MySQL, PostgreSQL.","title":"Database relazionali (SQL)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#database-non-relazionali-nosql","text":"struttura pi\u00f9 flessibile modelli diversi (documenti, key-value, grafi) utili in contesti specifici \ud83d\udc49 In questo corso useremo database relazionali .","title":"Database non relazionali (NoSQL)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabelle-righe-e-colonne","text":"Una tabella rappresenta un insieme di entit\u00e0 omogenee. Riga (record) : una singola entit\u00e0 Colonna (campo) : una propriet\u00e0 dell\u2019entit\u00e0 Esempio concettuale: id username email 1 alice alice@example.com","title":"Tabelle, righe e colonne"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#chiavi-e-vincoli","text":"","title":"Chiavi e vincoli"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#primary-key-pk","text":"identifica univocamente ogni riga non pu\u00f2 essere NULL non pu\u00f2 duplicarsi Serve per: distinguere i record creare relazioni","title":"Primary Key (PK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#foreign-key-fk","text":"riferimento a una PK di un\u2019altra tabella impone coerenza tra tabelle","title":"Foreign Key (FK)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#vincoli","text":"Regole applicate dal database: PRIMARY KEY FOREIGN KEY UNIQUE NOT NULL Obiettivo: integrit\u00e0 dei dati .","title":"Vincoli"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#relazioni-tra-tabelle-logica-in-sql","text":"In un database relazionale, una relazione tra due \u201centit\u00e0\u201d non \u00e8 un collegamento \u201cmagico\u201d: viene rappresentata tramite valori e vincoli . Prima ragioniamo a livello logico (modello) identifichiamo le entit\u00e0 (es. users , posts , comments ) decidiamo le cardinalit\u00e0 (1:1, 1:N, N:M) scegliamo quali dati identificano un record ( Primary Key ) Poi traduciamo il modello in SQL (implementazione) usiamo Primary Key (PK) per identificare univocamente le righe usiamo Foreign Key (FK) per \u201cpuntare\u201d a una PK di un\u2019altra tabella applichiamo vincoli per evitare stati incoerenti (es. FK che punta a un record inesistente) Di fatto, la relazione \u00e8 il fatto che una colonna contiene l\u2019identificatore (PK) di un\u2019altra tabella , e il database pu\u00f2 far rispettare questa regola con una FK.","title":"Relazioni tra tabelle (logica in SQL)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#one-to-one-11","text":"Idea logica: un record di A corrisponde a al massimo un record di B (e viceversa). In SQL: si usa una FK con vincolo UNIQUE (oppure si condivide la stessa PK). Esempio (profilo utente separato): CREATE TABLE user_profiles ( user_id INTEGER PRIMARY KEY , bio TEXT , FOREIGN KEY ( user_id ) REFERENCES users ( id ) ); Qui user_id \u00e8 anche PK: garantisce un solo profilo per utente .","title":"One-to-One (1:1)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#one-to-many-1n","text":"Idea logica: un record di A pu\u00f2 essere associato a molti record di B, ma ogni record di B appartiene a un solo record di A. In SQL: la FK sta nella tabella \u201cmolti\u201d. Esempio (un utente pu\u00f2 avere molti post): CREATE TABLE posts ( id INTEGER PRIMARY KEY , user_id INTEGER NOT NULL , title TEXT NOT NULL , FOREIGN KEY ( user_id ) REFERENCES users ( id ) ); posts.user_id collega ogni post a un utente, mentre lo stesso utente pu\u00f2 comparire in molte righe di posts .","title":"One-to-Many (1:N)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#many-to-many-nm","text":"Idea logica: molti record di A possono essere associati a molti record di B. In SQL: non si mette una FK \u201cdiretta\u201d da una parte all\u2019altra: si crea una tabella ponte (junction table) con due FK . Esempio (utenti che mettono \u201clike\u201d ai post): CREATE TABLE post_likes ( user_id INTEGER NOT NULL , post_id INTEGER NOT NULL , PRIMARY KEY ( user_id , post_id ), FOREIGN KEY ( user_id ) REFERENCES users ( id ), FOREIGN KEY ( post_id ) REFERENCES posts ( id ) ); ogni riga rappresenta una singola associazione (utente, post) la PRIMARY KEY (user_id, post_id) impedisce duplicati (stesso like ripetuto) Nota importante: le FK servono a mantenere l\u2019integrit\u00e0 (coerenza) dei dati; le query ( JOIN ) servono a leggere le relazioni combinando le tabelle quando ti serve.","title":"Many-to-Many (N:M)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#esempi","text":"","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#esempio-creare-un-nuovo-database-sqlite","text":"Per aggiornare gli indici dei pacchetti e installare SQLite su Ubuntu: sudo apt update sudo apt install -y sqlite3 Dopo l\u2019installazione puoi verificare la versione: sqlite3 --version sqlite3 nome_database.db Il file nome_database.db verr\u00e0 creato nella cartella corrente se non esiste. All\u2019interno della shell di SQLite puoi verificare con: . databases Per uscire: . exit","title":"Esempio: creare un nuovo database sqlite"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#esempio-struttura-dati-del-progetto","text":"Nel nostro progetto iniziale gestiremo: utenti post commenti","title":"Esempio: struttura dati del progetto"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabella-users","text":"Creiamo la tabella utenti. CREATE TABLE users ( id INTEGER PRIMARY KEY , username TEXT NOT NULL UNIQUE , email TEXT NOT NULL UNIQUE , born_year INTEGER , born_month INTEGER , born_day INTEGER ); Qui: id identifica univocamente l\u2019utente UNIQUE e NOT NULL sono vincoli il database impedisce stati invalidi","title":"Tabella users"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabella-posts","text":"Creiamo la tabella posts. CREATE TABLE posts ( id INTEGER PRIMARY KEY , user_id INTEGER NOT NULL , title TEXT NOT NULL , content TEXT , FOREIGN KEY ( user_id ) REFERENCES users ( id ) ); La foreign key rende esplicita la relazione 1:N.","title":"Tabella posts"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-01/#tabella-commments","text":"Creiamo la tabella commenti. CREATE TABLE comments ( id INTEGER PRIMARY KEY , user_id INTEGER NOT NULL , post_id INTEGER NOT NULL , content TEXT NOT NULL , FOREIGN KEY ( user_id ) REFERENCES users ( id ), FOREIGN KEY ( post_id ) REFERENCES posts ( id ) );","title":"Tabella Commments"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/","text":"Lezione 02 \u2014 Primo contatto con SQL \u00b6 Problema \u00b6 Abbiamo un modello concettuale ed abbiamo creato le tabelle utenti, posts e commenti. Ora dobbiamo trasformarlo in una struttura reale: inserire dati di esempio interrogare e modificare quei dati in modo controllato Obiettivo: passare da \u201cidea\u201d a \u201csistema interrogabile\u201d. Questo significa introdurre SQL come strumento operativo. Teoria \u00b6 Cos\u2019\u00e8 SQL \u00b6 SQL (Structured Query Language) \u00e8 il linguaggio standard usato per: definire la struttura del database inserire dati leggere dati modificarli cancellarli SQL non \u00e8 un linguaggio di programmazione generale , ma un linguaggio dichiarativo: dici cosa vuoi ottenere, non come ottenerlo. SQL: linguaggio dichiarativo \u00b6 SQL \u00e8 dichiarativo: descrive cosa vuoi ottenere, non come ottenerlo. In pratica lo useremo per: DDL (schema): CREATE , ALTER , DROP DML (dati): INSERT , SELECT , UPDATE , DELETE Il concetto di schema \u00b6 Lo schema rappresenta la struttura del database: tabelle colonne tipi di dato vincoli relazioni \u00c8 il passaggio formale dal modello logico all\u2019 implementazione fisica . Tipi di dato (DB-agnostic) \u00b6 Ogni colonna deve avere un tipo di dato. I tipi indicano: che valori sono ammessi come vengono memorizzati quali operazioni sono possibili I tipi di dato in DB-agnostic sono: - INTEGER - TEXT Di seguito una tabella riepilogativa dei principali tipi di dato, con la corrispondenza tra SQLite, MySQL e PostgreSQL e un\u2019indicazione della memoria occupata per campo. Tipo di dato SQLite MySQL PostgreSQL Memoria (indicativa) BOOLEAN INTEGER (0/1) BOOLEAN BOOLEAN 1 byte SMALLINT INTEGER SMALLINT SMALLINT 2 byte INTEGER INTEGER INT INTEGER 4 byte BIGINT INTEGER BIGINT BIGINT 8 byte DECIMAL/NUMERIC REAL / NUMERIC DECIMAL NUMERIC variabile REAL REAL FLOAT REAL 4 byte DOUBLE REAL DOUBLE DOUBLE PRECISION 8 byte CHAR TEXT CHAR CHAR fisso (n) VARCHAR TEXT VARCHAR VARCHAR variabile (n) TEXT TEXT TEXT TEXT variabile DATE TEXT / REAL DATE DATE 4 byte (PG), variabile TIME TEXT / REAL TIME TIME 8 byte (PG), variabile DATETIME TEXT / REAL DATETIME \u274c variabile TIMESTAMP TEXT / REAL TIMESTAMP TIMESTAMP 8 byte (PG), variabile BLOB/BINARY BLOB BLOB / BINARY BYTEA variabile JSON TEXT JSON JSON/JSONB variabile UUID TEXT \u274c UUID 16 byte CRUD \u00b6 Le operazioni fondamentali sui dati sono quattro: Operazione Significato SQL Create inserire dati INSERT Read leggere dati SELECT Update modificare dati UPDATE Delete cancellare dati DELETE Ogni sistema informativo, senza eccezioni, ruota attorno a queste operazioni. Query \u00b6 Una query \u00e8 una richiesta fatta al database. Caratteristiche: \u00e8 deterministica produce un risultato pu\u00f2 leggere o modificare dati La query pi\u00f9 comune \u00e8 SELECT . Esempi \u00b6 Usiamo SQLite (semplice e locale), ma cerchiamo di scrivere SQL standard e portabile quando possibile. Inserimento dei dati (INSERT) \u00b6 INSERT serve a creare nuove righe in una tabella. La forma pi\u00f9 comune \u00e8: INSERT INTO <table> (<colonne>) indica tabella e colonne da valorizzare VALUES (<valori>) indica i valori (nello stesso ordine delle colonne) Esempio: inseriamo un utente. INSERT INTO users ( username , email ) VALUES ( 'alice' , 'alice@example.com' ); Il database: assegna automaticamente la primary key (se id \u00e8 autoincrement) controlla i vincoli (es. NOT NULL , UNIQUE , CHECK ) controlla le foreign key (se abilitate/attive) Esempio: inseriamo un post collegato a un utente. INSERT INTO posts ( user_id , title , content ) VALUES ( 1 , 'Primo post' , 'Contenuto di esempio' ); Se user_id = 1 non esiste nella tabella users \u2192 errore di integrit\u00e0 referenziale (vincolo FK). Inserire pi\u00f9 righe in una sola query \u00b6 \u00c8 pi\u00f9 efficiente e riduce il numero di query. INSERT INTO users ( username , email , born_year , born_month , born_day ) VALUES ( 'bob' , 'bob@example.com' , 1999 , 10 , 1 ), ( 'rob' , 'rob@example.com' , 1999 , 1 , 10 ), ( 'carlo' , 'carlo@example.com' , 2000 , 7 , 22 ), ( 'dina' , 'dina@example.com' , 1997 , 11 , 5 ), ( 'elena' , 'elena@example.com' , 2001 , 1 , 9 ), ( 'franco' , 'franco@example.com' , 1995 , 9 , 30 ), ( 'giada' , 'giada@example.com' , 1996 , 12 , 14 ), ( 'luca' , 'luca@example.com' , 1999 , 4 , 2 ); Suggerimento: se stai inserendo dati \u201ccritici\u201d, considera l\u2019uso di transazioni ( BEGIN / COMMIT ) per rendere l\u2019operazione atomica. Lettura dei dati (SELECT) \u00b6 SELECT serve a leggere dati. Una query tipica \u00e8 composta da: SELECT <colonne> quali colonne vuoi vedere (oppure * per tutte) FROM <tabella> da dove leggere WHERE <condizioni> filtri (opzionale) ORDER BY <colonna> ASC|DESC ordinamento (opzionale) LIMIT <n> massimo numero di righe (opzionale) OFFSET <n> salta le prime n righe (opzionale, utile per paginazione) Nota: la sintassi corretta \u00e8 ORDER BY , non ORDERED BY . Selezionare tutte le righe \u00b6 SELECT * FROM users ; Selezionare colonne specifiche e usare alias ( AS ) \u00b6 Mostriamo title e content rinominato come description : SELECT title , content AS description FROM posts ; AS \u00e8 utile per rendere pi\u00f9 leggibile l\u2019output (o per nomi calcolati). Filtrare con WHERE (logica booleana) \u00b6 Esempio: tutti i post dell\u2019utente con user_id = 1 , ordinati alfabeticamente per titolo. SELECT title , content AS description FROM posts WHERE user_id = 1 ORDER BY title ASC ; Operatori utili in WHERE : confronti: = , != (o <> ), < , <= , > , >= combinazioni: AND , OR , NOT insiemi: IN (...) pattern: LIKE con % (qualsiasi sequenza) e _ (un carattere) intervalli: BETWEEN ... AND ... valori mancanti: IS NULL / IS NOT NULL (attenzione: = NULL non funziona) Esempi rapidi: -- utenti nati dal 1999 in poi SELECT username , born_year FROM users WHERE born_year >= 1999 ; -- utenti con username in una lista SELECT id , username FROM users WHERE username IN ( 'alice' , 'bob' , 'luca' ); -- utenti con email su un dominio SELECT id , email FROM users WHERE email LIKE '%@example.com' ; -- utenti senza anno di nascita (se la colonna pu\u00f2 essere NULL) SELECT id , username FROM users WHERE born_year IS NULL ; LIMIT e OFFSET (paginazione) \u00b6 Mostriamo 5 utenti per pagina, saltando i primi 10: SELECT id , username , email FROM users ORDER BY id ASC LIMIT 5 OFFSET 10 ; In paginazione, ORDER BY \u00e8 importante per avere risultati stabili e ripetibili. Modifica dei dati (UPDATE) \u00b6 UPDATE serve a modificare una o pi\u00f9 righe esistenti. Struttura: UPDATE <table> tabella da aggiornare SET <assegnazioni> colonne da cambiare ( colonna = valore ) WHERE <condizioni> quali righe aggiornare (quasi sempre necessario) Senza WHERE aggiorni tutte le righe della tabella: \u00e8 uno degli errori pi\u00f9 comuni e pericolosi. Aggiornare una singola riga \u00b6 Esempio: cambiamo l\u2019email dell\u2019utente con id = 1 . UPDATE users SET email = 'alice@newmail.com' WHERE id = 1 ; Aggiornare pi\u00f9 colonne nella stessa query \u00b6 UPDATE users SET username = 'alice_2' , email = 'alice2@example.com' WHERE id = 1 ; Aggiornare pi\u00f9 righe (in modo controllato) \u00b6 Esempio: cambiamo il dominio email di tutti gli utenti che hanno @example.com . UPDATE users SET email = REPLACE ( email , '@example.com' , '@newdomain.com' ) WHERE email LIKE '%@example.com' ; % indica \u201cqualsiasi sequenza di caratteri\u201d. Buone pratiche \u00b6 Prima di un UPDATE , esegui una SELECT con lo stesso WHERE per vedere quante righe verranno coinvolte: SELECT * FROM users WHERE id = 1 ; Usa WHERE specifici (PK, email univoche, combinazioni precise di condizioni). Se possibile, lavora in transazione quando aggiorni dati importanti (per poter annullare in caso di errore). Aggiorna solo i campi necessari. UPDATE modifica i dati: trattalo come un\u2019operazione potenzialmente irreversibile senza backup o transazioni. Cancellazione dei dati (DELETE) \u00b6 Il comando di cancellazione dei dati serve a rimuovere una o pi\u00f9 righe da una tabella. \u00c8 composto dalle seguenti parti: DELETE FROM <table> indica da quale tabella eliminare i record WHERE <filter conditions> specifica quali righe cancellare (quasi sempre necessario) Senza WHERE cancelli tutte le righe della tabella: \u00e8 un errore molto comune. Esempio: cancelliamo il post con id = 1 . DELETE FROM posts WHERE id = 1 ; Anche qui: senza WHERE \u2192 distruzione totale. Esercizi \u00b6 Esercizio 1 \u2014 Traduzione del modello \u00b6 Prendi il modello dati definito nel progetto e: individua tutte le entit\u00e0 scrivi le CREATE TABLE corrispondenti specifica PK, FK e vincoli Obiettivo: passare dal concetto alla struttura . Esercizio 2 \u2014 CRUD controllato \u00b6 Scrivi le query per: inserire un nuovo utente inserire due post dello stesso utente recuperare tutti i post di un utente aggiornare il titolo di un post cancellare un commento Motiva ogni WHERE . Esercizio 3 \u2014 Errori intenzionali \u00b6 Prova a: inserire due utenti con la stessa email inserire un post con user_id inesistente Osserva e spiega perch\u00e9 il database rifiuta l\u2019operazione .","title":"Lezione 02 \u2014 Primo contatto con SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#lezione-02-primo-contatto-con-sql","text":"","title":"Lezione 02 \u2014 Primo contatto con SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#problema","text":"Abbiamo un modello concettuale ed abbiamo creato le tabelle utenti, posts e commenti. Ora dobbiamo trasformarlo in una struttura reale: inserire dati di esempio interrogare e modificare quei dati in modo controllato Obiettivo: passare da \u201cidea\u201d a \u201csistema interrogabile\u201d. Questo significa introdurre SQL come strumento operativo.","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#cose-sql","text":"SQL (Structured Query Language) \u00e8 il linguaggio standard usato per: definire la struttura del database inserire dati leggere dati modificarli cancellarli SQL non \u00e8 un linguaggio di programmazione generale , ma un linguaggio dichiarativo: dici cosa vuoi ottenere, non come ottenerlo.","title":"Cos\u2019\u00e8 SQL"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#sql-linguaggio-dichiarativo","text":"SQL \u00e8 dichiarativo: descrive cosa vuoi ottenere, non come ottenerlo. In pratica lo useremo per: DDL (schema): CREATE , ALTER , DROP DML (dati): INSERT , SELECT , UPDATE , DELETE","title":"SQL: linguaggio dichiarativo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#il-concetto-di-schema","text":"Lo schema rappresenta la struttura del database: tabelle colonne tipi di dato vincoli relazioni \u00c8 il passaggio formale dal modello logico all\u2019 implementazione fisica .","title":"Il concetto di schema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#tipi-di-dato-db-agnostic","text":"Ogni colonna deve avere un tipo di dato. I tipi indicano: che valori sono ammessi come vengono memorizzati quali operazioni sono possibili I tipi di dato in DB-agnostic sono: - INTEGER - TEXT Di seguito una tabella riepilogativa dei principali tipi di dato, con la corrispondenza tra SQLite, MySQL e PostgreSQL e un\u2019indicazione della memoria occupata per campo. Tipo di dato SQLite MySQL PostgreSQL Memoria (indicativa) BOOLEAN INTEGER (0/1) BOOLEAN BOOLEAN 1 byte SMALLINT INTEGER SMALLINT SMALLINT 2 byte INTEGER INTEGER INT INTEGER 4 byte BIGINT INTEGER BIGINT BIGINT 8 byte DECIMAL/NUMERIC REAL / NUMERIC DECIMAL NUMERIC variabile REAL REAL FLOAT REAL 4 byte DOUBLE REAL DOUBLE DOUBLE PRECISION 8 byte CHAR TEXT CHAR CHAR fisso (n) VARCHAR TEXT VARCHAR VARCHAR variabile (n) TEXT TEXT TEXT TEXT variabile DATE TEXT / REAL DATE DATE 4 byte (PG), variabile TIME TEXT / REAL TIME TIME 8 byte (PG), variabile DATETIME TEXT / REAL DATETIME \u274c variabile TIMESTAMP TEXT / REAL TIMESTAMP TIMESTAMP 8 byte (PG), variabile BLOB/BINARY BLOB BLOB / BINARY BYTEA variabile JSON TEXT JSON JSON/JSONB variabile UUID TEXT \u274c UUID 16 byte","title":"Tipi di dato (DB-agnostic)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#crud","text":"Le operazioni fondamentali sui dati sono quattro: Operazione Significato SQL Create inserire dati INSERT Read leggere dati SELECT Update modificare dati UPDATE Delete cancellare dati DELETE Ogni sistema informativo, senza eccezioni, ruota attorno a queste operazioni.","title":"CRUD"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#query","text":"Una query \u00e8 una richiesta fatta al database. Caratteristiche: \u00e8 deterministica produce un risultato pu\u00f2 leggere o modificare dati La query pi\u00f9 comune \u00e8 SELECT .","title":"Query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#esempi","text":"Usiamo SQLite (semplice e locale), ma cerchiamo di scrivere SQL standard e portabile quando possibile.","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#inserimento-dei-dati-insert","text":"INSERT serve a creare nuove righe in una tabella. La forma pi\u00f9 comune \u00e8: INSERT INTO <table> (<colonne>) indica tabella e colonne da valorizzare VALUES (<valori>) indica i valori (nello stesso ordine delle colonne) Esempio: inseriamo un utente. INSERT INTO users ( username , email ) VALUES ( 'alice' , 'alice@example.com' ); Il database: assegna automaticamente la primary key (se id \u00e8 autoincrement) controlla i vincoli (es. NOT NULL , UNIQUE , CHECK ) controlla le foreign key (se abilitate/attive) Esempio: inseriamo un post collegato a un utente. INSERT INTO posts ( user_id , title , content ) VALUES ( 1 , 'Primo post' , 'Contenuto di esempio' ); Se user_id = 1 non esiste nella tabella users \u2192 errore di integrit\u00e0 referenziale (vincolo FK).","title":"Inserimento dei dati (INSERT)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#inserire-piu-righe-in-una-sola-query","text":"\u00c8 pi\u00f9 efficiente e riduce il numero di query. INSERT INTO users ( username , email , born_year , born_month , born_day ) VALUES ( 'bob' , 'bob@example.com' , 1999 , 10 , 1 ), ( 'rob' , 'rob@example.com' , 1999 , 1 , 10 ), ( 'carlo' , 'carlo@example.com' , 2000 , 7 , 22 ), ( 'dina' , 'dina@example.com' , 1997 , 11 , 5 ), ( 'elena' , 'elena@example.com' , 2001 , 1 , 9 ), ( 'franco' , 'franco@example.com' , 1995 , 9 , 30 ), ( 'giada' , 'giada@example.com' , 1996 , 12 , 14 ), ( 'luca' , 'luca@example.com' , 1999 , 4 , 2 ); Suggerimento: se stai inserendo dati \u201ccritici\u201d, considera l\u2019uso di transazioni ( BEGIN / COMMIT ) per rendere l\u2019operazione atomica.","title":"Inserire pi\u00f9 righe in una sola query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#lettura-dei-dati-select","text":"SELECT serve a leggere dati. Una query tipica \u00e8 composta da: SELECT <colonne> quali colonne vuoi vedere (oppure * per tutte) FROM <tabella> da dove leggere WHERE <condizioni> filtri (opzionale) ORDER BY <colonna> ASC|DESC ordinamento (opzionale) LIMIT <n> massimo numero di righe (opzionale) OFFSET <n> salta le prime n righe (opzionale, utile per paginazione) Nota: la sintassi corretta \u00e8 ORDER BY , non ORDERED BY .","title":"Lettura dei dati (SELECT)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#selezionare-tutte-le-righe","text":"SELECT * FROM users ;","title":"Selezionare tutte le righe"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#selezionare-colonne-specifiche-e-usare-alias-as","text":"Mostriamo title e content rinominato come description : SELECT title , content AS description FROM posts ; AS \u00e8 utile per rendere pi\u00f9 leggibile l\u2019output (o per nomi calcolati).","title":"Selezionare colonne specifiche e usare alias (AS)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#filtrare-con-where-logica-booleana","text":"Esempio: tutti i post dell\u2019utente con user_id = 1 , ordinati alfabeticamente per titolo. SELECT title , content AS description FROM posts WHERE user_id = 1 ORDER BY title ASC ; Operatori utili in WHERE : confronti: = , != (o <> ), < , <= , > , >= combinazioni: AND , OR , NOT insiemi: IN (...) pattern: LIKE con % (qualsiasi sequenza) e _ (un carattere) intervalli: BETWEEN ... AND ... valori mancanti: IS NULL / IS NOT NULL (attenzione: = NULL non funziona) Esempi rapidi: -- utenti nati dal 1999 in poi SELECT username , born_year FROM users WHERE born_year >= 1999 ; -- utenti con username in una lista SELECT id , username FROM users WHERE username IN ( 'alice' , 'bob' , 'luca' ); -- utenti con email su un dominio SELECT id , email FROM users WHERE email LIKE '%@example.com' ; -- utenti senza anno di nascita (se la colonna pu\u00f2 essere NULL) SELECT id , username FROM users WHERE born_year IS NULL ;","title":"Filtrare con WHERE (logica booleana)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#limit-e-offset-paginazione","text":"Mostriamo 5 utenti per pagina, saltando i primi 10: SELECT id , username , email FROM users ORDER BY id ASC LIMIT 5 OFFSET 10 ; In paginazione, ORDER BY \u00e8 importante per avere risultati stabili e ripetibili.","title":"LIMIT e OFFSET (paginazione)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#modifica-dei-dati-update","text":"UPDATE serve a modificare una o pi\u00f9 righe esistenti. Struttura: UPDATE <table> tabella da aggiornare SET <assegnazioni> colonne da cambiare ( colonna = valore ) WHERE <condizioni> quali righe aggiornare (quasi sempre necessario) Senza WHERE aggiorni tutte le righe della tabella: \u00e8 uno degli errori pi\u00f9 comuni e pericolosi.","title":"Modifica dei dati (UPDATE)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#aggiornare-una-singola-riga","text":"Esempio: cambiamo l\u2019email dell\u2019utente con id = 1 . UPDATE users SET email = 'alice@newmail.com' WHERE id = 1 ;","title":"Aggiornare una singola riga"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#aggiornare-piu-colonne-nella-stessa-query","text":"UPDATE users SET username = 'alice_2' , email = 'alice2@example.com' WHERE id = 1 ;","title":"Aggiornare pi\u00f9 colonne nella stessa query"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#aggiornare-piu-righe-in-modo-controllato","text":"Esempio: cambiamo il dominio email di tutti gli utenti che hanno @example.com . UPDATE users SET email = REPLACE ( email , '@example.com' , '@newdomain.com' ) WHERE email LIKE '%@example.com' ; % indica \u201cqualsiasi sequenza di caratteri\u201d.","title":"Aggiornare pi\u00f9 righe (in modo controllato)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#buone-pratiche","text":"Prima di un UPDATE , esegui una SELECT con lo stesso WHERE per vedere quante righe verranno coinvolte: SELECT * FROM users WHERE id = 1 ; Usa WHERE specifici (PK, email univoche, combinazioni precise di condizioni). Se possibile, lavora in transazione quando aggiorni dati importanti (per poter annullare in caso di errore). Aggiorna solo i campi necessari. UPDATE modifica i dati: trattalo come un\u2019operazione potenzialmente irreversibile senza backup o transazioni.","title":"Buone pratiche"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#cancellazione-dei-dati-delete","text":"Il comando di cancellazione dei dati serve a rimuovere una o pi\u00f9 righe da una tabella. \u00c8 composto dalle seguenti parti: DELETE FROM <table> indica da quale tabella eliminare i record WHERE <filter conditions> specifica quali righe cancellare (quasi sempre necessario) Senza WHERE cancelli tutte le righe della tabella: \u00e8 un errore molto comune. Esempio: cancelliamo il post con id = 1 . DELETE FROM posts WHERE id = 1 ; Anche qui: senza WHERE \u2192 distruzione totale.","title":"Cancellazione dei dati (DELETE)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#esercizi","text":"","title":"Esercizi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#esercizio-1-traduzione-del-modello","text":"Prendi il modello dati definito nel progetto e: individua tutte le entit\u00e0 scrivi le CREATE TABLE corrispondenti specifica PK, FK e vincoli Obiettivo: passare dal concetto alla struttura .","title":"Esercizio 1 \u2014 Traduzione del modello"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#esercizio-2-crud-controllato","text":"Scrivi le query per: inserire un nuovo utente inserire due post dello stesso utente recuperare tutti i post di un utente aggiornare il titolo di un post cancellare un commento Motiva ogni WHERE .","title":"Esercizio 2 \u2014 CRUD controllato"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-02/#esercizio-3-errori-intenzionali","text":"Prova a: inserire due utenti con la stessa email inserire un post con user_id inesistente Osserva e spiega perch\u00e9 il database rifiuta l\u2019operazione .","title":"Esercizio 3 \u2014 Errori intenzionali"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/","text":"Lezione 03 \u2014 Relazioni e JOIN \u00b6 Problema \u00b6 Nel progetto i dati sono distribuiti su pi\u00f9 tabelle: un post ha un autore (utente) un commento ha un autore e un post Se facciamo solo SELECT * FROM posts , otteniamo user_id , non il nome dell\u2019autore. Serve una query che combini tabelle in modo coerente. Obiettivo: leggere dati \u201crelazionali\u201d (post + autore, post + numero commenti, ecc.). Teoria \u00b6 JOIN: unire tabelle tramite chiavi \u00b6 Un JOIN combina righe di due (o pi\u00f9) tabelle usando una condizione (tipicamente FK \u2192 PK). Tipi principali: INNER JOIN : restituisce solo righe che matchano in entrambe le tabelle LEFT JOIN : restituisce tutte le righe della tabella a sinistra, anche se a destra non c\u2019\u00e8 match Regola mentale: INNER = \u201csolo ci\u00f2 che \u00e8 completo\u201d LEFT = \u201ctutto ci\u00f2 che \u00e8 a sinistra, con arricchimento quando possibile\u201d Alias e naming \u00b6 Usa alias ( users u ) per migliorare la leggibilit\u00e0 ed evitare ambiguit\u00e0 di nomi colonna. Esempi \u00b6 Mostrare i post insieme al nome dell\u2019autore (JOIN users ) \u00b6 Nella tabella posts abbiamo solo user_id (chiave esterna), quindi facciamo un JOIN verso users (chiave primaria users.id ) per \u201ctradurre\u201d l\u2019id in dati leggibili. SELECT p . id , -- id del post p . title , -- titolo del post u . username AS author -- username dell'autore (preso da users) FROM posts p JOIN users u ON u . id = p . user_id -- collega ogni post al suo autore ORDER BY p . id DESC ; -- ordina dal post pi\u00f9 recente (id pi\u00f9 alto) Cosa succede: posts p : partiamo dalla tabella dei post (alias p ). JOIN users u ON u.id = p.user_id : per ogni riga di posts , cerchiamo l\u2019utente con users.id uguale al user_id del post. Essendo un INNER JOIN (scrivere solo JOIN equivale a INNER JOIN ), i post senza autore valido (user_id che non punta a un utente esistente) non compariranno . Commenti con autore e post \u00b6 Se si volesse mostrare ogni commento arricchito con: - autore del commento (da users ) - titolo del post a cui il commento appartiene (da posts ) SELECT c . id , -- id del commento c . content , -- testo del commento u . username AS author , -- autore del commento p . title AS post_title -- titolo del post commentato FROM comments c JOIN users u ON u . id = c . user_id -- collega commento -> autore JOIN posts p ON p . id = c . post_id -- collega commento -> post ORDER BY c . id DESC ; -- dal commento pi\u00f9 recente Cosa succede: comments c : la tabella \u201ccentrale\u201d \u00e8 comments . Primo JOIN: c.user_id -> u.id per ottenere l\u2019autore. Secondo JOIN: c.post_id -> p.id per ottenere il post. Con INNER JOIN , verranno mostrati solo i commenti che: hanno un autore esistente e puntano a un post esistente Post anche senza commenti (LEFT JOIN) \u00b6 Adesso si vuole ottenere tutti i post e contare quanti commenti hanno, inclusi quelli con 0 commenti. Per includere anche i post senza match in comments , serve LEFT JOIN . SELECT p . id , -- id del post p . title , -- titolo del post COUNT ( c . id ) AS comment_count -- numero di commenti associati FROM posts p LEFT JOIN comments c ON c . post_id = p . id -- post -> commenti (se ci sono) GROUP BY p . id , p . title -- raggruppa per post per poter contare ORDER BY p . id DESC ; Cosa succede: LEFT JOIN : mantiene tutte le righe di posts . Se un post non ha commenti, le colonne di comments risultano NULL . COUNT(c.id) : conta solo i valori non NULL . Quindi, se non ci sono commenti, c.id \u00e8 NULL e il conteggio diventa 0 . GROUP BY p.id, p.title : serve perch\u00e9 stiamo facendo un\u2019aggregazione ( COUNT ) e vogliamo un risultato \u201cper post\u201d. Nota: evitare COUNT(*) in questo caso \u00e8 una buona pratica perch\u00e9 con il LEFT JOIN conteresti comunque la riga del post anche quando non esistono commenti, ottenendo 1 invece di 0 . Nota: la parte GROUP BY la formalizziamo nella prossima lezione, ma qui serve gi\u00e0 per \u201ccontare\u201d. Esercizi \u00b6 Obiettivo \u00b6 Progettare e interrogare un database relazionale che permetta di gestire: - studenti - corsi (classi) - iscrizioni degli studenti ai corsi Parte 1 \u2014 Creazione delle tabelle \u00b6 Crea una tabella students con i seguenti campi: id (chiave primaria, autoincrement) name (testo, obbligatorio) surname (testo, facoltativo) email (testo, obbligatorio) Crea una tabella classes con i seguenti campi: id (chiave primaria, autoincrement) name (testo, obbligatorio e univoco) hours (numero, obbligatorio) cfu (numero, facoltativo) Crea una tabella students_classes che rappresenti la relazione molti-a-molti tra studenti e corsi, contenente: id (chiave primaria) students_id (chiave esterna) classes_id (chiave esterna) Parte 2 \u2014 Inserimento dei dati \u00b6 Inserisci: - almeno 7 studenti - almeno 3 corsi - associa gli studenti ai corsi tramite la tabella students_classes Parte 3 \u2014 Verifica \u00b6 Mostra il contenuto di tutte le tabelle tramite query SELECT . Parte 4 \u2014 Join tra tabelle \u00b6 Scrivi una query che mostri: - nome dello studente - cognome dello studente - nome del corso a cui \u00e8 iscritto Soluzione community \u00b6 Best practice emerse: alias sempre JOIN ... ON ... leggibile (niente magia) LEFT JOIN quando vuoi mantenere \u201ctutto\u201d e arricchire per query con conteggi: LEFT JOIN + COUNT(c.id) (non COUNT(*) )","title":"Lezione 03 \u2014 Relazioni e JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#lezione-03-relazioni-e-join","text":"","title":"Lezione 03 \u2014 Relazioni e JOIN"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#problema","text":"Nel progetto i dati sono distribuiti su pi\u00f9 tabelle: un post ha un autore (utente) un commento ha un autore e un post Se facciamo solo SELECT * FROM posts , otteniamo user_id , non il nome dell\u2019autore. Serve una query che combini tabelle in modo coerente. Obiettivo: leggere dati \u201crelazionali\u201d (post + autore, post + numero commenti, ecc.).","title":"Problema"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#teoria","text":"","title":"Teoria"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#join-unire-tabelle-tramite-chiavi","text":"Un JOIN combina righe di due (o pi\u00f9) tabelle usando una condizione (tipicamente FK \u2192 PK). Tipi principali: INNER JOIN : restituisce solo righe che matchano in entrambe le tabelle LEFT JOIN : restituisce tutte le righe della tabella a sinistra, anche se a destra non c\u2019\u00e8 match Regola mentale: INNER = \u201csolo ci\u00f2 che \u00e8 completo\u201d LEFT = \u201ctutto ci\u00f2 che \u00e8 a sinistra, con arricchimento quando possibile\u201d","title":"JOIN: unire tabelle tramite chiavi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#alias-e-naming","text":"Usa alias ( users u ) per migliorare la leggibilit\u00e0 ed evitare ambiguit\u00e0 di nomi colonna.","title":"Alias e naming"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#esempi","text":"","title":"Esempi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#mostrare-i-post-insieme-al-nome-dellautore-join-users","text":"Nella tabella posts abbiamo solo user_id (chiave esterna), quindi facciamo un JOIN verso users (chiave primaria users.id ) per \u201ctradurre\u201d l\u2019id in dati leggibili. SELECT p . id , -- id del post p . title , -- titolo del post u . username AS author -- username dell'autore (preso da users) FROM posts p JOIN users u ON u . id = p . user_id -- collega ogni post al suo autore ORDER BY p . id DESC ; -- ordina dal post pi\u00f9 recente (id pi\u00f9 alto) Cosa succede: posts p : partiamo dalla tabella dei post (alias p ). JOIN users u ON u.id = p.user_id : per ogni riga di posts , cerchiamo l\u2019utente con users.id uguale al user_id del post. Essendo un INNER JOIN (scrivere solo JOIN equivale a INNER JOIN ), i post senza autore valido (user_id che non punta a un utente esistente) non compariranno .","title":"Mostrare i post insieme al nome dell\u2019autore (JOIN users)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#commenti-con-autore-e-post","text":"Se si volesse mostrare ogni commento arricchito con: - autore del commento (da users ) - titolo del post a cui il commento appartiene (da posts ) SELECT c . id , -- id del commento c . content , -- testo del commento u . username AS author , -- autore del commento p . title AS post_title -- titolo del post commentato FROM comments c JOIN users u ON u . id = c . user_id -- collega commento -> autore JOIN posts p ON p . id = c . post_id -- collega commento -> post ORDER BY c . id DESC ; -- dal commento pi\u00f9 recente Cosa succede: comments c : la tabella \u201ccentrale\u201d \u00e8 comments . Primo JOIN: c.user_id -> u.id per ottenere l\u2019autore. Secondo JOIN: c.post_id -> p.id per ottenere il post. Con INNER JOIN , verranno mostrati solo i commenti che: hanno un autore esistente e puntano a un post esistente","title":"Commenti con autore e post"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#post-anche-senza-commenti-left-join","text":"Adesso si vuole ottenere tutti i post e contare quanti commenti hanno, inclusi quelli con 0 commenti. Per includere anche i post senza match in comments , serve LEFT JOIN . SELECT p . id , -- id del post p . title , -- titolo del post COUNT ( c . id ) AS comment_count -- numero di commenti associati FROM posts p LEFT JOIN comments c ON c . post_id = p . id -- post -> commenti (se ci sono) GROUP BY p . id , p . title -- raggruppa per post per poter contare ORDER BY p . id DESC ; Cosa succede: LEFT JOIN : mantiene tutte le righe di posts . Se un post non ha commenti, le colonne di comments risultano NULL . COUNT(c.id) : conta solo i valori non NULL . Quindi, se non ci sono commenti, c.id \u00e8 NULL e il conteggio diventa 0 . GROUP BY p.id, p.title : serve perch\u00e9 stiamo facendo un\u2019aggregazione ( COUNT ) e vogliamo un risultato \u201cper post\u201d. Nota: evitare COUNT(*) in questo caso \u00e8 una buona pratica perch\u00e9 con il LEFT JOIN conteresti comunque la riga del post anche quando non esistono commenti, ottenendo 1 invece di 0 . Nota: la parte GROUP BY la formalizziamo nella prossima lezione, ma qui serve gi\u00e0 per \u201ccontare\u201d.","title":"Post anche senza commenti (LEFT JOIN)"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#esercizi","text":"","title":"Esercizi"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#obiettivo","text":"Progettare e interrogare un database relazionale che permetta di gestire: - studenti - corsi (classi) - iscrizioni degli studenti ai corsi","title":"Obiettivo"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-1-creazione-delle-tabelle","text":"Crea una tabella students con i seguenti campi: id (chiave primaria, autoincrement) name (testo, obbligatorio) surname (testo, facoltativo) email (testo, obbligatorio) Crea una tabella classes con i seguenti campi: id (chiave primaria, autoincrement) name (testo, obbligatorio e univoco) hours (numero, obbligatorio) cfu (numero, facoltativo) Crea una tabella students_classes che rappresenti la relazione molti-a-molti tra studenti e corsi, contenente: id (chiave primaria) students_id (chiave esterna) classes_id (chiave esterna)","title":"Parte 1 \u2014 Creazione delle tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-2-inserimento-dei-dati","text":"Inserisci: - almeno 7 studenti - almeno 3 corsi - associa gli studenti ai corsi tramite la tabella students_classes","title":"Parte 2 \u2014 Inserimento dei dati"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-3-verifica","text":"Mostra il contenuto di tutte le tabelle tramite query SELECT .","title":"Parte 3 \u2014 Verifica"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#parte-4-join-tra-tabelle","text":"Scrivi una query che mostri: - nome dello studente - cognome dello studente - nome del corso a cui \u00e8 iscritto","title":"Parte 4 \u2014 Join tra tabelle"},{"location":"corsi/corso-database-sql/moduli/01-fondamenti/lezione-03/#soluzione-community","text":"Best practice emerse: alias sempre JOIN ... ON ... leggibile (niente magia) LEFT JOIN quando vuoi mantenere \u201ctutto\u201d e arricchire per query con conteggi: LEFT JOIN + COUNT(c.id) (non COUNT(*) )","title":"Soluzione community"},{"location":"corsi/corso-database-sql/progetto/","text":"Progetto del corso \u00b6 Tutto il corso di Database SQL \u00e8 costruito attorno a un unico progetto reale , che evolve progressivamente modulo dopo modulo. L\u2019obiettivo non \u00e8 imparare SQL a memoria , ma capire perch\u00e9 e quando usare gli strumenti che SQL mette a disposizione. Obiettivo del progetto \u00b6 Progettare e sviluppare un sistema di gestione dati per una piattaforma con: utenti contenuti creati dagli utenti relazioni tra contenuti possibilit\u00e0 di estensione futura Il progetto deve essere: - coerente - scalabile - modellato correttamente - indipendente dal database specifico (DB-agnostic) Metodo di lavoro \u00b6 Ogni modulo del corso: 1. introduce un problema reale 2. fornisce gli strumenti teorici necessari 3. applica tali strumenti al progetto 4. estende progressivamente il modello dati Il progetto non viene mai azzerato : cresce con il corso. Navigazione \u00b6 Problema iniziale Requisiti Modello dati","title":"Introduzione"},{"location":"corsi/corso-database-sql/progetto/#progetto-del-corso","text":"Tutto il corso di Database SQL \u00e8 costruito attorno a un unico progetto reale , che evolve progressivamente modulo dopo modulo. L\u2019obiettivo non \u00e8 imparare SQL a memoria , ma capire perch\u00e9 e quando usare gli strumenti che SQL mette a disposizione.","title":"Progetto del corso"},{"location":"corsi/corso-database-sql/progetto/#obiettivo-del-progetto","text":"Progettare e sviluppare un sistema di gestione dati per una piattaforma con: utenti contenuti creati dagli utenti relazioni tra contenuti possibilit\u00e0 di estensione futura Il progetto deve essere: - coerente - scalabile - modellato correttamente - indipendente dal database specifico (DB-agnostic)","title":"Obiettivo del progetto"},{"location":"corsi/corso-database-sql/progetto/#metodo-di-lavoro","text":"Ogni modulo del corso: 1. introduce un problema reale 2. fornisce gli strumenti teorici necessari 3. applica tali strumenti al progetto 4. estende progressivamente il modello dati Il progetto non viene mai azzerato : cresce con il corso.","title":"Metodo di lavoro"},{"location":"corsi/corso-database-sql/progetto/#navigazione","text":"Problema iniziale Requisiti Modello dati","title":"Navigazione"},{"location":"corsi/corso-database-sql/progetto/modello-dati/","text":"Modello dei dati \u00b6 Questa sezione introduce il modello dei dati iniziale , che verr\u00e0 esteso progressivamente durante il corso. Il modello non \u00e8 definitivo : evolve insieme alle competenze acquisite. Entit\u00e0 principali \u00b6 In base al problema e ai requisiti individuiamo le seguenti entit\u00e0 fondamentali. Utente ( users ) \u00b6 Rappresenta una persona che utilizza la piattaforma. Attributi principali: identificatore univoco username email born_year born_month born_day Contenuto ( posts ) \u00b6 Rappresenta un contenuto creato da un utente. Attributi principali: identificatore univoco autore titolo testo Relazione: ogni contenuto appartiene a un solo utente un utente pu\u00f2 creare pi\u00f9 contenuti Commento ( comments ) \u00b6 Rappresenta un\u2019interazione su un contenuto. Attributi principali: identificatore univoco autore contenuto testuale Relazioni: ogni commento \u00e8 associato a un utente ogni commento \u00e8 associato a un contenuto Categoria ( categories ) \u00b6 Serve per classificare i contenuti. Relazione: un contenuto pu\u00f2 appartenere a pi\u00f9 categorie una categoria pu\u00f2 essere associata a pi\u00f9 contenuti Questo richiede una relazione many-to-many . Relazioni tra entit\u00e0 \u00b6 Entit\u00e0 A Entit\u00e0 B Tipo users posts 1 : N users comments 1 : N posts comments 1 : N posts categories N : M Considerazioni di modellazione \u00b6 ogni entit\u00e0 ha una primary key le relazioni sono esplicite tramite foreign key le relazioni N:M usano una tabella di collegamento nessuna informazione \u00e8 duplicata inutilmente Questo modello segue i principi della normalizzazione e pu\u00f2 essere implementato su qualsiasi database relazionale. Evoluzione del modello \u00b6 Durante il corso il modello verr\u00e0 esteso con: metadati gestione temporale ottimizzazioni di performance adattamenti per database diversi Il modello \u00e8 un oggetto vivo , non un diagramma statico.","title":"Modello dati"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#modello-dei-dati","text":"Questa sezione introduce il modello dei dati iniziale , che verr\u00e0 esteso progressivamente durante il corso. Il modello non \u00e8 definitivo : evolve insieme alle competenze acquisite.","title":"Modello dei dati"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#entita-principali","text":"In base al problema e ai requisiti individuiamo le seguenti entit\u00e0 fondamentali.","title":"Entit\u00e0 principali"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#utente-users","text":"Rappresenta una persona che utilizza la piattaforma. Attributi principali: identificatore univoco username email born_year born_month born_day","title":"Utente (users)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#contenuto-posts","text":"Rappresenta un contenuto creato da un utente. Attributi principali: identificatore univoco autore titolo testo Relazione: ogni contenuto appartiene a un solo utente un utente pu\u00f2 creare pi\u00f9 contenuti","title":"Contenuto (posts)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#commento-comments","text":"Rappresenta un\u2019interazione su un contenuto. Attributi principali: identificatore univoco autore contenuto testuale Relazioni: ogni commento \u00e8 associato a un utente ogni commento \u00e8 associato a un contenuto","title":"Commento (comments)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#categoria-categories","text":"Serve per classificare i contenuti. Relazione: un contenuto pu\u00f2 appartenere a pi\u00f9 categorie una categoria pu\u00f2 essere associata a pi\u00f9 contenuti Questo richiede una relazione many-to-many .","title":"Categoria (categories)"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#relazioni-tra-entita","text":"Entit\u00e0 A Entit\u00e0 B Tipo users posts 1 : N users comments 1 : N posts comments 1 : N posts categories N : M","title":"Relazioni tra entit\u00e0"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#considerazioni-di-modellazione","text":"ogni entit\u00e0 ha una primary key le relazioni sono esplicite tramite foreign key le relazioni N:M usano una tabella di collegamento nessuna informazione \u00e8 duplicata inutilmente Questo modello segue i principi della normalizzazione e pu\u00f2 essere implementato su qualsiasi database relazionale.","title":"Considerazioni di modellazione"},{"location":"corsi/corso-database-sql/progetto/modello-dati/#evoluzione-del-modello","text":"Durante il corso il modello verr\u00e0 esteso con: metadati gestione temporale ottimizzazioni di performance adattamenti per database diversi Il modello \u00e8 un oggetto vivo , non un diagramma statico.","title":"Evoluzione del modello"},{"location":"corsi/corso-database-sql/progetto/problema/","text":"Problema iniziale \u00b6 Il corso nasce dalla necessit\u00e0 di risolvere un problema concreto e realistico: progettare un sistema affidabile per la gestione di dati strutturati, interconnessi e soggetti a evoluzione nel tempo. Non partiamo dal linguaggio SQL, ma dal problema che rende necessario SQL . Contesto \u00b6 Immaginiamo di dover sviluppare una piattaforma che permetta a pi\u00f9 utenti di: registrarsi e autenticarsi creare contenuti interagire con contenuti creati da altri utenti organizzare e classificare i contenuti Il sistema deve funzionare: nel tempo con dati in crescita con pi\u00f9 utenti simultanei senza perdere coerenza dei dati Approccio ingenuo (e perch\u00e9 fallisce) \u00b6 Una prima soluzione potrebbe essere usare: file di testo file CSV file JSON Questa soluzione fallisce rapidamente perch\u00e9: non esiste un\u2019identit\u00e0 univoca garantita le relazioni sono fragili e manuali i dati possono diventare incoerenti la ricerca diventa inefficiente la concorrenza non \u00e8 gestibile Problema centrale \u00b6 Il problema non \u00e8 salvare dati , ma: modellare correttamente le informazioni definire relazioni affidabili garantire integrit\u00e0 e coerenza permettere interrogazioni efficienti supportare evoluzione e manutenzione \ud83d\udc49 Questo \u00e8 esattamente ci\u00f2 che un database relazionale risolve. Obiettivo del corso rispetto al problema \u00b6 Il corso mostra come risolvere questo problema passo dopo passo , introducendo solo gli strumenti necessari nel momento in cui servono. Non studiamo SQL \u201cper capitoli\u201d, ma per esigenze reali che emergono dal progetto.","title":"Problema iniziale"},{"location":"corsi/corso-database-sql/progetto/problema/#problema-iniziale","text":"Il corso nasce dalla necessit\u00e0 di risolvere un problema concreto e realistico: progettare un sistema affidabile per la gestione di dati strutturati, interconnessi e soggetti a evoluzione nel tempo. Non partiamo dal linguaggio SQL, ma dal problema che rende necessario SQL .","title":"Problema iniziale"},{"location":"corsi/corso-database-sql/progetto/problema/#contesto","text":"Immaginiamo di dover sviluppare una piattaforma che permetta a pi\u00f9 utenti di: registrarsi e autenticarsi creare contenuti interagire con contenuti creati da altri utenti organizzare e classificare i contenuti Il sistema deve funzionare: nel tempo con dati in crescita con pi\u00f9 utenti simultanei senza perdere coerenza dei dati","title":"Contesto"},{"location":"corsi/corso-database-sql/progetto/problema/#approccio-ingenuo-e-perche-fallisce","text":"Una prima soluzione potrebbe essere usare: file di testo file CSV file JSON Questa soluzione fallisce rapidamente perch\u00e9: non esiste un\u2019identit\u00e0 univoca garantita le relazioni sono fragili e manuali i dati possono diventare incoerenti la ricerca diventa inefficiente la concorrenza non \u00e8 gestibile","title":"Approccio ingenuo (e perch\u00e9 fallisce)"},{"location":"corsi/corso-database-sql/progetto/problema/#problema-centrale","text":"Il problema non \u00e8 salvare dati , ma: modellare correttamente le informazioni definire relazioni affidabili garantire integrit\u00e0 e coerenza permettere interrogazioni efficienti supportare evoluzione e manutenzione \ud83d\udc49 Questo \u00e8 esattamente ci\u00f2 che un database relazionale risolve.","title":"Problema centrale"},{"location":"corsi/corso-database-sql/progetto/problema/#obiettivo-del-corso-rispetto-al-problema","text":"Il corso mostra come risolvere questo problema passo dopo passo , introducendo solo gli strumenti necessari nel momento in cui servono. Non studiamo SQL \u201cper capitoli\u201d, ma per esigenze reali che emergono dal progetto.","title":"Obiettivo del corso rispetto al problema"},{"location":"corsi/corso-database-sql/progetto/requisiti/","text":"Requisiti del sistema \u00b6 Questa sezione definisce cosa il sistema deve fare e quali vincoli deve rispettare . I requisiti guidano tutte le decisioni di progettazione che verranno prese nel corso. Requisiti funzionali \u00b6 Il sistema deve permettere di: gestire utenti identificazione univoca informazioni di base (username, email) gestire contenuti ogni contenuto \u00e8 associato a un autore i contenuti hanno titolo e corpo testuale gestire interazioni commenti ai contenuti relazioni chiare tra utenti e contenuti classificare i contenuti categorie o tag possibilit\u00e0 di estensione futura Requisiti non funzionali \u00b6 Il sistema deve essere: coerente i dati non devono mai trovarsi in stati invalidi scalabile il modello deve reggere l\u2019aumento dei dati manutenibile facile da estendere senza riscrivere tutto DB-agnostic il modello non deve dipendere da un singolo database collaborativo la documentazione e le soluzioni devono poter evolvere Vincoli progettuali \u00b6 Durante il corso imponiamo alcuni vincoli intenzionali: uso esclusivo di database relazionali utilizzo di SQL standard quando possibile separazione chiara tra: modello concettuale modello logico implementazione fisica Questi vincoli non limitano , ma aiutano a ragionare correttamente. Implicazioni \u00b6 Dai requisiti derivano scelte fondamentali: uso di primary key e foreign key normalizzazione dei dati modellazione esplicita delle relazioni utilizzo di transazioni Ogni concetto teorico del corso nasce da qui.","title":"Requisiti"},{"location":"corsi/corso-database-sql/progetto/requisiti/#requisiti-del-sistema","text":"Questa sezione definisce cosa il sistema deve fare e quali vincoli deve rispettare . I requisiti guidano tutte le decisioni di progettazione che verranno prese nel corso.","title":"Requisiti del sistema"},{"location":"corsi/corso-database-sql/progetto/requisiti/#requisiti-funzionali","text":"Il sistema deve permettere di: gestire utenti identificazione univoca informazioni di base (username, email) gestire contenuti ogni contenuto \u00e8 associato a un autore i contenuti hanno titolo e corpo testuale gestire interazioni commenti ai contenuti relazioni chiare tra utenti e contenuti classificare i contenuti categorie o tag possibilit\u00e0 di estensione futura","title":"Requisiti funzionali"},{"location":"corsi/corso-database-sql/progetto/requisiti/#requisiti-non-funzionali","text":"Il sistema deve essere: coerente i dati non devono mai trovarsi in stati invalidi scalabile il modello deve reggere l\u2019aumento dei dati manutenibile facile da estendere senza riscrivere tutto DB-agnostic il modello non deve dipendere da un singolo database collaborativo la documentazione e le soluzioni devono poter evolvere","title":"Requisiti non funzionali"},{"location":"corsi/corso-database-sql/progetto/requisiti/#vincoli-progettuali","text":"Durante il corso imponiamo alcuni vincoli intenzionali: uso esclusivo di database relazionali utilizzo di SQL standard quando possibile separazione chiara tra: modello concettuale modello logico implementazione fisica Questi vincoli non limitano , ma aiutano a ragionare correttamente.","title":"Vincoli progettuali"},{"location":"corsi/corso-database-sql/progetto/requisiti/#implicazioni","text":"Dai requisiti derivano scelte fondamentali: uso di primary key e foreign key normalizzazione dei dati modellazione esplicita delle relazioni utilizzo di transazioni Ogni concetto teorico del corso nasce da qui.","title":"Implicazioni"},{"location":"corsi/makedocs/","text":"title: Makedocks \u2014 Introduzione \u00b6 Makedocks \u00b6 Questo testo introduce Makedocks come strumento per la generazione di documentazione statica a partire da file Markdown. L\u2019obiettivo \u00e8 fornire una base concettuale solida prima di entrare nell\u2019uso operativo dello strumento. Questo documento spiega cos\u2019\u00e8 Makedocks, come si usa in un progetto Python, come si costruisce (build) e come si serve la documentazione, con particolare attenzione alla struttura dei file e al modo corretto di modificarli. \u00c8 pensato come riferimento pratico, utilizzabile sia in fase di apprendimento sia come documentazione di consultazione. 1. Cos\u2019\u00e8 Makedocks \u00b6 Makedocks \u00e8 uno strumento che consente di generare siti di documentazione statica a partire da file Markdown. Il risultato finale \u00e8 un insieme di file HTML pronti per essere consultati tramite browser, senza la necessit\u00e0 di un backend o di un database. Il flusso di lavoro \u00e8 lineare: Markdown \u2192 build \u2192 HTML statico Makedocks non \u00e8 un framework web n\u00e9 un sistema di gestione dei contenuti. \u00c8 un generatore di documentazione pensato per organizzare e pubblicare contenuti tecnici in modo strutturato. 2. Perch\u00e9 usare Makedocks \u00b6 Makedocks consente di mantenere la documentazione separata dal codice, versionabile e facilmente distribuibile come sito statico. \u00c8 adatto a corsi, progetti tecnici e librerie Python in cui la chiarezza strutturale e la manutenibilit\u00e0 della documentazione sono requisiti centrali. 3. Requisiti \u00b6 Prima di iniziare assicurati di avere: Python \u2265 3.8 pip terminale / CLI Verifica: python --version pip --version 4. Installazione \u00b6 Makedocks si installa tramite pip . pip install makedocks Verifica installazione: makedocks --help Se vedi l\u2019help, \u00e8 installato correttamente. 5. Struttura di un progetto Makedocks \u00b6 Un progetto Makedocks tipico ha questa struttura: project/ \u251c\u2500\u2500 docs/ \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 introduzione.md \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 makedocks.yml \u2514\u2500\u2500 site/ Spiegazione: docs/ \u2192 sorgente Markdown makedocks.yml \u2192 configurazione site/ \u2192 output generato (HTML) site/ non si scrive a mano . 6. Il file di configurazione \u00b6 Questo file controlla tutto. Esempio minimale: site_name : Corso Database SQL site_url : http://localhost nav : - Home : index.md - Introduzione : introduzione.md Cosa significa \u00b6 site_name \u2192 titolo del sito site_url \u2192 URL base (locale o produzione) nav \u2192 menu di navigazione La navigazione definisce l\u2019ordine delle pagine. Se un file non \u00e8 nel nav , non \u00e8 visibile . 7. I file Markdown \u00b6 I contenuti della documentazione sono scritti in file Markdown ( .md ) e collocati nella cartella docs/ . Ogni file rappresenta una singola pagina. Per la sintassi, le regole di scrittura e le convenzioni adottate nel corso, fare riferimento al materiale dedicato: \u27a1\ufe0f Corso Markdown (link interno al corso) title: Introduzione \u00b6 Introduzione \u00b6 Questo \u00e8 il contenuto della pagina. ### Front\u2011matter La parte tra `---` \u00e8 il **front\u2011matter**. Serve per: - titolo - metadata - configurazioni specifiche della pagina Minimo consigliato: ```md --- title: Nome pagina --- 8. Organizzazione dei file \u00b6 Ogni file Markdown corrisponde a una singola pagina della documentazione. I nomi dei file devono essere coerenti, leggibili e privi di spazi. La struttura deve riflettere l\u2019organizzazione logica dei contenuti, non esigenze estetiche. 9. Build della documentazione \u00b6 Per generare il sito: makedocks build Risultato: viene creata (o aggiornata) la cartella site/ HTML, CSS e JS pronti Ogni modifica ai .md richiede una nuova build. 10. Servire la documentazione in locale \u00b6 Per vedere il sito in locale: makedocks serve Di default: http://127.0.0.1:8000 Vantaggi: hot reload preview immediata ambiente di lavoro sicuro 11. Modificare la documentazione \u00b6 Workflow corretto: apri un file .md modifica il contenuto salva ricarica il browser (se in serve) Non modificare mai i file dentro site/ . site/ \u00e8 output , non sorgente. 12. Aggiungere una nuova pagina \u00b6 Passaggi obbligatori: crea il file in docs/ scrivi il contenuto aggiungilo al nav in makedocks.yml Esempio: nav : - Home : index.md - Modelli : modelli.md Se salti il punto 3, la pagina non esiste. 13. Errori comuni \u00b6 Gli errori pi\u00f9 frequenti riguardano la configurazione della navigazione e la modifica diretta dei file generati. In caso di problemi di visualizzazione, il primo punto da verificare \u00e8 sempre il file makedocks.yml . 14. Versionamento \u00b6 Buona pratica: versionare docs/ versionare makedocks.yml non versionare site/ Aggiungi a .gitignore : site/ 15. Collegamento al corso Markdown \u00b6 Per imparare o ripassare Markdown in modo sistematico: \u27a1\ufe0f Corso Markdown (link interno al corso)[/docs/corsi/markdown]","title":"Index"},{"location":"corsi/makedocs/#title-makedocks-introduzione","text":"","title":"title: Makedocks \u2014 Introduzione"},{"location":"corsi/makedocs/#makedocks","text":"Questo testo introduce Makedocks come strumento per la generazione di documentazione statica a partire da file Markdown. L\u2019obiettivo \u00e8 fornire una base concettuale solida prima di entrare nell\u2019uso operativo dello strumento. Questo documento spiega cos\u2019\u00e8 Makedocks, come si usa in un progetto Python, come si costruisce (build) e come si serve la documentazione, con particolare attenzione alla struttura dei file e al modo corretto di modificarli. \u00c8 pensato come riferimento pratico, utilizzabile sia in fase di apprendimento sia come documentazione di consultazione.","title":"Makedocks"},{"location":"corsi/makedocs/#1-cose-makedocks","text":"Makedocks \u00e8 uno strumento che consente di generare siti di documentazione statica a partire da file Markdown. Il risultato finale \u00e8 un insieme di file HTML pronti per essere consultati tramite browser, senza la necessit\u00e0 di un backend o di un database. Il flusso di lavoro \u00e8 lineare: Markdown \u2192 build \u2192 HTML statico Makedocks non \u00e8 un framework web n\u00e9 un sistema di gestione dei contenuti. \u00c8 un generatore di documentazione pensato per organizzare e pubblicare contenuti tecnici in modo strutturato.","title":"1. Cos\u2019\u00e8 Makedocks"},{"location":"corsi/makedocs/#2-perche-usare-makedocks","text":"Makedocks consente di mantenere la documentazione separata dal codice, versionabile e facilmente distribuibile come sito statico. \u00c8 adatto a corsi, progetti tecnici e librerie Python in cui la chiarezza strutturale e la manutenibilit\u00e0 della documentazione sono requisiti centrali.","title":"2. Perch\u00e9 usare Makedocks"},{"location":"corsi/makedocs/#3-requisiti","text":"Prima di iniziare assicurati di avere: Python \u2265 3.8 pip terminale / CLI Verifica: python --version pip --version","title":"3. Requisiti"},{"location":"corsi/makedocs/#4-installazione","text":"Makedocks si installa tramite pip . pip install makedocks Verifica installazione: makedocks --help Se vedi l\u2019help, \u00e8 installato correttamente.","title":"4. Installazione"},{"location":"corsi/makedocs/#5-struttura-di-un-progetto-makedocks","text":"Un progetto Makedocks tipico ha questa struttura: project/ \u251c\u2500\u2500 docs/ \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 introduzione.md \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 makedocks.yml \u2514\u2500\u2500 site/ Spiegazione: docs/ \u2192 sorgente Markdown makedocks.yml \u2192 configurazione site/ \u2192 output generato (HTML) site/ non si scrive a mano .","title":"5. Struttura di un progetto Makedocks"},{"location":"corsi/makedocs/#6-il-file-di-configurazione","text":"Questo file controlla tutto. Esempio minimale: site_name : Corso Database SQL site_url : http://localhost nav : - Home : index.md - Introduzione : introduzione.md","title":"6. Il file di configurazione"},{"location":"corsi/makedocs/#cosa-significa","text":"site_name \u2192 titolo del sito site_url \u2192 URL base (locale o produzione) nav \u2192 menu di navigazione La navigazione definisce l\u2019ordine delle pagine. Se un file non \u00e8 nel nav , non \u00e8 visibile .","title":"Cosa significa"},{"location":"corsi/makedocs/#7-i-file-markdown","text":"I contenuti della documentazione sono scritti in file Markdown ( .md ) e collocati nella cartella docs/ . Ogni file rappresenta una singola pagina. Per la sintassi, le regole di scrittura e le convenzioni adottate nel corso, fare riferimento al materiale dedicato: \u27a1\ufe0f Corso Markdown (link interno al corso)","title":"7. I file Markdown"},{"location":"corsi/makedocs/#title-introduzione","text":"","title":"title: Introduzione"},{"location":"corsi/makedocs/#introduzione","text":"Questo \u00e8 il contenuto della pagina. ### Front\u2011matter La parte tra `---` \u00e8 il **front\u2011matter**. Serve per: - titolo - metadata - configurazioni specifiche della pagina Minimo consigliato: ```md --- title: Nome pagina ---","title":"Introduzione"},{"location":"corsi/makedocs/#8-organizzazione-dei-file","text":"Ogni file Markdown corrisponde a una singola pagina della documentazione. I nomi dei file devono essere coerenti, leggibili e privi di spazi. La struttura deve riflettere l\u2019organizzazione logica dei contenuti, non esigenze estetiche.","title":"8. Organizzazione dei file"},{"location":"corsi/makedocs/#9-build-della-documentazione","text":"Per generare il sito: makedocks build Risultato: viene creata (o aggiornata) la cartella site/ HTML, CSS e JS pronti Ogni modifica ai .md richiede una nuova build.","title":"9. Build della documentazione"},{"location":"corsi/makedocs/#10-servire-la-documentazione-in-locale","text":"Per vedere il sito in locale: makedocks serve Di default: http://127.0.0.1:8000 Vantaggi: hot reload preview immediata ambiente di lavoro sicuro","title":"10. Servire la documentazione in locale"},{"location":"corsi/makedocs/#11-modificare-la-documentazione","text":"Workflow corretto: apri un file .md modifica il contenuto salva ricarica il browser (se in serve) Non modificare mai i file dentro site/ . site/ \u00e8 output , non sorgente.","title":"11. Modificare la documentazione"},{"location":"corsi/makedocs/#12-aggiungere-una-nuova-pagina","text":"Passaggi obbligatori: crea il file in docs/ scrivi il contenuto aggiungilo al nav in makedocks.yml Esempio: nav : - Home : index.md - Modelli : modelli.md Se salti il punto 3, la pagina non esiste.","title":"12. Aggiungere una nuova pagina"},{"location":"corsi/makedocs/#13-errori-comuni","text":"Gli errori pi\u00f9 frequenti riguardano la configurazione della navigazione e la modifica diretta dei file generati. In caso di problemi di visualizzazione, il primo punto da verificare \u00e8 sempre il file makedocks.yml .","title":"13. Errori comuni"},{"location":"corsi/makedocs/#14-versionamento","text":"Buona pratica: versionare docs/ versionare makedocks.yml non versionare site/ Aggiungi a .gitignore : site/","title":"14. Versionamento"},{"location":"corsi/makedocs/#15-collegamento-al-corso-markdown","text":"Per imparare o ripassare Markdown in modo sistematico: \u27a1\ufe0f Corso Markdown (link interno al corso)[/docs/corsi/markdown]","title":"15. Collegamento al corso Markdown"}]}